<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>我的leetcode刷题记录 | zhanghm的个人博客</title><meta name="author" content="zhanghm"><meta name="copyright" content="zhanghm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组① 二分查找使用情景 有序数组 无重复元素(有重复元素时的返回值不唯一，需要深思)  边界条件 左闭右开  区间【left,right),对应代码：while(left &lt; right)  右指针没意义，即right &#x3D; nums.length   左闭右闭  区间【left,right】,对应代码：while(left &lt;&#x3D; right)  右指针有意义，即r">
<meta property="og:type" content="article">
<meta property="og:title" content="我的leetcode刷题记录">
<meta property="og:url" content="https://zhanghm0915.github.io/2023/03/29/myleetcode/myleetcode/index.html">
<meta property="og:site_name" content="zhanghm的个人博客">
<meta property="og:description" content="数组① 二分查找使用情景 有序数组 无重复元素(有重复元素时的返回值不唯一，需要深思)  边界条件 左闭右开  区间【left,right),对应代码：while(left &lt; right)  右指针没意义，即right &#x3D; nums.length   左闭右闭  区间【left,right】,对应代码：while(left &lt;&#x3D; right)  右指针有意义，即r">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003731-16221334517645.jpg">
<meta property="article:published_time" content="2023-03-29T08:49:03.000Z">
<meta property="article:modified_time" content="2023-03-29T09:05:44.077Z">
<meta property="article:author" content="zhanghm">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003731-16221334517645.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhanghm0915.github.io/2023/03/29/myleetcode/myleetcode/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '我的leetcode刷题记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-29 17:05:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/213705-1550497025568e.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhanghm的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">我的leetcode刷题记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T08:49:03.000Z" title="发表于 2023-03-29 16:49:03">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-29T09:05:44.077Z" title="更新于 2023-03-29 17:05:44">2023-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode/">leetcode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>147分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="我的leetcode刷题记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="①-二分查找"><a href="#①-二分查找" class="headerlink" title="① 二分查找"></a>① 二分查找</h2><h3 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h3><ol>
<li>有序数组</li>
<li>无重复元素(有重复元素时的返回值不唯一，需要深思)</li>
</ol>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul>
<li><p>左闭右开</p>
<blockquote>
<p>区间【left,right),对应代码：while(left &lt; right)<br>  右指针没意义，即right &#x3D; nums.length</p>
</blockquote>
</li>
<li><p>左闭右闭</p>
<blockquote>
<p>区间【left,right】,对应代码：while(left &lt;&#x3D; right)<br>  右指针有意义，即right &#x3D; nums.length - 1;</p>
</blockquote>
</li>
</ul>
<h3 id="题目1：二分查找（力扣704）"><a href="#题目1：二分查找（力扣704）" class="headerlink" title="题目1：二分查找（力扣704）"></a><font color="red">题目1：二分查找（力扣704）</font></h3><p>给定一个 n 个元素<strong>有序</strong>的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p>
<p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1
 </p>
<p>提示：</p>
<p>你可以假设 nums 中的<strong>所有元素是不重复的</strong>。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search">题目地址</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>暴力法(次)<br>直接遍历数组，判断是否等于target,等于就返回当前索引值，否则继续。</li>
<li>二分法<br>由题目知该数组的元素为有序且无重复的，适合二分法。<br>① 首先选择数组中间的数字和需要查找的目标值比较<br>② 如果相等最好，就可以直接返回答案了<br>③ 如果不相等<ul>
<li>如果中间的数字大于目标值，则中间数字向右的所有数字都大于目标值，全部排除</li>
<li>如果中间的数字小于目标值，则中间数字向左的所有数字都小于目标值，全部排除</li>
</ul>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [-1,0,3,5,9,12], target = 8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;      <span class="comment">//指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;      <span class="comment">//中间值的索引</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;                 <span class="comment">//目标值大于中间值,则中间值左边的值去掉，即左指针右移</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;           <span class="comment">//目标值小于中间值，则去除右边的值，即右指针左移</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;                         <span class="comment">//相等，返回索引值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                  <span class="comment">//目标值不在数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="题目2-搜索插入位置（力扣35）"><a href="#题目2-搜索插入位置（力扣35）" class="headerlink" title="题目2:搜索插入位置（力扣35）"></a><font color="red">题目2:搜索插入位置（力扣35）</font></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 为 无重复元素 的 升序 排列数组<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position">题目地址</a></p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目中<strong>排序数组</strong>，适合用二分法<br>分析情况：</p>
<ol>
<li>目标值在数组里，且是数组中的元素<ul>
<li>套模板就能够找到目标值</li>
</ul>
</li>
<li>目标值在数组范围内，但不是数组中的元素<ul>
<li>思考：在终止条件时，即右指针right在左指针的前面，会发现右指针对应的值总是小于目标值，左指针的对应的值总是大于目标值，因此在right+1处即为插入的位置。</li>
</ul>
</li>
<li>目标值在数组范围两边，即小于数组的第一个或大于最后一个元素。<ul>
<li>同上面思考一样，右指针总是在左指针的左边，插入位置依然为right+1;</li>
</ul>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;     <span class="comment">//情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;       <span class="comment">//其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"><a href="#题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）" class="headerlink" title="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"></a><font color="red">题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）</font></h3><p>给定一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>nums 是一个非递减数组<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">题目地址</a></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>分析:</p>
<ol>
<li>非递减顺序的数组即<strong>升序但可以有重复元素的数组</strong></li>
<li>情况①：target 在数组范围的右边或者左边，返回[-1,-1]</li>
<li>情况②：target 在数组范围中，且数组中不存在target，返回[-1,-1]</li>
<li>情况③：target 在数组范围中，且数组中存在target</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> searchLeftBorder(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> searchRightBorder(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == -<span class="number">2</span> || rightBorder == -<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchLeftBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchRightBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目4：x的平方根（力扣69）"><a href="#题目4：x的平方根（力扣69）" class="headerlink" title="题目4：x的平方根（力扣69）"></a><font color="red">题目4：x的平方根（力扣69）</font></h3><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">题目地址</a></p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>暴力法<br>直接从0开始遍历，当该平方的数小于等于x的值时，记录当前的值。否则跳出循环。</li>
<li>二分法<br>使用二分法，左指针为0，右指针为x值。当中间值的平方小于等于x的值时，记录中间值，此时需要往后移动指针判断下一个值是否满足条件。注意：中间值平方过后可能造成溢出，需要强转为long类型的数据进行判断</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ol>
<li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= x/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)i*i &lt;= x)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( (<span class="type">long</span>)mid*mid &lt;= x)&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="题目5：有效的完全平方数（力扣367）"><a href="#题目5：有效的完全平方数（力扣367）" class="headerlink" title="题目5：有效的完全平方数（力扣367）"></a><font color="red">题目5：有效的完全平方数（力扣367）</font></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num &#x3D; 16<br>输出：true<br>示例 2：</p>
<p>输入：num &#x3D; 14<br>输出：false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; num &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square">题目地址</a></p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>与题目4思路是一致的，这里仅写二分法的代码</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid*mid == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid*mid &lt; num)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目6：山脉数组的峰顶索引（力扣852）"><a href="#题目6：山脉数组的峰顶索引（力扣852）" class="headerlink" title="题目6：山脉数组的峰顶索引（力扣852）"></a><font color="red">题目6：山脉数组的峰顶索引（力扣852）</font></h3><p>符合下列属性的数组 arr 称为 山脉数组 ：<br>arr.length &gt;&#x3D; 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [0,1,0]<br>输出：1<br>示例 2：</p>
<p>输入：arr &#x3D; [0,2,1,0]<br>输出：1<br>示例 3：</p>
<p>输入：arr &#x3D; [0,10,5,2]<br>输出：1<br>示例 4：</p>
<p>输入：arr &#x3D; [3,4,5,1]<br>输出：2<br>示例 5：</p>
<p>输入：arr &#x3D; [24,69,100,99,79,78,67,36,26,19]<br>输出：2
 </p>
<p>提示：</p>
<p>3 &lt;&#x3D; arr.length &lt;&#x3D; 10^4<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10^6<br>题目数据保证 arr 是一个山脉数组
 </p>
<p>进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/peak-index-in-a-mountain-array">题目地址</a></p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>分析题目：<br>使用二分法解决该问题，可知满足的条件为中间索引对应的值大于前一个索引对应的值同时大于后一个索引对应的值</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="number">1</span>])&#123;         <span class="comment">//当前值小于前面的值而大于后面的值，峰顶在左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid+<span class="number">1</span>])&#123;   <span class="comment">//当前值大于前面值而小于后面值，峰顶在右边</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//比前、后值都大,即为峰顶</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//无意义，本题中必定能找到峰顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目7：寻找比目标字母大的最小字母（力扣744）"><a href="#题目7：寻找比目标字母大的最小字母（力扣744）" class="headerlink" title="题目7：寻找比目标字母大的最小字母（力扣744）"></a><font color="red">题目7：寻找比目标字母大的最小字母（力扣744）</font></h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’
 </p>
<p>示例 1：</p>
<p>输入: letters &#x3D; [“c”, “f”, “j”]，target &#x3D; “a”<br>输出: “c”<br>示例 2:</p>
<p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “c”<br>输出: “f”<br>示例 3:</p>
<p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “d”<br>输出: “f”
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; letters.length &lt;&#x3D; 104<br>letters[i] 是一个小写字母<br>letters 按非递减顺序排序<br>letters 最少包含两个不同的字母<br>target 是一个小写字母</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target">题目地址</a></p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><pre><code>分析：
    
    情况①：目标值在列表左边或者在列表的右边（可以等于最右的那个值），返回letters[0];
    
    情况②：目标值在列表里，可以不等于列表的值。
        思考：用二分法时，在终止条件是，左指针指向的值总是大于目标值，右指针指向的值总是小于目标值。利用该特性与本题结合，可知返回值为letters[left]
</code></pre>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//情况①</span></span><br><span class="line">        <span class="keyword">if</span>(letters[<span class="number">0</span>] &gt; target || letters[letters.length-<span class="number">1</span>] &lt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况②</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> letters.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="②移除元素之双指针法"><a href="#②移除元素之双指针法" class="headerlink" title="②移除元素之双指针法"></a>②移除元素之双指针法</h2><h3 id="题目1：移除元素（力扣27）"><a href="#题目1：移除元素（力扣27）" class="headerlink" title="题目1：移除元素（力扣27）"></a><font color="red">题目1：移除元素（力扣27）</font></h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p> </p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);</p>
<p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element">题目地址</a></p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>须知：在数组内“移除”元素只能是覆盖。<br>移除所有等于val的元素，相当于用不等于val的元素去覆盖等于val的元素。<br>本题中使用双指针法，快指针fast指向不等于val的值就覆盖前一个值，慢指针指向的就是前一个值。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;      <span class="comment">//快指针指向的值不等于val</span></span><br><span class="line">                nums[slow] = nums[fast];    <span class="comment">//覆盖</span></span><br><span class="line">                slow++;                     <span class="comment">//慢指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;                        <span class="comment">//此时慢指针的值就是不等于val的数组新长度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目2：删除有序数组中的重复项（力扣26）"><a href="#题目2：删除有序数组中的重复项（力扣26）" class="headerlink" title="题目2：删除有序数组中的重复项（力扣26）"></a><font color="red">题目2：删除有序数组中的重复项（力扣26）</font></h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 升序 排列</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">题目地址</a></p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>无</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目3：移动零（力扣283）"><a href="#题目3：移动零（力扣283）" class="headerlink" title="题目3：移动零（力扣283）"></a><font color="red">题目3：移动零（力扣283）</font></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums &#x3D; [0]<br>输出: [0]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes">题目地址</a></p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>无</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,slow,fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> slow,<span class="type">int</span> fast)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目4：比较含退格的字符串（力扣844）"><a href="#题目4：比较含退格的字符串（力扣844）" class="headerlink" title="题目4：比较含退格的字符串（力扣844）"></a><font color="red">题目4：比较含退格的字符串（力扣844）</font></h3><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。<br>示例 2：</p>
<p>输入：s &#x3D; “ab##”, t &#x3D; “c#d#”<br>输出：true<br>解释：s 和 t 都会变成 “”。<br>示例 3：</p>
<p>输入：s &#x3D; “a#c”, t &#x3D; “b”<br>输出：false<br>解释：s 会变成 “c”，但 t 仍然是 “b”。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 200<br>s 和 t 只含有小写字母以及字符 ‘#’
 </p>
<p>进阶：</p>
<p>你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare">题目地址</a></p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>没理清</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipS</span> <span class="operator">=</span> <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先找到 s 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS ++;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS --;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再找到 t 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT --;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后开始比较,注意有下面这个 if 条件的原因是：如果 index = 0 位置上为 &#x27;#&#x27;，则 i, j 会为 -1</span></span><br><span class="line">            <span class="comment">// 而 index = -1 的情况应当处理。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果待比较字符不同，return false</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (i &gt;= 0 &amp;&amp; j &gt;= 0) 为 false 情况为</span></span><br><span class="line">            <span class="comment">// 1. i &lt; 0 &amp;&amp; j &gt;= 0</span></span><br><span class="line">            <span class="comment">// 2. j &lt; 0 &amp;&amp; i &gt;= 0</span></span><br><span class="line">            <span class="comment">// 3. i &lt; 0 &amp;&amp; j &lt; 0</span></span><br><span class="line">            <span class="comment">// 其中，第 3 种情况为符合题意情况，因为这种情况下 s 和 t 都是 index = 0 的位置为 &#x27;#&#x27; 而这种情况下</span></span><br><span class="line">            <span class="comment">// 退格空字符即为空字符，也符合题意，应当返回 True。</span></span><br><span class="line">            <span class="comment">// 但是，情况 1 和 2 不符合题意，因为 s 和 t 其中一个是在 index &gt;= 0 处找到了待比较字符，另一个没有找到</span></span><br><span class="line">            <span class="comment">// 这种情况显然不符合题意，应当返回 False，下式便处理这种情况。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目5：有序数组的平方（力扣977）"><a href="#题目5：有序数组的平方（力扣977）" class="headerlink" title="题目5：有序数组的平方（力扣977）"></a><font color="red">题目5：有序数组的平方（力扣977）</font></h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p>
<p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 非递减顺序 排序
 </p>
<p>进阶：</p>
<p>请你设计时间复杂度为 O(n) 的算法解决本问题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array">题目地址</a></p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>题目中的数组是非递减顺序排序，可知数值平方后的最大值是在左右两边产生的。<br>需要双指针分别指向左，右。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                res[index] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目6：验证回文串（力扣125）"><a href="#题目6：验证回文串（力扣125）" class="headerlink" title="题目6：验证回文串（力扣125）"></a><font color="red">题目6：验证回文串（力扣125）</font></h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p>
<p>输入：s &#x3D; “race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p>
<p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 10^5<br>s 仅由可打印的 ASCII 字符组成</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome">题目地址</a></p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[i]) &amp;&amp; i&lt;j)&#123;   <span class="comment">//非数字字母</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[j]) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c[i] != c[j])&#123;       <span class="comment">//数字字母，判断是否相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是小写字母或数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="③子数组、子串之滑动窗口"><a href="#③子数组、子串之滑动窗口" class="headerlink" title="③子数组、子串之滑动窗口"></a>③子数组、子串之滑动窗口</h2><h3 id="题目1：长度最小的子数组（力扣209）"><a href="#题目1：长度最小的子数组（力扣209）" class="headerlink" title="题目1：长度最小的子数组（力扣209）"></a><font color="red">题目1：长度最小的子数组（力扣209）</font></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p>
<p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：</p>
<p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; target &lt;&#x3D; 10^9<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum">题目地址</a></p>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];             <span class="comment">//求和</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;      <span class="comment">//计算满足条件的数组子长度</span></span><br><span class="line">                res = res &lt; subLength ? res : subLength;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若res为整型的最大值，说明数组的所有数加起来都比target小，返回0；</span></span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目2：水果成篮（力扣904）"><a href="#题目2：水果成篮（力扣904）" class="headerlink" title="题目2：水果成篮（力扣904）"></a><font color="red">题目2：水果成篮（力扣904）</font></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：fruits &#x3D; [1,2,1]<br>输出：3<br>解释：可以采摘全部 3 棵树。<br>示例 2：</p>
<p>输入：fruits &#x3D; [0,1,2,2]<br>输出：3<br>解释：可以采摘 [1,2,2] 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。<br>示例 3：</p>
<p>输入：fruits &#x3D; [1,2,3,2,2]<br>输出：4<br>解释：可以采摘 [2,3,2,2] 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。<br>示例 4：</p>
<p>输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：可以采摘 [1,2,1,1,2] 这五棵树。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets">题目地址</a></p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>题目分析：<br>    从某一棵树开始采摘，且必须连续采摘而不多于2种类型（值相同为同类型）的果树。如fruits &#x3D; [1,2,3,2,2]，若从1开始采摘，则只能采摘到2，因为3与前面的都不是同一类型的果树。从2开始的话，能够采摘到2,3,2,2。题目中需要返回的是子数组的最大长度。<br>思考：<br>    如果从头遍历数组，在遍历到该元素时，也就从该元素开始采摘。如何记录果树的类型不大于2 ??<br>    解决完果树类型不大于2时，同时记录子数组的长度，再返回即可。</p>
<p>现需要记录当前遍历的左右果树，分别用ln表示左果树类型、rn表示右果树类型。同时左（慢）指针，右（快）指针开始寻找能够装下篮子（果树类型）的水果，若右指针指向的果树类型与ln或者rn相同，记下此时能够装下的最大长度，右指针继续移动。若右指针指向的果树类型不同于ln、rn，即当前有3中类型的果树，因此需要左指针右移到右指针的前一个位置（不能是left++,参考示例4），再更新左、右果树类型。由于开始时左、右果树类型都是一样，此时需要进行判断，因为左指针移到右指针的前一个位置，但可能出现与左果树类型相同的情况。记录长度，返回即可。</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = <span class="number">0</span>;                  <span class="comment">//左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;                            <span class="comment">//记录长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> fruits[left],rn = fruits[right];   <span class="comment">//篮子一号和二号（左、右果树类型，此时果树类型相同）</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right] == rn || fruits[right] == ln)&#123;<span class="comment">//属于篮子某个种类</span></span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);  <span class="comment">//更新结果，每次取一个数就更新一下</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果遇到第三种，把慢指针移动到快指针前一步，该步的水果种类必然不同于快指针，此时慢指针慢慢回退齐所有的连续同类。</span></span><br><span class="line">                left = right - <span class="number">1</span>;  <span class="comment">//取到第三种则移动左标到right -1</span></span><br><span class="line">                ln = fruits[left]; <span class="comment">//更新第一个篮子</span></span><br><span class="line">                <span class="keyword">while</span>(left &gt;= <span class="number">1</span> &amp;&amp; fruits[left - <span class="number">1</span>] == ln) &#123;    <span class="comment">//左果树更新后回退至相同种类的开始位置</span></span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                rn = fruits[right];</span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="题目1：移除链表元素（力扣203）"><a href="#题目1：移除链表元素（力扣203）" class="headerlink" title="题目1：移除链表元素（力扣203）"></a><font color="red">题目1：移除链表元素（力扣203）</font></h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]</p>
<p>示例 2：</p>
<p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]
 </p>
<p>提示：</p>
<p>列表中的节点数目在范围 [0, 10^4] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements">题目地址</a></p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);    <span class="comment">//虚拟结点：仅仅是串起整条链，统一操作链表</span></span><br><span class="line">        node.next = head;                   <span class="comment">//虚拟结点指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;                <span class="comment">//当前结点指向虚拟结点（node）</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val )&#123;</span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">//删除等于val的结点并后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;                  <span class="comment">//后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目2：设计链表（力扣707）"><a href="#题目2：设计链表（力扣707）" class="headerlink" title="题目2：设计链表（力扣707）"></a><font color="red">题目2：设计链表（力扣707）</font></h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。
 </p>
<p>示例：</p>
<p>MyLinkedList linkedList &#x3D; new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回2<br>linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回3
 </p>
<p>提示：</p>
<p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list">题目地址</a></p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode dummy;     <span class="comment">//虚拟头结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;     <span class="comment">//初始化</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123; <span class="comment">//超出索引位置</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; index;i++)&#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);   <span class="comment">//添加</span></span><br><span class="line">        add.next = pre.next;</span><br><span class="line">        pre.next = add;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">	        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next,prev;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;            <span class="comment">//从head开始</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;                                  <span class="comment">//从tail开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123; </span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;   </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目3：反转链表（力扣206）"><a href="#题目3：反转链表（力扣206）" class="headerlink" title="题目3：反转链表（力扣206）"></a><font color="red">题目3：反转链表（力扣206）</font></h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000
 </p>
<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list">题目地址</a></p>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针、迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;    </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//保存下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;<span class="comment">// 先保存下一个节点</span></span><br><span class="line">        cur.next = prev;<span class="comment">// 反转</span></span><br><span class="line">        <span class="comment">// 更新prev、cur位置</span></span><br><span class="line">        <span class="comment">// prev = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力，构建新链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> head; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x.val,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目4：两两交换链表中的节点（力扣24）"><a href="#题目4：两两交换链表中的节点（力扣24）" class="headerlink" title="题目4：两两交换链表中的节点（力扣24）"></a><font color="red">题目4：两两交换链表中的节点（力扣24）</font></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head &#x3D; []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs">题目地址</a></p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑：</span></span><br><span class="line"><span class="comment">// 保存第二个节点，第一个节点指向第二层的返回值，再两两交换。</span></span><br><span class="line"><span class="comment">// 例子：1-&gt;2-&gt;3-&gt;4 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一层：  </span></span><br><span class="line"><span class="comment">// 定义指针-&gt;2    1-&gt;??(第二层返回值)                    1-&gt;4-&gt;3</span></span><br><span class="line"><span class="comment">//                                                     当前层又进行交互：</span></span><br><span class="line"><span class="comment">//                                                     2-&gt;1-&gt;4-&gt;3,返回定义的指针，即新的head</span></span><br><span class="line">    ||</span><br><span class="line">    \/</span><br><span class="line"><span class="comment">// 进入第二层：</span></span><br><span class="line">    ||</span><br><span class="line">    \/                                                      /\</span><br><span class="line">                                                            ||</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">// 定义指针指向-&gt;4</span></span><br><span class="line"><span class="comment">// 3-&gt;??(进入第三层)                                    交换：4-&gt;3,返回</span></span><br><span class="line">                                                            /\</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">//     --&gt;                  ----&gt;                       第三层为空，返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终止条件</span></span><br><span class="line">	    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="comment">//假设链表是 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line">		<span class="comment">//这句就先保存节点2</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;</span><br><span class="line">		<span class="comment">//继续递归，处理节点3-&gt;4</span></span><br><span class="line">		<span class="comment">//当递归结束返回后，就变成了4-&gt;3</span></span><br><span class="line">		<span class="comment">//于是head节点就指向了4，变成1-&gt;4-&gt;3</span></span><br><span class="line">		head.next = swapPairs(tmp.next);</span><br><span class="line">		<span class="comment">//将2节点指向1</span></span><br><span class="line">		tmp.next = head;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目5：删除链表的倒数第N个结点（力扣19）"><a href="#题目5：删除链表的倒数第N个结点（力扣19）" class="headerlink" title="题目5：删除链表的倒数第N个结点（力扣19）"></a><font color="red">题目5：删除链表的倒数第N个结点（力扣19）</font></h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p>
<p>示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]<br> <br>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">题目地址</a></p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：计算链表长度，找到要删除的前一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);           <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; length -n +<span class="number">1</span>;i++)&#123;    <span class="comment">//要删除的前一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = cur.next.next;           <span class="comment">//删除倒数第n的节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法二：前后双指针（你走一步，我走一步）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;       <span class="comment">//first指针比second指针多n步</span></span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">null</span>)&#123;           <span class="comment">//你一步我一步，结束时second在要删除节点的前一个节点</span></span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;     <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法三：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFormEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;   <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = removeNthFormEnd(head.next,n);</span><br><span class="line">        cur++;          <span class="comment">//递归返回时都会执行，即寻找要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(n == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;       <span class="comment">//直接抛弃要删除的节点，返回下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目6：面试题02-07-链表相交-lt-力扣同题160-gt"><a href="#题目6：面试题02-07-链表相交-lt-力扣同题160-gt" class="headerlink" title="题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;"></a><font color="red">题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;</font></h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：</p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：</p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br> <br>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 10^4<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA + 1] &#x3D;&#x3D; listB[skipB + 1]
 </p>
<p>进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">题目地址</a></p>
<h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>思考：两链表长度不一，如何进行遍历？<br>可以计算出两链表的长度，进行差值，即有一个链表先移动（差值）步，再开始比较。分别用两指针指向当前该判断的位置。判断是否指针相等，若相等，则返回当前指针。若不等，则同时移动两个指针到下一个位置。</p>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;    <span class="comment">//计算headA的长度</span></span><br><span class="line">            lengthA++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;      <span class="comment">//计算headB的长度</span></span><br><span class="line">            lengthB++;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;          <span class="comment">//判断长度的差值，使得指针在不同链表中的同一步</span></span><br><span class="line">            lengthA = lengthA - lengthB;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     <span class="comment">//指针先移动lengthA步</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lengthA = lengthB - lengthA;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     </span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;            <span class="comment">//判断当前指针是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;           <span class="comment">//相等</span></span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;                    <span class="comment">//不相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目7：环形链表-lt-力扣142-gt"><a href="#题目7：环形链表-lt-力扣142-gt" class="headerlink" title="题目7：环形链表||&lt;力扣142&gt;"></a><font color="red">题目7：环形链表||&lt;力扣142&gt;</font></h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。<br> <br>提示：</p>
<p>链表中节点的数目范围在范围 [0, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>pos 的值为 -1 或者链表中的一个有效索引
 </p>
<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii">题目地址</a></p>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.add(a);</span><br><span class="line">            a = a.next;</span><br><span class="line">            <span class="keyword">while</span>(temp.contains(a))&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="题目1：有效的字母异位词（力扣242）"><a href="#题目1：有效的字母异位词（力扣242）" class="headerlink" title="题目1：有效的字母异位词（力扣242）"></a><font color="red">题目1：有效的字母异位词（力扣242）</font></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true</p>
<p>示例 2:</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false<br> <br>提示:</p>
<p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 10^4<br>s 和 t 仅包含小写字母
 </p>
<p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram">题目地址</a></p>
<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通哈希,不符合unicode字符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : record)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">var</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//进阶哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(ch) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目2：两个数组的交集（力扣349）"><a href="#题目2：两个数组的交集（力扣349）" class="headerlink" title="题目2：两个数组的交集（力扣349）"></a><font color="red">题目2：两个数组的交集（力扣349）</font></h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p>
<p>示例 2：</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的<br> <br>提示：</p>
<p>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays">题目地址</a></p>
<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums1)&#123;</span><br><span class="line">            set.add(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(<span class="keyword">var</span>))&#123;</span><br><span class="line">                res.add(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] str = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : res)&#123;</span><br><span class="line">            str[i++] = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">// return res.stream().mapToInt(x -&gt; x).toArray();  //流操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目3：快乐数（力扣202）"><a href="#题目3：快乐数（力扣202）" class="headerlink" title="题目3：快乐数（力扣202）"></a><font color="red">题目3：快乐数（力扣202）</font></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p>
<p>示例 2：</p>
<p>输入：n &#x3D; 2<br>输出：false<br> <br>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number">题目地址</a></p>
<h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;  <span class="comment">//前一个条件用于循环，后一个条件用于判断不重复</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;          <span class="comment">//计算当前数的每一个位数的平方和，用total保存</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n;</span><br><span class="line">                temp = temp%<span class="number">10</span>;</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">                total += temp * temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total == <span class="number">1</span>)&#123;         <span class="comment">//位数的平方和为1，符号条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = total;          <span class="comment">//赋值重新进入循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目4：两数之和（力扣1）"><a href="#题目4：两数之和（力扣1）" class="headerlink" title="题目4：两数之和（力扣1）"></a><font color="red">题目4：两数之和（力扣1）</font></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p>
<p>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p>
<p>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-109 &lt;&#x3D; target &lt;&#x3D; 10^9<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum">题目地址</a></p>
<h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;Integer,Integer&gt; set = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     int n = target - nums[i];</span></span><br><span class="line">        <span class="comment">//     if(set.containsKey(n))&#123;</span></span><br><span class="line">        <span class="comment">//         return new int[]&#123;set.get(n),i&#125;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     set.put(nums[i],i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return new int[0];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目5：四数相加-（力扣454）"><a href="#题目5：四数相加-（力扣454）" class="headerlink" title="题目5：四数相加||（力扣454）"></a><font color="red">题目5：四数相加||（力扣454）</font></h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<br> <br>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
<p>示例 2：</p>
<p>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums1.length<br>n &#x3D;&#x3D; nums2.length<br>n &#x3D;&#x3D; nums3.length<br>n &#x3D;&#x3D; nums4.length<br>1 &lt;&#x3D; n &lt;&#x3D; 200<br>-2^28 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 2^28</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii">题目地址</a></p>
<h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目6：赎金信（力扣383）"><a href="#题目6：赎金信（力扣383）" class="headerlink" title="题目6：赎金信（力扣383）"></a><font color="red">题目6：赎金信（力扣383）</font></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<p>示例 1：</p>
<p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p>
<p>示例 2：</p>
<p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p>
<p>示例 3：</p>
<p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true<br> <br>提示：<br>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 10^5<br>ransomNote 和 magazine 由小写英文字母组成</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note">题目地址</a></p>
<h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> magazine.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.put(c,map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ransomNote.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(c,map.get(c)-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">============================================================</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote,String magazine)</span>&#123;</span><br><span class="line">        <span class="comment">//记录杂志字符串出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            temp = magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            arr[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            temp = ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//对于金信中的每一个字符都在数组中查找</span></span><br><span class="line">            <span class="comment">//找到相应位减一，否则找不到返回false</span></span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目7：三数之和（力扣15）"><a href="#题目7：三数之和（力扣15）" class="headerlink" title="题目7：三数之和（力扣15）"></a><font color="red">题目7：三数之和（力扣15）</font></h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>
<p>示例 2：</p>
<p>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。</p>
<p>示例 3：</p>
<p>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。
 </p>
<p>提示：</p>
<p>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum">题目地址</a></p>
<h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>大概懂</p>
<h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums); <span class="comment">// O(nlogn)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; <span class="comment">// O(n^2)</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 第一个数大于 0，后面的数都比它大，肯定不成立了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去掉重复情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                    ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    left++; right--; <span class="comment">// 首先无论如何先要进行加减操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// nums[left] + nums[right] &gt; target</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目8：四数之和（力扣18）"><a href="#题目8：四数之和（力扣18）" class="headerlink" title="题目8：四数之和（力扣18）"></a><font color="red">题目8：四数之和（力扣18）</font></h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum">题目地址</a></p>
<h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= nums.length -<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;  <span class="comment">//排序后的数组第一个正数都比target大。</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt;= nums.length -<span class="number">3</span>;j++)&#123;      <span class="comment">//第二个指针j</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j];            <span class="comment">//前2个指针的数值之和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;                       <span class="comment">//第三个指针</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;             <span class="comment">//第四个指针</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> temp + nums[left] + nums[right]; </span><br><span class="line">                    <span class="keyword">if</span>(total &gt; target)&#123;         <span class="comment">//目标值小</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(total &lt; target)&#123;   <span class="comment">//目标值大</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//相等</span></span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i],nums[j],nums[left],nums[right])));</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;   <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; </span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;  <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++; <span class="comment">//继续看其他情况是否符合</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="题目1：反转字符串（力扣344）"><a href="#题目1：反转字符串（力扣344）" class="headerlink" title="题目1：反转字符串（力扣344）"></a><font color="red">题目1：反转字符串（力扣344）</font></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5<br>s[i] 都是 ASCII 码表中的可打印字符</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string">题目地址</a></p>
<h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">                s[right] ^= s[left];</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="comment">//其他精简写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span> - i;</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">            s[j] ^= s[i];</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">        &#125;</span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目2：反转字符串-（力扣541）"><a href="#题目2：反转字符串-（力扣541）" class="headerlink" title="题目2：反转字符串||（力扣541）"></a><font color="red">题目2：反转字符串||（力扣541）</font></h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br> <br>示例 1：</p>
<p>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：</p>
<p>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由小写英文组成<br>1 &lt;&#x3D; k &lt;&#x3D; 10^4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii">题目地址</a></p>
<h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>题目理解：每隔2k个反转前k个，尾数不够k个时候全部反转</p>
<h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);<span class="comment">//字符串长度可能小于k，则尾指针使用总长度-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目3：剑指Offer-05-替换空格（力扣？？？）"><a href="#题目3：剑指Offer-05-替换空格（力扣？？？）" class="headerlink" title="题目3：剑指Offer 05.替换空格（力扣？？？）"></a><font color="red">题目3：剑指Offer 05.替换空格（力扣？？？）</font></h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”<br> <br>限制：</p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">题目地址</a></p>
<h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">        <span class="comment">//if (&quot; &quot;.equals(String.valueOf(str.charAt(i))))&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目4：反转字符串中的单词（力扣151）"><a href="#题目4：反转字符串中的单词（力扣151）" class="headerlink" title="题目4：反转字符串中的单词（力扣151）"></a><font color="red">题目4：反转字符串中的单词（力扣151）</font></h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “the sky is blue”<br>输出：”blue is sky the”</p>
<p>示例 2：</p>
<p>输入：s &#x3D; “  hello world  “<br>输出：”world hello”<br>解释：反转后的字符串中不能存在前导空格和尾随空格。</p>
<p>示例 3：</p>
<p>输入：s &#x3D; “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 包含英文大小写字母、数字和空格 ‘ ‘<br>s 中 至少存在一个 单词</p>
<p>进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string">题目地址</a></p>
<h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();                           <span class="comment">//去除前后空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;               <span class="comment">//单词的尾指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;                        <span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span>)&#123;                      <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;                     <span class="comment">//当start为0时，直接加</span></span><br><span class="line">                sb.append(s,start,end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != <span class="string">&#x27; &#x27;</span>)&#123;         <span class="comment">//当前字符不为&#x27; &#x27;,头指针找单词的头</span></span><br><span class="line">                start--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// sb.append(s.substring(start + 1 , end+1)).append(&#x27; &#x27;);</span></span><br><span class="line">                sb.append(s,start + <span class="number">1</span>,end + <span class="number">1</span>).append(<span class="string">&#x27; &#x27;</span>);     <span class="comment">//当前字符为&#x27; &#x27;,start指针此时在单词头的前一个索引位置，添加到sb中。</span></span><br><span class="line">                end = start - <span class="number">1</span>;                                <span class="comment">//移动尾指针</span></span><br><span class="line">                <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;                   <span class="comment">//两单词之间多空格的情况，找尾指针不为空字符的时候，即尾指针指向第二个单词的尾部</span></span><br><span class="line">                    end--;                                      </span><br><span class="line">                &#125;</span><br><span class="line">                start = end;                                    <span class="comment">//头指针与尾指针都指向第二个单词的尾部，重复如此</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目5：剑指Offer-58-左旋转字符串（力扣？？？）"><a href="#题目5：剑指Offer-58-左旋转字符串（力扣？？？）" class="headerlink" title="题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）"></a><font color="red">题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）</font></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p>
<p>示例 2：</p>
<p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”<br> <br>限制：</p>
<p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">题目地址</a></p>
<h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">// sb.append(s,n,s.length());</span></span><br><span class="line">        <span class="comment">// sb.append(s,0,n);</span></span><br><span class="line">        <span class="comment">// return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目6：找出字符串中第一个匹配的下标（力扣28）"><a href="#题目6：找出字符串中第一个匹配的下标（力扣28）" class="headerlink" title="题目6：找出字符串中第一个匹配的下标（力扣28）"></a><font color="red">题目6：找出字符串中第一个匹配的下标（力扣28）</font></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<p>示例 1：</p>
<p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p>
<p>示例 2：</p>
<p>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 10^4<br>haystack 和 needle 仅由小写英文字符组成</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">题目地址</a></p>
<h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>未理清kmp</p>
<h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="type">char</span>[] s = haystack.toCharArray(), p = needle.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举原串的「发起点」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从原串的「发起点」和匹配串的「首位」开始，尝试匹配</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; m &amp;&amp; s[a] == p[b]) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果能够完全匹配，返回原串的「发起点」下标</span></span><br><span class="line">            <span class="keyword">if</span> (b == m) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack,String needle)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;        <span class="comment">//构造next数组（pi）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;          <span class="comment">//匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目7：重复的子字符串（力扣459）"><a href="#题目7：重复的子字符串（力扣459）" class="headerlink" title="题目7：重复的子字符串（力扣459）"></a><font color="red">题目7：重复的子字符串（力扣459）</font></h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p>
<p>输入: s &#x3D; “aba”<br>输出: false<br>示例 3:</p>
<p>输入: s &#x3D; “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)<br> <br>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 由小写英文字母组成</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern">题目地址</a></p>
<h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= m/<span class="number">2</span>;i++)&#123;        <span class="comment">//能够由子字符串构成的字符串，子字符串的长度必定是字符串长度的一半以内</span></span><br><span class="line">            <span class="keyword">if</span>(m % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ;j &lt; m; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="题目1：用栈实现队列-力扣232"><a href="#题目1：用栈实现队列-力扣232" class="headerlink" title="题目1：用栈实现队列(力扣232)"></a><font color="red">题目1：用栈实现队列(力扣232)</font></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p>示例 1：</p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p>
<p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false<br> <br>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用 100 次 push、pop、peek 和 empty<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）<br> <br>进阶：</p>
<p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks">题目地址</a></p>
<h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>根据队列FIFO的特性，用两个栈(LIFO特性)模拟。栈1负责元素进栈，栈2负责接收栈1的元素，并做出栈等操作。</p>
<h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//用栈模拟队列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;  <span class="comment">//栈1(元素进栈)</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;  <span class="comment">//栈2(栈1的元素出栈，该栈负责元素出栈及获取栈顶元素)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();       <span class="comment">//将栈1的元素弹出并进栈2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队空?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty()&amp;&amp;stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈1元素出栈到栈2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outStack1_AndInStack2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目2：用队列实现栈-力扣225"><a href="#题目2：用队列实现栈-力扣225" class="headerlink" title="题目2：用队列实现栈(力扣225)"></a><font color="red">题目2：用队列实现栈(力扣225)</font></h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br> <br>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<p>示例：</p>
<p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p>
<p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False<br> <br>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空<br> <br>进阶：你能否仅用一个队列来实现栈。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues">题目地址</a></p>
<h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><p>根据栈的特性LIFO，以及队列的特性FIFO,使用两个队列实现栈。首先队列1负责元素进出队，队列2负责临时存储元素。在元素进入队列1时，为达到LIFO的特性，用上临时存储队列2，先将队列2中所有的元素全部进队到队列1中，再交换队列，即交换存储空间（队列交换）达到队列1始终为空.</p>
<h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; a;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        a.offer(x);             <span class="comment">//元素进入队列1</span></span><br><span class="line">        <span class="keyword">while</span>(!b.isEmpty())&#123;    <span class="comment">//将队列2中的所有元素入队1</span></span><br><span class="line">            a.offer(b.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换保证a始终为空</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//一个队列实现栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目3：有效的括号-力扣20"><a href="#题目3：有效的括号-力扣20" class="headerlink" title="题目3：有效的括号(力扣20)"></a><font color="red">题目3：有效的括号(力扣20)</font></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “()”<br>输出：true</p>
<p>示例 2：</p>
<p>输入：s &#x3D; “()[]{}”<br>输出：true</p>
<p>示例 3：</p>
<p>输入：s &#x3D; “(]”<br>输出：false</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由括号 ‘()[]{}’ 组成</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses">题目地址</a></p>
<h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h4><p>该题不是那种穿插的括号，直接进行判断即可</p>
<h4 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;[&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">//哈希快速匹配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//右括号为键，左括号为值</span></span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;    <span class="comment">//右括号进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != map.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">//左括号直接进栈</span></span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈为空，即全部匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目4：删除字符串中的所有相邻重复项-力扣1047"><a href="#题目4：删除字符串中的所有相邻重复项-力扣1047" class="headerlink" title="题目4：删除字符串中的所有相邻重复项(力扣1047)"></a><font color="red">题目4：删除字符串中的所有相邻重复项(力扣1047)</font></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br> <br>提示：<br>1 &lt;&#x3D; S.length &lt;&#x3D; 20000<br>S 仅由小写英文字母组成。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">题目地址</a></p>
<h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈思想实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">0</span> &amp;&amp; stack.charAt(top) == ch) &#123;</span><br><span class="line">                stack.deleteCharAt(top);</span><br><span class="line">                --top;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.append(ch);</span><br><span class="line">                ++top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================================================</span><br><span class="line"><span class="comment">//数组实现（还是栈的思想）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;   <span class="comment">//栈顶指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == -<span class="number">1</span> || ch[top] != ch[i]) &#123;    <span class="comment">//当前元素与栈顶元素不一致就进栈</span></span><br><span class="line">                ch[++top] = ch[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top--;      <span class="comment">//删除栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch, <span class="number">0</span>, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目5：逆波兰表达式求值-力扣150"><a href="#题目5：逆波兰表达式求值-力扣150" class="headerlink" title="题目5：逆波兰表达式求值(力扣150)"></a><font color="red">题目5：逆波兰表达式求值(力扣150)</font></h3><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>
<p>示例 2：</p>
<p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</p>
<p>示例 3：</p>
<p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 10^4<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</p>
<p>逆波兰表达式：</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">题目地址</a></p>
<h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h4><p>是数字就进栈，是运算符则出栈2个数进行操作后再进栈。</p>
<h4 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String item : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>) || item.equals(<span class="string">&quot;-&quot;</span>) || item.equals(<span class="string">&quot;*&quot;</span>) || item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1+num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2-num1);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1*num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(item));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span></span><br><span class="line">                stack.push(stack.pop() + stack.pop());      <span class="comment">// 注意 - 和/ 需要特殊处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目6：滑动窗口最大值-力扣239"><a href="#题目6：滑动窗口最大值-力扣239" class="headerlink" title="题目6：滑动窗口最大值(力扣239)"></a><font color="red">题目6：滑动窗口最大值(力扣239)</font></h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                  最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>示例 2：</p>
<p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]<br> <br>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum">题目地址</a></p>
<h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h4><p>难啊</p>
<h4 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加元素时，如果要添加的元素大于队尾处的元素，就将队尾元素弹出（保证对首元素始终大于队尾元素）</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 如果队首存储的角标就是滑动窗口左边界数值，就移除队首（保证窗口大小为k）</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; (i - k) == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当i增长到第一个窗口右边界时，每滑动一步都将队首角标对应元素(窗口最大值)放入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目7：前K个高频元素-力扣347"><a href="#题目7：前K个高频元素-力扣347" class="headerlink" title="题目7：前K个高频元素(力扣347)"></a><font color="red">题目7：前K个高频元素(力扣347)</font></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的<br> <br>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements">题目地址</a></p>
<h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h4><ol>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ol>
<h4 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    解法<span class="number">1</span>：基于大顶堆实现</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//大顶堆需要对所有元素进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//依次从队头弹出k个,就是出现频率前k高的元素</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//解法2：基于小顶堆实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;<span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();<span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="题目1：二叉树的前序遍历-力扣144"><a href="#题目1：二叉树的前序遍历-力扣144" class="headerlink" title="题目1：二叉树的前序遍历(力扣144)"></a><font color="red">题目1：二叉树的前序遍历(力扣144)</font></h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]</p>
<p>示例 4：</p>
<p>输入：root &#x3D; [1,2]<br>输出：[1,2]</p>
<p>示例 5：</p>
<p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]<br> <br>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal">题目地址</a></p>
<h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pre(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        pre(root.left,list);</span><br><span class="line">        pre(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//官方迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="comment">//morris算法(二叉搜索树)</span></span><br><span class="line"><span class="comment">//实现原则</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.如果cur无左孩子，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">    2.如果cur有左孩子，找到cur左子树上最右的节点，记为mostright</span></span><br><span class="line"><span class="comment">        1.如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</span></span><br><span class="line"><span class="comment">        2.如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur表示当前节点，mostRight表示cur的左孩子的最右节点</span></span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// cur有左孩子，找到cur左子树最右节点</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// mostRight的右孩子指向空，让其指向cur，cur向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// mostRight的右孩子指向cur，让其指向空，cur向右移动</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.print(cur.value + &quot; &quot;);</span></span><br><span class="line">                res.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">//二叉树的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node root; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        createTree(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        List &lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//新建一个list集合，将数据变为各个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> temp : data) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        root=list.get(<span class="number">0</span>);<span class="comment">//将第一个元素设置为根节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用构建完全二叉树的方式构建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(( i*<span class="number">2</span> + <span class="number">1</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setLeft(list.get(i*<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i*<span class="number">2</span>+<span class="number">2</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setRight(list.get(i*<span class="number">2</span>+<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="comment">// 得到根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value,Node left,Node right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(Node left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目2：二叉树的中序遍历-力扣94"><a href="#题目2：二叉树的中序遍历-力扣94" class="headerlink" title="题目2：二叉树的中序遍历(力扣94)"></a><font color="red">题目2：二叉树的中序遍历(力扣94)</font></h3><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]</p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal">题目地址</a></p>
<h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目3：二叉树的后序遍历-力扣145"><a href="#题目3：二叉树的后序遍历-力扣145" class="headerlink" title="题目3：二叉树的后序遍历(力扣145)"></a><font color="red">题目3：二叉树的后序遍历(力扣145)</font></h3><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]<br> <br>提示：</p>
<p>树中节点的数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal">题目地址</a></p>
<h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postorder(root.left,list);</span><br><span class="line">        postorder(root.right,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目4：二叉树的层序遍历-力扣102"><a href="#题目4：二叉树的层序遍历-力扣102" class="headerlink" title="题目4：二叉树的层序遍历(力扣102)"></a><font color="red">题目4：二叉树的层序遍历(力扣102)</font></h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal">题目地址</a></p>
<h4 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS（breadth first search：广度优先算法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();   <span class="comment">//存放结果集</span></span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//存放结点的队列</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;  </span><br><span class="line">        que.offerLast(root);            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();                   </span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.right);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目5：二叉树的层序遍历-力扣107"><a href="#题目5：二叉树的层序遍历-力扣107" class="headerlink" title="题目5：二叉树的层序遍历||(力扣107)"></a><font color="red">题目5：二叉树的层序遍历||(力扣107)</font></h3><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii">题目地址</a></p>
<h4 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每一层的结点数量</span></span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//存放第i层数组的值，i从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,ret);         <span class="comment">//往结果集中的第0个位置存放，使得遍历完每一层的结果都在最前面，达到从下往上遍历的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目6：二叉树的右视图-力扣199"><a href="#题目6：二叉树的右视图-力扣199" class="headerlink" title="题目6：二叉树的右视图(力扣199)"></a><font color="red">题目6：二叉树的右视图(力扣199)</font></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p>
<p>示例 2:</p>
<p>输入: [1,null,3]<br>输出: [1,3]</p>
<p>示例 3:</p>
<p>输入: []<br>输出: []<br> <br>提示:</p>
<p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view">题目地址</a></p>
<h4 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，取最后一个节点的值即可</p>
<h4 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();   <span class="comment">//同一层的结点数量</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目7：二叉树的层平均值-力扣637"><a href="#题目7：二叉树的层平均值-力扣637" class="headerlink" title="题目7：二叉树的层平均值(力扣637)"></a><font color="red">题目7：二叉树的层平均值(力扣637)</font></h3><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。</p>
<p>示例 2:</p>
<p>输入：root &#x3D; [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p>
<p>提示：</p>
<p>树中节点数量在 [1, 10^4] 范围内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">题目地址</a></p>
<h4 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，遍历一层就计算出每一层的平均值。</p>
<h4 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> len;        <span class="comment">//每层节点数量</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;     <span class="comment">//层序遍历每一层，得到每一层的总值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(sum/count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目8：N叉树的层序遍历-力扣637"><a href="#题目8：N叉树的层序遍历-力扣637" class="headerlink" title="题目8：N叉树的层序遍历(力扣637)"></a><font color="red">题目8：N叉树的层序遍历(力扣637)</font></h3><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]<br> <br>提示：</p>
<p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal">题目地址</a></p>
<h4 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">for</span>(Node ch : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Iterator&lt;Node&gt; iter = node.children.iterator();</span></span><br><span class="line">                <span class="comment">// while(iter.hasNext())&#123;</span></span><br><span class="line">                <span class="comment">//     que.offer(iter.next());</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目9：在每个树中找最大值-力扣515"><a href="#题目9：在每个树中找最大值-力扣515" class="headerlink" title="题目9：在每个树中找最大值(力扣515)"></a><font color="red">题目9：在每个树中找最大值(力扣515)</font></h3><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p>
<p>示例1：</p>
<p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p>
<p>示例2：</p>
<p>输入: root &#x3D; [1,2,3]<br>输出: [1,3]</p>
<p>提示：</p>
<p>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row">题目地址</a></p>
<h4 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h4><p>层序遍历</p>
<h4 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                max = node.val &gt; max ? node.val : max;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目10：填充每个节点的下一个右侧节点指针-力扣116"><a href="#题目10：填充每个节点的下一个右侧节点指针-力扣116" class="headerlink" title="题目10：填充每个节点的下一个右侧节点指针(力扣116)"></a><font color="red">题目10：填充每个节点的下一个右侧节点指针(力扣116)</font></h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,3,4,5,6,7]</p>
<p>输出：[1,#,2,3,#,4,5,6,7,#]</p>
<p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p>
<p>示例 2:</p>
<p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p>
<p>树中节点的数量在 [0, 2^12 - 1] 范围内</p>
<p>-1000 &lt;&#x3D; node.val &lt;&#x3D; 1000<br> <br>进阶：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node">题目地址</a></p>
<h4 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//先前出队的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//当前出队的节点</span></span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每层的节点数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;             </span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();       </span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;      <span class="comment">//非最右侧节点指向先前出队的节点</span></span><br><span class="line">                    cur.next = pre;     </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;      <span class="comment">//每层的节点遵循从右往左入队</span></span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目11：填充每个节点的下一个右侧节点指针-力扣117"><a href="#题目11：填充每个节点的下一个右侧节点指针-力扣117" class="headerlink" title="题目11：填充每个节点的下一个右侧节点指针||(力扣117)"></a><font color="red">题目11：填充每个节点的下一个右侧节点指针||(力扣117)</font></h3><p>给定一个二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
 </p>
<p>示例：</p>
<p>输入：root &#x3D; [1,2,3,4,5,null,7]</p>
<p>输出：[1,#,2,3,#,4,5,7,#]</p>
<p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。
 </p>
<p>提示：</p>
<p>树中的节点数小于 6000<br>-100 &lt;&#x3D; node.val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">题目地址</a></p>
<h4 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;</span><br><span class="line">                    cur.next = pre;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目12：二叉树的最大深度-力扣104"><a href="#题目12：二叉树的最大深度-力扣104" class="headerlink" title="题目12：二叉树的最大深度(力扣104)"></a><font color="red">题目12：二叉树的最大深度(力扣104)</font></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>返回它的最大深度 3 。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">题目地址</a></p>
<h4 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS(深度优先搜索)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="comment">//BFS(广度优先遍历)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125; </span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目13：二叉树的最小深度-力扣111"><a href="#题目13：二叉树的最小深度-力扣111" class="headerlink" title="题目13：二叉树的最小深度(力扣111)"></a><font color="red">题目13：二叉树的最小深度(力扣111)</font></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [2,null,3,null,4,null,5,null,6]<br>输出：5<br> <br>提示：</p>
<p>树中节点数的范围在 [0, 10^5] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree">题目地址</a></p>
<h4 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;  <span class="comment">//该层的节点若没有左右节点即为最小的深度</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目14：翻转二叉树-力扣226"><a href="#题目14：翻转二叉树-力扣226" class="headerlink" title="题目14：翻转二叉树(力扣226)"></a><font color="red">题目14：翻转二叉树(力扣226)</font></h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：[2,3,1]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目范围在 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree">题目地址</a></p>
<h4 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//前序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(rightTree);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//后序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.right = leftNode;</span><br><span class="line">        root.left = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//层序</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = rightNode;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目15：对称二叉树-力扣101"><a href="#题目15：对称二叉树-力扣101" class="headerlink" title="题目15：对称二叉树(力扣101)"></a><font color="red">题目15：对称二叉树(力扣101)</font></h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree">题目地址</a></p>
<h4 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode leftNode,TreeNode rightNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(leftNode.left,rightNode.right) &amp;&amp; check(leftNode.right,rightNode.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        que.offer(root.left);</span><br><span class="line">        que.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.offer(leftNode.left);</span><br><span class="line">            que.offer(rightNode.right);</span><br><span class="line"></span><br><span class="line">            que.offer(leftNode.right);</span><br><span class="line">            que.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目16：相同的树-力扣100"><a href="#题目16：相同的树-力扣100" class="headerlink" title="题目16：相同的树(力扣100)"></a><font color="red">题目16：相同的树(力扣100)</font></h3><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1：</p>
<p>输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]<br>输出：true</p>
<p>示例 2：</p>
<p>输入：p &#x3D; [1,2], q &#x3D; [1,null,2]<br>输出：false</p>
<p>示例 3：</p>
<p>输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]<br>输出：false<br> <br>提示：</p>
<p>两棵树上的节点数目都在范围 [0, 100] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree">题目地址</a></p>
<h4 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> check(p.left,q.left) &amp;&amp; check(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(p);</span><br><span class="line">        que.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            que.offer(node1.left);</span><br><span class="line">            que.offer(node2.left);</span><br><span class="line"></span><br><span class="line">            que.offer(node1.right);</span><br><span class="line">            que.offer(node2.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目17：另一棵树的子树-力扣572"><a href="#题目17：另一棵树的子树-力扣572" class="headerlink" title="题目17：另一棵树的子树(力扣572)"></a><font color="red">题目17：另一棵树的子树(力扣572)</font></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p>
<p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]<br>输出：true</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [3,4,5,1,2,null,null,null,null,0], subRoot &#x3D; [4,1,2]<br>输出：false<br> <br>提示：</p>
<p>root 树上的节点数量范围是 [1, 2000]<br>subRoot 树上的节点数量范围是 [1, 1000]<br>-10^4 &lt;&#x3D; root.val &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; subRoot.val &lt;&#x3D; 10^4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree">题目地址</a></p>
<h4 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//树的子树的结果</span></span><br><span class="line">    <span class="comment">//1.树相同</span></span><br><span class="line">    <span class="comment">//2.是该树的左子树的子树</span></span><br><span class="line">    <span class="comment">//3.是该树的右子树的子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//1.树相同</span></span><br><span class="line">        <span class="keyword">if</span>(isSameTree(root,subRoot))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子树</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || subRoot == <span class="literal">null</span> || root.val != subRoot.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(root.left,subRoot.left) &amp;&amp; isSameTree(root.right,subRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目18：N叉树的最大深度-力扣559"><a href="#题目18：N叉树的最大深度-力扣559" class="headerlink" title="题目18：N叉树的最大深度(力扣559)"></a><font color="red">题目18：N叉树的最大深度(力扣559)</font></h3><p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：3</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：5</p>
<p>提示：</p>
<p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 10^4] 之间。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree">题目地址</a></p>
<h4 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            depth = Math.max(depth,maxDepth(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node n : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; </span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目19：完全二叉树的节点个数-力扣222"><a href="#题目19：完全二叉树的节点个数-力扣222" class="headerlink" title="题目19：完全二叉树的节点个数(力扣222)"></a><font color="red">题目19：完全二叉树的节点个数(力扣222)</font></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6</p>
<p>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：0</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：1<br> <br>提示：</p>
<p>树中节点的数目范围是[0, 5 * 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 1^04<br>题目数据保证输入的树是 完全二叉树</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes">题目地址</a></p>
<h4 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目20：完全二叉树的节点个数-力扣222"><a href="#题目20：完全二叉树的节点个数-力扣222" class="headerlink" title="题目20：完全二叉树的节点个数(力扣222)"></a><font color="red">题目20：完全二叉树的节点个数(力扣222)</font></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false</p>
<p>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：true<br> <br>提示：</p>
<p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree">题目地址</a></p>
<h4 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目21：二叉树的所有路径-力扣257"><a href="#题目21：二叉树的所有路径-力扣257" class="headerlink" title="题目21：二叉树的所有路径(力扣257)"></a><font color="red">题目21：二叉树的所有路径(力扣257)</font></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。<br> <br>示例 1：</p>
<p>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[“1”]</p>
<p>提示：</p>
<p>树中节点的数目在范围 [1, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths">题目地址</a></p>
<h4 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,StringBuffer s,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        s.append(root.val); <span class="comment">//根值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;    <span class="comment">//叶子节点</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res);</span><br><span class="line">        dfs(root.right,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目22：左子树之和-力扣404"><a href="#题目22：左子树之和-力扣404" class="headerlink" title="题目22：左子树之和(力扣404)"></a><font color="red">题目22：左子树之和(力扣404)</font></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<p>示例 1：</p>
<p>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>示例 2:</p>
<p>输入: root &#x3D; [1]<br>输出: 0</p>
<p>提示:</p>
<p>节点数在 [1, 1000] 范围内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves">题目地址</a></p>
<h4 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;    <span class="comment">//当前遍历的左节点不为null时，且是叶子节点</span></span><br><span class="line">            res += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目23：找树左下角的值-力扣513"><a href="#题目23：找树左下角的值-力扣513" class="headerlink" title="题目23：找树左下角的值(力扣513)"></a><font color="red">题目23：找树左下角的值(力扣513)</font></h3><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p>示例 1:</p>
<p>输入: root &#x3D; [2,1,3]<br>输出: 1</p>
<p>示例 2:</p>
<p>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7<br> <br>提示:</p>
<p>二叉树的节点个数的范围是 [1,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 </p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value">题目地址</a></p>
<h4 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            root = que.poll();</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目24：前中、中后构造二叉树-力扣xxx-不会"><a href="#题目24：前中、中后构造二叉树-力扣xxx-不会" class="headerlink" title="题目24：前中、中后构造二叉树(力扣xxx)不会"></a><font color="red">题目24：前中、中后构造二叉树(力扣xxx)不会</font></h3><h3 id="题目26：最大二叉树-力扣654"><a href="#题目26：最大二叉树-力扣654" class="headerlink" title="题目26：最大二叉树(力扣654)"></a><font color="red">题目26：最大二叉树(力扣654)</font></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例 2：</p>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[3,null,2,null,1]<br> <br>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums 中的所有整数 互不相同</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree">题目地址</a></p>
<h4 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>;i &lt;= end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[index]);</span><br><span class="line">        node.left = construct(nums, start, index - <span class="number">1</span>);</span><br><span class="line">        node.right = construct(nums, index + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目27：合并二叉树-力扣617"><a href="#题目27：合并二叉树-力扣617" class="headerlink" title="题目27：合并二叉树(力扣617)"></a><font color="red">题目27：合并二叉树(力扣617)</font></h3><p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p>示例 1：</p>
<p>输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p>
<p>示例 2：</p>
<p>输入：root1 &#x3D; [1], root2 &#x3D; [1,2]<br>输出：[2,2]<br> <br>提示：</p>
<p>两棵树中的节点数目在范围 [0, 2000] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees">题目地址</a></p>
<h4 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目28：二叉搜索树的搜索-力扣700"><a href="#题目28：二叉搜索树的搜索-力扣700" class="headerlink" title="题目28：二叉搜索树的搜索(力扣700)"></a><font color="red">题目28：二叉搜索树的搜索(力扣700)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<p>示例 1:</p>
<p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2<br>输出：[2,1,3]</p>
<p>示例 2:</p>
<p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[]<br> <br>提示：</p>
<p>数中节点数在 [1, 5000] 范围内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^7<br>root 是二叉搜索树<br>1 &lt;&#x3D; val &lt;&#x3D; 10^7</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree">题目地址</a></p>
<h4 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> searchBST(val &lt; root.val ? root.left : root.right, val); <span class="comment">//根据二叉搜索树的性质，根的值比左边大，比右边小。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目29：验证二叉搜索树-力扣98"><a href="#题目29：验证二叉搜索树-力扣98" class="headerlink" title="题目29：验证二叉搜索树(力扣98)"></a><font color="red">题目29：验证二叉搜索树(力扣98)</font></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<br> <br>提示：</p>
<p>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree">题目地址</a></p>
<h4 id="思路-70"><a href="#思路-70" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左子树小于当前根节点，右子树大于当前根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(TreeNode root,<span class="type">long</span> min,<span class="type">long</span> max)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> validBST(root.left,min,root.val) &amp;&amp; validBST(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目30：二叉搜索树的最小绝对差-力扣530或783"><a href="#题目30：二叉搜索树的最小绝对差-力扣530或783" class="headerlink" title="题目30：二叉搜索树的最小绝对差(力扣530或783)"></a><font color="red">题目30：二叉搜索树的最小绝对差(力扣530或783)</font></h3><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [4,2,6,1,3]<br>输出：1</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [1,0,48,null,null,12,49]<br>输出：1<br> <br>提示：</p>
<p>树中节点的数目范围是 [2, 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">题目地址</a></p>
<h4 id="思路-71"><a href="#思路-71" class="headerlink" title="思路"></a>思路</h4><p>利用二叉搜索树的性质（左子树小于根，根小于右），当转成数组时，二叉搜索树（中序遍历）就是一个升序的数组，<strong>即BST的中序遍历就是遍历一个有序数组</strong>，利用这个可以解决本题。</p>
<h4 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目31：二叉搜索树中的众数-力扣501"><a href="#题目31：二叉搜索树中的众数-力扣501" class="headerlink" title="题目31：二叉搜索树中的众数(力扣501)"></a><font color="red">题目31：二叉搜索树中的众数(力扣501)</font></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
<p>假定 BST 满足如下定义：</p>
<p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树<br> <br>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,2]<br>输出：[2]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [0]<br>输出：[0]<br> <br>提示：</p>
<p>树中节点的数目在范围 [1, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree">题目地址</a></p>
<h4 id="思路-72"><a href="#思路-72" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curent</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最大的重复数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="comment">//把集合list转化为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        inOrderTraversal(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是对当前节点的一些逻辑操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeValue</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">if</span> (nodeValue == curent) &#123;</span><br><span class="line">            <span class="comment">//如果节点值等于curent，count就加1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，就表示遇到了一个新的值，curent和count都要</span></span><br><span class="line">            <span class="comment">//重新赋值</span></span><br><span class="line">            curent = nodeValue;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            <span class="comment">//如果count == maxCount，就把当前节点加入到集合中</span></span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//否则，当前节点的值重复量是最多的，直接把list清空，然后</span></span><br><span class="line">            <span class="comment">//把当前节点的值加入到集合中</span></span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历右子树</span></span><br><span class="line">        inOrderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目32：二叉树的最近公共祖先-力扣236"><a href="#题目32：二叉树的最近公共祖先-力扣236" class="headerlink" title="题目32：二叉树的最近公共祖先(力扣236)"></a><font color="red">题目32：二叉树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1<br> <br>提示：</p>
<p>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">题目地址</a></p>
<h4 id="思路-73"><a href="#思路-73" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="comment">//当遍历到叶结点后就会返回null</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;<span class="comment">//当找到p或者q的是时候就会返回pq</span></span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外</span></span><br><span class="line"><span class="comment">                     一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);<span class="comment">//返回的结点进行保存，可能是null</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);<span class="comment">//也可能是pq，还可能是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;<span class="comment">//否则我们返回已经找到的那个值（存储在left，与right中），p或者q</span></span><br><span class="line">            <span class="keyword">return</span> left;<span class="comment">//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目33：二叉搜索树的最近公共祖先-力扣236"><a href="#题目33：二叉搜索树的最近公共祖先-力扣236" class="headerlink" title="题目33：二叉搜索树的最近公共祖先(力扣236)"></a><font color="red">题目33：二叉搜索树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:</p>
<p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p>示例 2:</p>
<p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">题目地址</a></p>
<h4 id="思路-74"><a href="#思路-74" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目34：二叉搜索树的插入操作-力扣701"><a href="#题目34：二叉搜索树的插入操作-力扣701" class="headerlink" title="题目34：二叉搜索树的插入操作(力扣701)"></a><font color="red">题目34：二叉搜索树的插入操作(力扣701)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25<br>输出：[40,20,60,10,30,50,70,null,null,25]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br> <br>提示：</p>
<p>树中的节点数将在 [0, 10^4]的范围内。<br>-10^8 &lt;&#x3D; Node.val &lt;&#x3D; 10^8<br>所有值 Node.val 是 独一无二 的。<br>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8<br>保证 val 在原始BST中不存在。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree">题目地址</a></p>
<h4 id="思路-75"><a href="#思路-75" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目35：刪除二叉搜索树的节点-力扣450"><a href="#题目35：刪除二叉搜索树的节点-力扣450" class="headerlink" title="题目35：刪除二叉搜索树的节点(力扣450)"></a><font color="red">题目35：刪除二叉搜索树的节点(力扣450)</font></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<p>示例 1:</p>
<p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p>
<p>示例 2:</p>
<p>输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点</p>
<p>示例 3:</p>
<p>输入: root &#x3D; [], key &#x3D; 0<br>输出: []</p>
<p>提示:</p>
<p>节点数的范围 [0, 10^4].<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>节点值唯一<br>root 是合法的二叉搜索树<br>-10^5 &lt;&#x3D; key &lt;&#x3D; 10^5</p>
<p>进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<h4 id="思路-76"><a href="#思路-76" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 去右子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val)    </span><br><span class="line">            root.left = deleteNode(root.left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;  <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>)   <span class="keyword">return</span> root.right;      <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>)  <span class="keyword">return</span> root.left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.left!=<span class="literal">null</span> &amp;&amp; root.right !=<span class="literal">null</span>)&#123;  <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;   </span><br><span class="line">                <span class="keyword">while</span> (node.left != <span class="literal">null</span>)      <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                    node = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = root.left;     <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">                root = root.right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目36：修剪二叉搜索树-力扣669"><a href="#题目36：修剪二叉搜索树-力扣669" class="headerlink" title="题目36：修剪二叉搜索树(力扣669)"></a><font color="red">题目36：修剪二叉搜索树(力扣669)</font></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,0,2], low &#x3D; 1, high &#x3D; 2<br>输出：[1,null,2]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3<br>输出：[3,2,null,1]</p>
<p>提示：</p>
<p>树中节点数在范围 [1, 10^4] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^4<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 10^4</p>
<h4 id="思路-77"><a href="#思路-77" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最大值大，直接返回左子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最小值小，直接返回右子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别对左右子树进行处理</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目37：将有序数组转换为二叉搜索树-力扣108"><a href="#题目37：将有序数组转换为二叉搜索树-力扣108" class="headerlink" title="题目37：将有序数组转换为二叉搜索树(力扣108)"></a><font color="red">题目37：将有序数组转换为二叉搜索树(力扣108)</font></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p>示例 2：</p>
<p>输入：nums &#x3D; [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 按 严格递增 顺序排列</p>
<h4 id="思路-78"><a href="#思路-78" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, left, mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目38：把二叉搜索树转换为累加树-力扣538"><a href="#题目38：把二叉搜索树转换为累加树-力扣538" class="headerlink" title="题目38：把二叉搜索树转换为累加树(力扣538)"></a><font color="red">题目38：把二叉搜索树转换为累加树(力扣538)</font></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038</a> 相同</p>
<p>示例 1：</p>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>示例 2：</p>
<p>输入：root &#x3D; [0,null,1]<br>输出：[1,null,1]</p>
<p>示例 3：</p>
<p>输入：root &#x3D; [1,0,2]<br>输出：[3,3,2]</p>
<p>示例 4：</p>
<p>输入：root &#x3D; [3,2,4,1]<br>输出：[7,9,4,10]</p>
<p>提示：</p>
<p>树中的节点数介于 0 和 10^4 之间。<br>每个节点的值介于 -10^4 和 10^4 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p>
<h4 id="思路-79"><a href="#思路-79" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convertBST1(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按右中左顺序遍历，累加即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertBST1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST1(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST1(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h3 id="题目1：组合-力扣77"><a href="#题目1：组合-力扣77" class="headerlink" title="题目1：组合(力扣77)"></a><font color="red">题目1：组合(力扣77)</font></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<p>示例 2：</p>
<p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 20<br>1 &lt;&#x3D; k &lt;&#x3D; n</p>
<h4 id="思路-80"><a href="#思路-80" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化（剪枝）</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            1.已经选择的元素个数：ret.size();</span></span><br><span class="line"><span class="comment">            2.还需要的元素个数为: k - ret.size();</span></span><br><span class="line"><span class="comment">            3.列表中可选元素（n-i） &gt;= 还需要的元素个数（k - ret.size()）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            为什么需要+1？？（限制最大搜索起点）</span></span><br><span class="line"><span class="comment">                举个例子，n = 4，k = 3， 目前已经选取的元素为0（ret.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。即+1后，【2，3，,4】这个组合都是可以成立的</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt;= n - (k-ret.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            backTrack(n,k,i+<span class="number">1</span>);</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目2：组合-力扣216"><a href="#题目2：组合-力扣216" class="headerlink" title="题目2：组合|||(力扣216)"></a><font color="red">题目2：组合|||(力扣216)</font></h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p>示例 1:</p>
<p>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。</p>
<p>示例 2:</p>
<p>输入: k &#x3D; 3, n &#x3D; 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>没有其他符合的组合了。</p>
<p>示例 3:</p>
<p>输入: k &#x3D; 4, n &#x3D; 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 &#x3D; 10，因为10 &gt; 1，没有有效的组合。</p>
<p>提示:</p>
<p>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60</p>
<h4 id="思路-81"><a href="#思路-81" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backTrack(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTrack(k,n,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		backTracking(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">		<span class="comment">// 减枝</span></span><br><span class="line">		<span class="keyword">if</span> (sum &gt; targetSum) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sum == targetSum) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 减枝 9 - (k - path.size()) + 1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			path.add(i);</span><br><span class="line">			sum += i;</span><br><span class="line">			backTracking(targetSum, k, i + <span class="number">1</span>, sum);</span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">			path.removeLast();</span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">			sum -= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目3：电话号码的字母组合-力扣17"><a href="#题目3：电话号码的字母组合-力扣17" class="headerlink" title="题目3：电话号码的字母组合(力扣17)"></a><font color="red">题目3：电话号码的字母组合(力扣17)</font></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例 1：</p>
<p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>示例 2：</p>
<p>输入：digits &#x3D; “”<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p>
<p>提示：</p>
<p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
<h4 id="思路-82"><a href="#思路-82" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目4：组合总和-力扣39"><a href="#题目4：组合总和-力扣39" class="headerlink" title="题目4：组合总和(力扣39)"></a><font color="red">题目4：组合总和(力扣39)</font></h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：</p>
<p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p>
<p>示例 2：</p>
<p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p>
<p>示例 3：</p>
<p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p>
<p>提示：</p>
<p>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>2 &lt;&#x3D; candidates[i] &lt;&#x3D; 40<br>candidates 的所有元素 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 40</p>
<h4 id="思路-83"><a href="#思路-83" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要先进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝操作：若 sum + candidates[i] &gt; target, 则不进入循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            ret.add(candidates[i]);</span><br><span class="line">            backtrack(i, candidates, target);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            ret.remove(ret.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhanghm0915.github.io">zhanghm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhanghm0915.github.io/2023/03/29/myleetcode/myleetcode/">https://zhanghm0915.github.io/2023/03/29/myleetcode/myleetcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhanghm0915.github.io" target="_blank">zhanghm的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003731-16221334517645.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/30/mysql/mysql/"><img class="prev-cover" src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003636-16221333966665.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mysql那些事</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/28/juc/juc-h/"><img class="next-cover" src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/223619-16762989795a96.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">juc-JMM</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhanghm</div><div class="author-info__description">我裂开了只为给老板买劳斯莱斯</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zhanghm0915"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Zhanghm0915" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2769245720&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2769245720@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.</span> <span class="toc-text">① 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用情景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">边界条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E5%8A%9B%E6%89%A3704%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">题目1：二分查找（力扣704）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8A%9B%E6%89%A335%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">题目2:搜索插入位置（力扣35）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8A%9B%E6%89%A334%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9Ax%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E5%8A%9B%E6%89%A369%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">题目4：x的平方根（力扣69）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E5%8A%9B%E6%89%A3367%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">题目5：有效的完全平方数（力扣367）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8A%9B%E6%89%A3852%EF%BC%89"><span class="toc-number">1.1.8.</span> <span class="toc-text">题目6：山脉数组的峰顶索引（力扣852）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%EF%BC%88%E5%8A%9B%E6%89%A3744%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">题目7：寻找比目标字母大的最小字母（力扣744）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A1%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">②移除元素之双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E5%8A%9B%E6%89%A327%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">题目1：移除元素（力扣27）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%88%E5%8A%9B%E6%89%A326%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">题目2：删除有序数组中的重复项（力扣26）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8A%9B%E6%89%A3283%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">题目3：移动零（力扣283）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%8A%9B%E6%89%A3844%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">题目4：比较含退格的字符串（力扣844）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%EF%BC%88%E5%8A%9B%E6%89%A3977%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">题目5：有序数组的平方（力扣977）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E5%8A%9B%E6%89%A3125%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">题目6：验证回文串（力扣125）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A2%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%90%E4%B8%B2%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">③子数组、子串之滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E5%8A%9B%E6%89%A3209%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">题目1：长度最小的子数组（力扣209）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE%EF%BC%88%E5%8A%9B%E6%89%A3904%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">题目2：水果成篮（力扣904）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%EF%BC%88%E5%8A%9B%E6%89%A3203%EF%BC%89"><span class="toc-number">2.0.1.</span> <span class="toc-text">题目1：移除链表元素（力扣203）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8A%9B%E6%89%A3707%EF%BC%89"><span class="toc-number">2.0.2.</span> <span class="toc-text">题目2：设计链表（力扣707）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8A%9B%E6%89%A3206%EF%BC%89"><span class="toc-number">2.0.3.</span> <span class="toc-text">题目3：反转链表（力扣206）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E5%8A%9B%E6%89%A324%EF%BC%89"><span class="toc-number">2.0.4.</span> <span class="toc-text">题目4：两两交换链表中的节点（力扣24）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%8A%9B%E6%89%A319%EF%BC%89"><span class="toc-number">2.0.5.</span> <span class="toc-text">题目5：删除链表的倒数第N个结点（力扣19）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4-lt-%E5%8A%9B%E6%89%A3%E5%90%8C%E9%A2%98160-gt"><span class="toc-number">2.0.6.</span> <span class="toc-text">题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-lt-%E5%8A%9B%E6%89%A3142-gt"><span class="toc-number">2.0.7.</span> <span class="toc-text">题目7：环形链表||&lt;力扣142&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E5%8A%9B%E6%89%A3242%EF%BC%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">题目1：有效的字母异位词（力扣242）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%88%E5%8A%9B%E6%89%A3349%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">题目2：两个数组的交集（力扣349）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E5%BF%AB%E4%B9%90%E6%95%B0%EF%BC%88%E5%8A%9B%E6%89%A3202%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">题目3：快乐数（力扣202）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E5%8A%9B%E6%89%A31%EF%BC%89"><span class="toc-number">3.0.4.</span> <span class="toc-text">题目4：两数之和（力扣1）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-%EF%BC%88%E5%8A%9B%E6%89%A3454%EF%BC%89"><span class="toc-number">3.0.5.</span> <span class="toc-text">题目5：四数相加||（力扣454）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-number">3.0.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-number">3.0.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E8%B5%8E%E9%87%91%E4%BF%A1%EF%BC%88%E5%8A%9B%E6%89%A3383%EF%BC%89"><span class="toc-number">3.0.6.</span> <span class="toc-text">题目6：赎金信（力扣383）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-number">3.0.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-number">3.0.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E5%8A%9B%E6%89%A315%EF%BC%89"><span class="toc-number">3.0.7.</span> <span class="toc-text">题目7：三数之和（力扣15）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-number">3.0.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-number">3.0.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE8%EF%BC%9A%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E5%8A%9B%E6%89%A318%EF%BC%89"><span class="toc-number">3.0.8.</span> <span class="toc-text">题目8：四数之和（力扣18）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-number">3.0.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-number">3.0.8.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%8A%9B%E6%89%A3344%EF%BC%89"><span class="toc-number">4.0.1.</span> <span class="toc-text">题目1：反转字符串（力扣344）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%EF%BC%88%E5%8A%9B%E6%89%A3541%EF%BC%89"><span class="toc-number">4.0.2.</span> <span class="toc-text">题目2：反转字符串||（力扣541）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%89"><span class="toc-number">4.0.3.</span> <span class="toc-text">题目3：剑指Offer 05.替换空格（力扣？？？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%EF%BC%88%E5%8A%9B%E6%89%A3151%EF%BC%89"><span class="toc-number">4.0.4.</span> <span class="toc-text">题目4：反转字符串中的单词（力扣151）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E5%89%91%E6%8C%87Offer-58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%89"><span class="toc-number">4.0.5.</span> <span class="toc-text">题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-number">4.0.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-number">4.0.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%88%E5%8A%9B%E6%89%A328%EF%BC%89"><span class="toc-number">4.0.6.</span> <span class="toc-text">题目6：找出字符串中第一个匹配的下标（力扣28）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%8A%9B%E6%89%A3459%EF%BC%89"><span class="toc-number">4.0.7.</span> <span class="toc-text">题目7：重复的子字符串（力扣459）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-number">4.0.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-number">4.0.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E5%8A%9B%E6%89%A3232"><span class="toc-number">5.0.1.</span> <span class="toc-text">题目1：用栈实现队列(力扣232)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-%E5%8A%9B%E6%89%A3225"><span class="toc-number">5.0.2.</span> <span class="toc-text">题目2：用队列实现栈(力扣225)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-number">5.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E5%8A%9B%E6%89%A320"><span class="toc-number">5.0.3.</span> <span class="toc-text">题目3：有效的括号(力扣20)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-number">5.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-number">5.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-%E5%8A%9B%E6%89%A31047"><span class="toc-number">5.0.4.</span> <span class="toc-text">题目4：删除字符串中的所有相邻重复项(力扣1047)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-%E5%8A%9B%E6%89%A3150"><span class="toc-number">5.0.5.</span> <span class="toc-text">题目5：逆波兰表达式求值(力扣150)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-number">5.0.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-number">5.0.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8A%9B%E6%89%A3239"><span class="toc-number">5.0.6.</span> <span class="toc-text">题目6：滑动窗口最大值(力扣239)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-number">5.0.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-number">5.0.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E5%8A%9B%E6%89%A3347"><span class="toc-number">5.0.7.</span> <span class="toc-text">题目7：前K个高频元素(力扣347)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-number">5.0.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-number">5.0.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3144"><span class="toc-number">6.0.1.</span> <span class="toc-text">题目1：二叉树的前序遍历(力扣144)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A394"><span class="toc-number">6.0.2.</span> <span class="toc-text">题目2：二叉树的中序遍历(力扣94)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3145"><span class="toc-number">6.0.3.</span> <span class="toc-text">题目3：二叉树的后序遍历(力扣145)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-number">6.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-number">6.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3102"><span class="toc-number">6.0.4.</span> <span class="toc-text">题目4：二叉树的层序遍历(力扣102)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-number">6.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-number">6.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3107"><span class="toc-number">6.0.5.</span> <span class="toc-text">题目5：二叉树的层序遍历||(力扣107)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-number">6.0.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-number">6.0.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-%E5%8A%9B%E6%89%A3199"><span class="toc-number">6.0.6.</span> <span class="toc-text">题目6：二叉树的右视图(力扣199)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-number">6.0.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-number">6.0.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC-%E5%8A%9B%E6%89%A3637"><span class="toc-number">6.0.7.</span> <span class="toc-text">题目7：二叉树的层平均值(力扣637)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-number">6.0.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-number">6.0.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE8%EF%BC%9AN%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3637"><span class="toc-number">6.0.8.</span> <span class="toc-text">题目8：N叉树的层序遍历(力扣637)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-number">6.0.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-number">6.0.8.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE9%EF%BC%9A%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8A%9B%E6%89%A3515"><span class="toc-number">6.0.9.</span> <span class="toc-text">题目9：在每个树中找最大值(力扣515)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-number">6.0.9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-number">6.0.9.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE10%EF%BC%9A%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-%E5%8A%9B%E6%89%A3116"><span class="toc-number">6.0.10.</span> <span class="toc-text">题目10：填充每个节点的下一个右侧节点指针(力扣116)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-number">6.0.10.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-number">6.0.10.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE11%EF%BC%9A%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-%E5%8A%9B%E6%89%A3117"><span class="toc-number">6.0.11.</span> <span class="toc-text">题目11：填充每个节点的下一个右侧节点指针||(力扣117)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-number">6.0.11.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-number">6.0.11.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE12%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E5%8A%9B%E6%89%A3104"><span class="toc-number">6.0.12.</span> <span class="toc-text">题目12：二叉树的最大深度(力扣104)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-number">6.0.12.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-number">6.0.12.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE13%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-%E5%8A%9B%E6%89%A3111"><span class="toc-number">6.0.13.</span> <span class="toc-text">题目13：二叉树的最小深度(力扣111)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-number">6.0.13.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-number">6.0.13.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE14%EF%BC%9A%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3226"><span class="toc-number">6.0.14.</span> <span class="toc-text">题目14：翻转二叉树(力扣226)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-number">6.0.14.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-number">6.0.14.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE15%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3101"><span class="toc-number">6.0.15.</span> <span class="toc-text">题目15：对称二叉树(力扣101)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-number">6.0.15.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-number">6.0.15.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE16%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-%E5%8A%9B%E6%89%A3100"><span class="toc-number">6.0.16.</span> <span class="toc-text">题目16：相同的树(力扣100)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-number">6.0.16.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-number">6.0.16.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE17%EF%BC%9A%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91-%E5%8A%9B%E6%89%A3572"><span class="toc-number">6.0.17.</span> <span class="toc-text">题目17：另一棵树的子树(力扣572)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-60"><span class="toc-number">6.0.17.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-number">6.0.17.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE18%EF%BC%9AN%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E5%8A%9B%E6%89%A3559"><span class="toc-number">6.0.18.</span> <span class="toc-text">题目18：N叉树的最大深度(力扣559)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-61"><span class="toc-number">6.0.18.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-number">6.0.18.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE19%EF%BC%9A%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E5%8A%9B%E6%89%A3222"><span class="toc-number">6.0.19.</span> <span class="toc-text">题目19：完全二叉树的节点个数(力扣222)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-62"><span class="toc-number">6.0.19.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-62"><span class="toc-number">6.0.19.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE20%EF%BC%9A%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E5%8A%9B%E6%89%A3222"><span class="toc-number">6.0.20.</span> <span class="toc-text">题目20：完全二叉树的节点个数(力扣222)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-63"><span class="toc-number">6.0.20.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-63"><span class="toc-number">6.0.20.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE21%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-%E5%8A%9B%E6%89%A3257"><span class="toc-number">6.0.21.</span> <span class="toc-text">题目21：二叉树的所有路径(力扣257)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-64"><span class="toc-number">6.0.21.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-64"><span class="toc-number">6.0.21.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE22%EF%BC%9A%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3404"><span class="toc-number">6.0.22.</span> <span class="toc-text">题目22：左子树之和(力扣404)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-65"><span class="toc-number">6.0.22.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-65"><span class="toc-number">6.0.22.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE23%EF%BC%9A%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-%E5%8A%9B%E6%89%A3513"><span class="toc-number">6.0.23.</span> <span class="toc-text">题目23：找树左下角的值(力扣513)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-66"><span class="toc-number">6.0.23.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-66"><span class="toc-number">6.0.23.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE24%EF%BC%9A%E5%89%8D%E4%B8%AD%E3%80%81%E4%B8%AD%E5%90%8E%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3xxx-%E4%B8%8D%E4%BC%9A"><span class="toc-number">6.0.24.</span> <span class="toc-text">题目24：前中、中后构造二叉树(力扣xxx)不会</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE26%EF%BC%9A%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3654"><span class="toc-number">6.0.25.</span> <span class="toc-text">题目26：最大二叉树(力扣654)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-67"><span class="toc-number">6.0.25.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-67"><span class="toc-number">6.0.25.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE27%EF%BC%9A%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3617"><span class="toc-number">6.0.26.</span> <span class="toc-text">题目27：合并二叉树(力扣617)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-68"><span class="toc-number">6.0.26.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-68"><span class="toc-number">6.0.26.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE28%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2-%E5%8A%9B%E6%89%A3700"><span class="toc-number">6.0.27.</span> <span class="toc-text">题目28：二叉搜索树的搜索(力扣700)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-69"><span class="toc-number">6.0.27.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-69"><span class="toc-number">6.0.27.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE29%EF%BC%9A%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E5%8A%9B%E6%89%A398"><span class="toc-number">6.0.28.</span> <span class="toc-text">题目29：验证二叉搜索树(力扣98)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-70"><span class="toc-number">6.0.28.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-70"><span class="toc-number">6.0.28.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE30%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-%E5%8A%9B%E6%89%A3530%E6%88%96783"><span class="toc-number">6.0.29.</span> <span class="toc-text">题目30：二叉搜索树的最小绝对差(力扣530或783)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-71"><span class="toc-number">6.0.29.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-71"><span class="toc-number">6.0.29.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE31%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0-%E5%8A%9B%E6%89%A3501"><span class="toc-number">6.0.30.</span> <span class="toc-text">题目31：二叉搜索树中的众数(力扣501)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-72"><span class="toc-number">6.0.30.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-72"><span class="toc-number">6.0.30.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE32%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E5%8A%9B%E6%89%A3236"><span class="toc-number">6.0.31.</span> <span class="toc-text">题目32：二叉树的最近公共祖先(力扣236)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-73"><span class="toc-number">6.0.31.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-73"><span class="toc-number">6.0.31.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE33%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E5%8A%9B%E6%89%A3236"><span class="toc-number">6.0.32.</span> <span class="toc-text">题目33：二叉搜索树的最近公共祖先(力扣236)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-74"><span class="toc-number">6.0.32.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-74"><span class="toc-number">6.0.32.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE34%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-%E5%8A%9B%E6%89%A3701"><span class="toc-number">6.0.33.</span> <span class="toc-text">题目34：二叉搜索树的插入操作(力扣701)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-75"><span class="toc-number">6.0.33.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-75"><span class="toc-number">6.0.33.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE35%EF%BC%9A%E5%88%AA%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9-%E5%8A%9B%E6%89%A3450"><span class="toc-number">6.0.34.</span> <span class="toc-text">题目35：刪除二叉搜索树的节点(力扣450)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-76"><span class="toc-number">6.0.34.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-76"><span class="toc-number">6.0.34.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE36%EF%BC%9A%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E5%8A%9B%E6%89%A3669"><span class="toc-number">6.0.35.</span> <span class="toc-text">题目36：修剪二叉搜索树(力扣669)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-77"><span class="toc-number">6.0.35.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-77"><span class="toc-number">6.0.35.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE37%EF%BC%9A%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E5%8A%9B%E6%89%A3108"><span class="toc-number">6.0.36.</span> <span class="toc-text">题目37：将有序数组转换为二叉搜索树(力扣108)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-78"><span class="toc-number">6.0.36.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-78"><span class="toc-number">6.0.36.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE38%EF%BC%9A%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-%E5%8A%9B%E6%89%A3538"><span class="toc-number">6.0.37.</span> <span class="toc-text">题目38：把二叉搜索树转换为累加树(力扣538)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-79"><span class="toc-number">6.0.37.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-79"><span class="toc-number">6.0.37.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">7.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1%EF%BC%9A%E7%BB%84%E5%90%88-%E5%8A%9B%E6%89%A377"><span class="toc-number">7.0.1.</span> <span class="toc-text">题目1：组合(力扣77)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-80"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-80"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E7%BB%84%E5%90%88-%E5%8A%9B%E6%89%A3216"><span class="toc-number">7.0.2.</span> <span class="toc-text">题目2：组合|||(力扣216)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-81"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-81"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3%EF%BC%9A%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-%E5%8A%9B%E6%89%A317"><span class="toc-number">7.0.3.</span> <span class="toc-text">题目3：电话号码的字母组合(力扣17)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-82"><span class="toc-number">7.0.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-82"><span class="toc-number">7.0.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4%EF%BC%9A%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E5%8A%9B%E6%89%A339"><span class="toc-number">7.0.4.</span> <span class="toc-text">题目4：组合总和(力扣39)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-83"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-83"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/30/jdbc/jdbc/" title="jdbc"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/223619-16762989795a96.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jdbc"/></a><div class="content"><a class="title" href="/2023/03/30/jdbc/jdbc/" title="jdbc">jdbc</a><time datetime="2023-03-30T14:45:52.000Z" title="发表于 2023-03-30 22:45:52">2023-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/30/redis/redis/" title="redis那些事"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230327104551.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis那些事"/></a><div class="content"><a class="title" href="/2023/03/30/redis/redis/" title="redis那些事">redis那些事</a><time datetime="2023-03-30T14:39:04.000Z" title="发表于 2023-03-30 22:39:04">2023-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/30/mysql/mysql/" title="mysql那些事"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003636-16221333966665.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql那些事"/></a><div class="content"><a class="title" href="/2023/03/30/mysql/mysql/" title="mysql那些事">mysql那些事</a><time datetime="2023-03-30T14:14:51.000Z" title="发表于 2023-03-30 22:14:51">2023-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/myleetcode/myleetcode/" title="我的leetcode刷题记录"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003731-16221334517645.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的leetcode刷题记录"/></a><div class="content"><a class="title" href="/2023/03/29/myleetcode/myleetcode/" title="我的leetcode刷题记录">我的leetcode刷题记录</a><time datetime="2023-03-29T08:49:03.000Z" title="发表于 2023-03-29 16:49:03">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/28/juc/juc-h/" title="juc-JMM"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/223619-16762989795a96.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="juc-JMM"/></a><div class="content"><a class="title" href="/2023/03/28/juc/juc-h/" title="juc-JMM">juc-JMM</a><time datetime="2023-03-28T10:42:06.000Z" title="发表于 2023-03-28 18:42:06">2023-03-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/213705-1550497025568e.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zhanghm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>