<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java基础(全) | zhanghm的个人博客</title><meta name="author" content="zhanghm"><meta name="copyright" content="zhanghm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SE基础数据变量类型    成员变量 局部变量 静态变量    定义位置 在类中，方法外 方法中或者方法的形参 在类中，方法外   初始化值 有默认初始化值 无，赋值后才能使用 有默认初始化值   调用方法 对象调用  对象调用，类名调用   存储位置 堆中 栈中 方法区（JDK8 以后移到堆中）   生命周期 与对象共存亡 与方法共存亡 与类共存亡   别名 实例变量  类变量，静态成员变量">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础(全)">
<meta property="og:url" content="https://zhanghm0915.github.io/2023/03/04/Java/java/index.html">
<meta property="og:site_name" content="zhanghm的个人博客">
<meta property="og:description" content="SE基础数据变量类型    成员变量 局部变量 静态变量    定义位置 在类中，方法外 方法中或者方法的形参 在类中，方法外   初始化值 有默认初始化值 无，赋值后才能使用 有默认初始化值   调用方法 对象调用  对象调用，类名调用   存储位置 堆中 栈中 方法区（JDK8 以后移到堆中）   生命周期 与对象共存亡 与方法共存亡 与类共存亡   别名 实例变量  类变量，静态成员变量">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/03%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png">
<meta property="article:published_time" content="2023-03-04T13:22:10.000Z">
<meta property="article:modified_time" content="2023-03-26T14:58:49.573Z">
<meta property="article:author" content="zhanghm">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/03%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhanghm0915.github.io/2023/03/04/Java/java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础(全)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 22:58:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/03%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhanghm的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础(全)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-04T13:22:10.000Z" title="发表于 2023-03-04 21:22:10">2023-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-26T14:58:49.573Z" title="更新于 2023-03-26 22:58:49">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>93分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础(全)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
<th align="center">静态变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义位置</td>
<td align="center">在类中，方法外</td>
<td align="center">方法中或者方法的形参</td>
<td align="center">在类中，方法外</td>
</tr>
<tr>
<td align="center">初始化值</td>
<td align="center">有默认初始化值</td>
<td align="center">无，赋值后才能使用</td>
<td align="center">有默认初始化值</td>
</tr>
<tr>
<td align="center">调用方法</td>
<td align="center">对象调用</td>
<td align="center"></td>
<td align="center">对象调用，类名调用</td>
</tr>
<tr>
<td align="center">存储位置</td>
<td align="center">堆中</td>
<td align="center">栈中</td>
<td align="center">方法区（JDK8 以后移到堆中）</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="center">与对象共存亡</td>
<td align="center">与方法共存亡</td>
<td align="center">与类共存亡</td>
</tr>
<tr>
<td align="center">别名</td>
<td align="center">实例变量</td>
<td align="center"></td>
<td align="center">类变量，静态成员变量</td>
</tr>
</tbody></table>
<p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TE41177m">参考视频</a></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li>
<li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li>
<li>默认值是 <code>0</code></li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li>
<li>例子：<code>byte a = 100，byte b = -50</code></li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li>
<li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>short s = 1000，short r = -20000</code></li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li>
<li>一般地整型变量默认为 int 类型</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>int a = 100000, int b = -200000</code></li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li>
<li>这种类型主要使用在需要比较大整数的系统上</li>
<li>默认值是 <code> 0L</code></li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li>
<li>float 在储存大型浮点数组的时候可节省内存空间</li>
<li>默认值是 <code>0.0f</code></li>
<li>浮点数不能用来表示精确的值，如货币</li>
<li>例子：<code>float f1 = 234.5F</code></li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li>
<li>浮点数的默认类型为 double 类型</li>
<li>double 类型同样不能表示精确的值，如货币</li>
<li>默认值是 <code>0.0d</code></li>
<li>例子：<code>double d1 = 123.4</code></li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean 数据类型表示一位的信息</li>
<li>只有两个取值：true 和 false</li>
<li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li>
<li>默认值是 <code>false</code></li>
<li>例子：<code>boolean one = true</code></li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li>
<li>最小值是 <code>\u0000</code>（即为 0）</li>
<li>最大值是 <code>\uffff</code>（即为 65535）</li>
<li>char 数据类型可以<strong>存储任何字符</strong></li>
<li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li>
</ul>
<h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul>
<li><p>float 与 double：</p>
<p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//1.1f 字面量才是 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> (<span class="type">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1245</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (<span class="type">int</span>) l2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式类型转换：</p>
<p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p>
<p>使用 +&#x3D; 或者 ++ 运算符会执行类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;	<span class="comment">//s1++;</span></span><br><span class="line"><span class="comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span></span><br><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p>
<p>包装类的作用：</p>
<ul>
<li>包装类作为类首先拥有了 Object 类的方法</li>
<li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）</span><br><span class="line"><span class="type">byte</span>                      Byte</span><br><span class="line"><span class="type">short</span>                     Short</span><br><span class="line"><span class="type">int</span>                       Integer</span><br><span class="line"><span class="type">long</span>                      Long</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>                     Float</span><br><span class="line"><span class="type">double</span>                    Double</span><br><span class="line"><span class="type">char</span>                      Character</span><br><span class="line"><span class="type">boolean</span>                   Boolean</span><br></pre></td></tr></table></figure>
<p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p>
<ul>
<li><p>可以把基本数据类型的值转换成字符串类型的值</p>
<ol>
<li>调用 toString() 方法</li>
<li>调用 Integer.toString(基本数据类型的值) 得到字符串</li>
<li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li>
</ol>
</li>
<li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p>
<ol>
<li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li>
<li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClass02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.把基本数据类型的值转成字符串</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="comment">// a.调用toString()方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr</span> <span class="operator">=</span> it.toString();</span><br><span class="line">        System.out.println(itStr+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr1</span> <span class="operator">=</span> Integer.toString(it);</span><br><span class="line">        System.out.println(itStr1+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr2</span> <span class="operator">=</span> it + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(itStr2+<span class="number">1</span>);<span class="comment">// 1001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.valueOf(numStr);</span><br><span class="line">        System.out.println(numInt+<span class="number">1</span>);<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">doubleStr</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleDb</span> <span class="operator">=</span> Double.valueOf(doubleStr);</span><br><span class="line">        System.out.println(doubleDb+<span class="number">0.1</span>);<span class="comment">//100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul>
<li><p>有了基本数据类型，为什么还要引用数据类型？</p>
<blockquote>
<p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p>
<p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p>
</blockquote>
</li>
<li><p>引用数据类型那么好，为什么还用基本数据类型？</p>
<blockquote>
<p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p>
</blockquote>
</li>
<li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p>
<blockquote>
<p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;</p>
<blockquote>
<p>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值<br>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</p>
</blockquote>
</li>
</ul>
<h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p>
<p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackegeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">12</span> ;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> a ;   <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 引用数据类型的默认值可以为null</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c ;      <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(<span class="number">12</span>);  	<span class="comment">// 手工装箱！</span></span><br><span class="line">        <span class="comment">// Integer it1 = new Integer(12); 	// 手工装箱！</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="number">111</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it33</span> <span class="operator">=</span> it3.intValue(); <span class="comment">// 手工拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 【缓存池】，本质上是一个数组</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li><p>new Integer(123)：每次都会新建一个对象</p>
</li>
<li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p>
<p><strong>基本类型对应的缓存池如下：</strong></p>
<ul>
<li>Boolean values true and false</li>
<li>all byte values</li>
<li>Short values between -128 and 127</li>
<li>Long values between -128 and 127</li>
<li>Integer values between -128 and 127</li>
<li>Character in the range \u0000 to \u007F (0 and 127)</li>
</ul>
<p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;				<span class="comment">// 自动装箱，底层调用 Integer.valueOf(1)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x == y);   	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);   	<span class="comment">// false，因为缓存池最大127</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);		<span class="comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure>
<h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p>
<ul>
<li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li>
<li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li>
</ul>
<p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p>
<ul>
<li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li>
<li>print：<code>PrintStream.write()</code></li>
</ul>
<blockquote>
<p>使用引用数据类型的API</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p>
<p>创建数组：</p>
<ul>
<li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li>
<li>数据类型 数组名[]：<code>int arr[]</code></li>
</ul>
<p>静态初始化：</p>
<ul>
<li>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li>
<li>数据类型[] 数组名 &#x3D; {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li>
</ul>
<p>动态初始化</p>
<ul>
<li>数据类型[] 数组名 &#x3D; new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li>
</ul>
<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul>
<li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p>
</li>
<li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p>
</li>
<li><p><strong>赋值：</strong><code>arr[0] = 10</code></p>
</li>
</ul>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>给 CPU 使用</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM 在使用操作系统功能的时候使用</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的 class 文件</td>
</tr>
<tr>
<td>堆内存</td>
<td>存储对象或者数组，new 来创建的，都存储在堆内存</td>
</tr>
<tr>
<td>方法栈</td>
<td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td>
</tr>
</tbody></table>
<p>内存分配图：<strong>Java 数组分配在堆内存</strong></p>
<ul>
<li><p>一个数组内存图</p>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
</li>
<li><p>两个数组内存图</p>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
</li>
<li><p>多个数组指向相同内存图</p>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4></li>
<li><p>索引越界异常：ArrayIndexOutOfBoundsException </p>
</li>
<li><p>空指针异常：NullPointerException </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr &#x3D; null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p>
<p>解决方案：给数组一个真正的堆内存空间引用即可</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4></li>
</ul>
<p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p>
<p>初始化：</p>
<ul>
<li><p>动态初始化：<code>数据类型[][] 变量名 = new 数据类型[m][n]</code>，<code>int[][] arr = new int[3][3]</code></p>
<ul>
<li>m 表示这个二维数组，可以存放多少个一维数组，行</li>
<li>n 表示每一个一维数组，可以存放多少个元素，列</li>
</ul>
</li>
<li><p>静态初始化:<code>数据类型[][] 变量名 = new 数据类型[m][n]&#123;&#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125;&#125; </code></p>
<ul>
<li><code>数据类型[][] 变量名 = &#123;&#123;元素1, 元素2...&#125;, &#123;元素1, 元素2...&#125;...&#125;`
  * `int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li>
</ul>
</li>
</ul>
<p>遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        步骤:</span></span><br><span class="line"><span class="comment">            1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line"><span class="comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(arr[i]);</span></span><br><span class="line">            <span class="comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line">            <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li><p>i++ 与 ++i 的区别？</p>
<p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p>
</li>
<li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p>
<p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p>
<p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p>
</li>
<li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p>
</li>
<li><p>同或：两位相同为 1，相异为 0</p>
</li>
<li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p>
</li>
<li><p>break：跳出一层循环</p>
</li>
<li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p>
<ul>
<li><p>正数的原码反码补码相同，最高位为 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>:	<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">100</span> 原码:	<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span>	<span class="comment">//32位</span></span><br><span class="line">-<span class="number">100</span> 反码:	<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011011</span></span><br><span class="line">-<span class="number">100</span> 补码:	<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011100</span></span><br></pre></td></tr></table></figure>

<p>补码 → 原码：符号位不变，其余位置取反加 1</p>
</li>
</ul>
<p>运算符：</p>
<ul>
<li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li>
<li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li>
<li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li>
</ul>
<p>运算规则：</p>
<ul>
<li><p>正数的左移与右移，空位补 0</p>
</li>
<li><p>负数原码的左移与右移，空位补 0</p>
<p>负数反码的左移与右移，空位补 1</p>
<p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p>
</li>
<li><p>无符号移位，空位补 0</p>
</li>
</ul>
</li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p>
<ul>
<li>形式参数，用于定义方法的时候使用的参数，只能是变量</li>
<li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li>
</ul>
<p>实参：调用方法时传递的数据可以是常量，也可以是变量</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p>
<p>格式：数据类型… 参数名称</p>
<p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p>
<p>可变参数的注意事项：</p>
<ul>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参列表的<strong>最后面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	sum(); <span class="comment">// 可以不传输参数。</span></span><br><span class="line">	sum(<span class="number">10</span>); <span class="comment">// 可以传输一个参数。</span></span><br><span class="line">	sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 可以传输多个参数。</span></span><br><span class="line">	sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">90</span>&#125;); <span class="comment">// 可以传输一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i : a) &#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p>
<p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p>
<p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p>
<p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p>
<h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line">	<span class="comment">//方法体;</span></span><br><span class="line">	<span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 (参数) ;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法名：调用方法时候使用的标识</li>
<li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li>
<li>方法体：完成功能的代码块</li>
<li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li>
</ul>
<p>如果方法操作完毕</p>
<ul>
<li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li>
<li>非 void 类型的方法，推荐用变量接收调用</li>
</ul>
<p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>方法不能嵌套定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p>
<ol>
<li>多个方法在<strong>同一个类</strong>中</li>
<li>多个方法具有<strong>相同的方法名</strong></li>
<li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li>
</ol>
<p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p>
<p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p>
<p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="comment">//方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line">		<span class="comment">//方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">/*正确格式*/</span></span><br><span class="line">		<span class="comment">//方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ul>
<li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li>
<li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li>
<li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li>
</ul>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>); 	<span class="comment">// 调用第二个invoke方法，选取的第二阶段</span></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span></span><br><span class="line">    </span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span></span><br><span class="line">    							   <span class="comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此不提倡可变长参数方法的重载</strong></p>
<h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p>
<ul>
<li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li>
<li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li>
</ul>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p>
<p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p>
<ul>
<li><p>基本数据类型：形式参数的改变，不影响实际参数</p>
<p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">		change(number);</span><br><span class="line">		System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">		number = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型：形式参数的改变，影响实际参数的值</p>
<p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());	<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p>
<p>定义枚举的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">	第一行都是罗列枚举实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举的特点：</p>
<ul>
<li>枚举类是用 final 修饰的，枚举类不能被继承</li>
<li>枚举类默认继承了 java.lang.Enum 枚举类</li>
<li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li>
<li>枚举类相当于是多例设计模式</li>
<li>每个枚举项都是一个实例，是一个静态成员变量</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String name()</td>
<td>获取枚举项的名称</td>
</tr>
<tr>
<td>int ordinal()</td>
<td>返回枚举项在枚举类中的索引值</td>
</tr>
<tr>
<td>int compareTo(E  o)</td>
<td>比较两个枚举项，返回的是索引值的差值</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回枚举常量的名称</td>
</tr>
<tr>
<td>static <T> T  valueOf(Class<T> type,String  name)</T></T></td>
<td>获取指定枚举类中的指定名称的枚举值</td>
</tr>
<tr>
<td>values()</td>
<td>获得所有的枚举项</td>
</tr>
</tbody></table>
<ul>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类的编译以后源代码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Season&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Season[] values();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>API 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        <span class="type">Season</span> <span class="variable">s</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(s);	<span class="comment">//SPRING</span></span><br><span class="line">        System.out.println(s.ordinal()); <span class="comment">// 0，该值代表索引，summer 就是 1</span></span><br><span class="line">        s.s.doSomething();</span><br><span class="line">        <span class="comment">// 获取全部枚举</span></span><br><span class="line">        Season[] ss = Season.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Season.SPRING.compareTo(Season.WINTER);</span><br><span class="line">        System.out.println(result);<span class="comment">//-3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p>
<p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p>
<p>面向对象三大特征：<strong>封装，继承，多态</strong></p>
<p>两个概念：类和对象</p>
<ul>
<li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li>
<li>对象：是真实存在的实例， 实例 &#x3D;&#x3D; 对象，<strong>对象是类的实例化</strong></li>
<li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li>
<li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li>
<li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分</span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line">		<span class="number">1.</span>成员变量(Field):  	描述类或者对象的属性信息的。</span><br><span class="line">        <span class="number">2.</span>成员方法(Method):		描述类或者对象的行为信息的。</span><br><span class="line">		<span class="number">3.</span>构造器(Constructor):	 初始化一个对象返回。</span><br><span class="line">		<span class="number">4.</span>代码块</span><br><span class="line">		<span class="number">5.</span>内部类</span><br><span class="line">	  &#125;</span><br><span class="line">类中有且仅有这五种成分，否则代码报错！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：初始化类的一个对象返回</p>
<p>分类：无参数构造器，有参数构造器</p>
<p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p>
<p>构造器初始化对象的格式：类名 对象名称 &#x3D; new 构造器</p>
<ul>
<li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li>
<li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li>
</ul>
<hr>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p>
<p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p>
<p>导包格式：<code>import 包名.类名</code></p>
<p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p>
<p>封装最初的目的：提高代码的安全性和复用性，组件化</p>
<p>封装的步骤：</p>
<ol>
<li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li>
<li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li>
</ol>
<p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p>
<ul>
<li>this 关键字代表了当前对象的引用</li>
<li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li>
<li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li>
<li>this 可以区分变量是访问的成员变量还是局部变量</li>
</ul>
<hr>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p>
<p>按照有无 static 修饰，成员变量和方法可以分为：</p>
<ul>
<li><p>成员变量：</p>
<ul>
<li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li>
<li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li>
</ul>
</li>
<li><p>成员方法：</p>
<ul>
<li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li>
<li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li>
</ul>
</li>
</ul>
<h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p>
<ul>
<li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p>
<ul>
<li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li>
<li>对象.静态成员变量（不推荐）</li>
</ul>
</li>
<li><p>实例成员变量：</p>
<ul>
<li>对象.实例成员变量（先创建对象）</li>
</ul>
</li>
</ul>
<p>成员方法的访问语法：</p>
<ul>
<li><p>静态方法：有 static 修饰，属于类</p>
<ul>
<li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li>
<li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li>
</ul>
</li>
<li><p>实例方法：无 static 修饰，属于对象</p>
<ul>
<li>对象.实例方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// a.类名.静态方法</span></span><br><span class="line">        Student.inAddr();</span><br><span class="line">        inAddr();</span><br><span class="line">        <span class="comment">// b.对象.实例方法</span></span><br><span class="line">        <span class="comment">// Student.eat(); // 报错了！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        sea.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>访问问题：</p>
<ul>
<li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li>
<li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li>
<li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li>
<li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li>
<li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li>
<li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li>
<li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li>
<li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p>
<ul>
<li>被继承的类称为：父类&#x2F;超类</li>
<li>继承父类的类称为：子类</li>
</ul>
<p>继承的作用：</p>
<ul>
<li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li>
<li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li>
<li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li>
</ul>
<p>继承的特点：</p>
<ol>
<li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li>
<li><strong>单继承</strong>：一个类只能继承一个直接父类</li>
<li>多层继承：一个类可以间接继承多个父类（家谱）</li>
<li>一个类可以有多个子类</li>
<li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li>
</ol>
<p>继承的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类不能继承父类的东西：</p>
<ul>
<li>子类不能继承父类的构造器，子类有自己的构造器</li>
<li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li>
<li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// c.run();</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        System.out.println(Cat.schoolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span><span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p>
<p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wmain</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();w</span><br><span class="line">        w.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类狼&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部name</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类对象的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的</span></span><br><span class="line">        System.out.println(name1); <span class="comment">// 父类的</span></span><br><span class="line">        <span class="comment">//System.out.println(name2); // 报错。子类父类都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类动物名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;父类&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p>
<p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p>
<p>方法重写的校验注解：@Override</p>
<ul>
<li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li>
<li>@Override 优势：可读性好，安全，优雅</li>
</ul>
<p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li>
</ul>
<p>继承中的隐藏问题：</p>
<ul>
<li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li>
<li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        w.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li><p>为什么子类构造器会先调用父类构造器？</p>
<ol>
<li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li>
<li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li>
<li>参考 JVM → 类加载 → 对象创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的有参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>为什么 Java 是单继承的？</strong></p>
<p>答：反证法，假如 Java 可以多继承，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> , B &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.test(); </span><br><span class="line">        <span class="comment">// 出现了类的二义性！所以Java不能多继承！！</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p>
<p>总结与拓展：</p>
<ul>
<li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li>
<li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li>
<li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li>
<li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;天蓬元帅&quot;</span>, <span class="number">1000</span> );</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;齐天大圣&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;清华大学&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Study</span> <span class="keyword">extends</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Study</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age , schoolName) ; </span><br><span class="line">       <span class="comment">// 根据参数匹配调用父类构造器</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String schoolName ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 借用兄弟构造器的功能！</span></span><br><span class="line">        <span class="built_in">this</span>(name , age , <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// .......get + set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p>
<ul>
<li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li>
<li>final 可以修饰方法，方法就不能被重写</li>
<li>final 修饰变量总规则：变量有且仅能被赋值一次</li>
</ul>
<p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p>
<p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p>
<p>final 修饰静态成员变量可以在哪些地方赋值：</p>
<ol>
<li><p>定义的时候赋值一次</p>
</li>
<li><p>可以在静态代码块中赋值一次</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">	<span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span></span><br><span class="line">        SCHOOL_NAME1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p>
<p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p>
<ol>
<li>定义的时候赋值一次</li>
<li>可以在实例代码块中赋值一次</li>
<li>可以在每个构造器中赋值一次</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在实例代码块中赋值一次。</span></span><br><span class="line">        name1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//构造器赋值一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalDemo</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalDemo</span>();</span><br><span class="line">        <span class="comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote>
<p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p>
</blockquote>
<p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p>
<p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p>
<p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;🐕跑&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p>
<ul>
<li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li>
<li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li>
</ul>
<blockquote>
<p>抽象在学术上本身意味着不能实例化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！</span></span><br><span class="line">        <span class="comment">//a.run(); // 抽象方法不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、static 与 abstract 能同时使用吗？</p>
<p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p>
<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p>
<p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作文模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoMa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaoMa.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeText</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;\t内容&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.写一个模板类：代表了作文模板。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;\t\t\t\t\t标题&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;\t开头&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;\t结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(title+<span class="string">&quot;\n&quot;</span>+start);</span><br><span class="line">        System.out.println(writeText());</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正文部分定义成抽象方法，交给子类重写！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">writeText</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p>
<p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 修饰符 interface 接口名称&#123;</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="comment">// 默认方法</span></span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">	<span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p>
</li>
<li><p>静态方法：静态方法必须有方法体</p>
</li>
<li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//默认补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p>
<ul>
<li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li>
<li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li>
<li>接口与接口继承关系：<strong>多继承</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">修饰符 interface 接口名 extend 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现多个接口的使用注意事项：</p>
<ol>
<li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p>
</li>
<li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p>
</li>
<li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p>
</li>
<li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.run();</span><br><span class="line">        s.rule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Food</span>, Person&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以直接 interface Person extend Food,</span></span><br><span class="line"><span class="comment">//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p>
<ul>
<li>默认方法（就是普通实例方法）<ul>
<li>必须用 default 修饰，默认会 public 修饰</li>
<li>必须用接口的实现类的对象来调用</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>静态方法<ul>
<li>默认会 public 修饰</li>
<li>接口的静态方法必须用接口的类名本身来调用</li>
<li>调用格式：ClassName.method()</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        m.run();</span><br><span class="line">        m.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span></span><br><span class="line">        InterfaceJDK8.inAddr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法！！</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// a.默认方法（就是之前写的普通实例方法）</span></span><br><span class="line">    <span class="comment">// 必须用接口的实现类的对象来调用。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始跑步🏃‍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.静态方法</span></span><br><span class="line">    <span class="comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们在武汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span></span><br><span class="line">    <span class="comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>可以有默认的方法实现</td>
<td>接口完全是抽象的，jdk8 以后有默认的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td>
<td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有 main 方法并且我们可以运行它</td>
<td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口可以继承一个或多个其它接口，接口不可继承类</td>
</tr>
<tr>
<td>速度</td>
<td>比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td>
<td>如果往接口中添加方法，那么必须改变实现该接口的类</td>
</tr>
</tbody></table>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p>
<p>多态的格式：</p>
<ul>
<li>父类类型范围 &gt; 子类类型范围</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口	  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure>

<p>多态的执行：</p>
<ul>
<li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li>
<li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li>
</ul>
<p>多态的使用规则：</p>
<ul>
<li>必须存在继承或者实现关系</li>
<li>必须存在父类类型的变量引用子类类型的对象</li>
<li>存在方法重写</li>
</ul>
<p>多态的优势：</p>
<ul>
<li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li>
<li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li>
</ul>
<p>多态的劣势： </p>
<ul>
<li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.run();</span><br><span class="line">        <span class="comment">//c.eat();//报错  编译看左边 需要强转</span></span><br><span class="line">        go(c);</span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Dog</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal d)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote>
<p>基本数据类型的转换：</p>
<ol>
<li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li>
<li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li>
</ol>
</blockquote>
<p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p>
<p><strong>父类引用指向子类对象</strong></p>
<ul>
<li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li>
<li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();	<span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;			<span class="comment">// 向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p>
<ul>
<li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li>
<li>强制类型转换的格式：<strong>类型 变量名称 &#x3D; (类型)(对象或者变量)</strong></li>
<li>有继承&#x2F;实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		<span class="comment">//Dog d = (Dog)a;</span></span><br><span class="line">        <span class="comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p>
<p>概念：定义在一个类里面的类就是内部类</p>
<p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p>
<p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p>
<p>静态内部类中的成分研究：</p>
<ul>
<li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li>
<li>特点与外部类是完全一样的，只是位置在别人里面</li>
<li>可以定义静态成员</li>
</ul>
<p>静态内部类的访问格式：外部类名称.内部类名称</p>
<p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称.内部类构造器</p>
<p>静态内部类的访问拓展：</p>
<ul>
<li>静态内部类中是否可以直接访问外部类的静态成员?	可以，外部类的静态成员只有一份，可以被共享<br>   静态内部类中是否可以直接访问外部类的实例成员?	不可以，外部类的成员必须用外部类对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量</span></span><br><span class="line">         System.out.println(age);</span><br><span class="line">         <span class="comment">//System.out.println(salary);报错</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p>
<p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p>
<p>实例内部类的访问格式：外部类名称.内部类名称</p>
<p>创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类构造器.new 内部构造器</p>
<ul>
<li><code>Outter.Inner in = new Outter().new Inner()</code></li>
</ul>
<p><strong>实例内部类可以访问外部类的全部成员</strong></p>
<ul>
<li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li>
<li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p>
<p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        class&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p>
<p>匿名内部类的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;</span><br><span class="line">	<span class="comment">//方法重写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 匿名内部类的特点：</p>
<ul>
<li>匿名内部类不能定义静态成员</li>
<li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li>
<li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li>
<li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);</span><br><span class="line">                <span class="comment">//System.out.println(n);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.run();</span><br><span class="line">        a.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始go~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p>
<table>
<thead>
<tr>
<th>四种修饰符访问权限</th>
<th align="center">private</th>
<th align="center">缺省</th>
<th align="center">protected</th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td>本类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>本包下的子类中</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>本包下其他类中</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>其他包下的子类中</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>其他包下的其他类中</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p>
<ul>
<li>基类的 protected 成员是包内可见的，并且对子类可见</li>
<li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态代码块特点： <ul>
<li>必须有 static 修饰，只能访问静态资源</li>
<li>会与类一起优先加载，且自动触发执行一次</li>
</ul>
</li>
<li>静态代码块作用：<ul>
<li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li>
<li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块,属于类，与类一起加载一次!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">// 在静态代码块中进行静态资源的初始化操作</span></span><br><span class="line">        schoolName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法被执行&quot;</span>);</span><br><span class="line">        System.out.println(schoolName);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块被触发执行~~~~~~~</span></span><br><span class="line"><span class="comment">main方法被执行</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">[3, 4, 5] */</span></span><br></pre></td></tr></table></figure>

<h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例代码块的特点：</p>
<ul>
<li>无 static 修饰，属于对象</li>
<li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li>
<li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li>
</ul>
</li>
<li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;代码块&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">()</span>&#123; &#125;<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeDemo</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">        System.out.println(c.name);</span><br><span class="line">        System.out.println(c.lists);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeDemo02</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p>
<p>Object 类常用方法：</p>
<ul>
<li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul>
<li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li>
<li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li>
</ul>
</li>
<li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li>
<li><code>protected Object clone()</code>：创建并返回此对象的副本</li>
</ul>
<p>只要两个对象的内容一样，就认为是相等的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span></span><br><span class="line">	<span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span></span><br><span class="line">	<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">	<span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">           sex == student.sex &amp;&amp;</span><br><span class="line">           Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong>：&#x3D;&#x3D; 和 equals 的区别</p>
<ul>
<li>&#x3D;&#x3D; 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li>
<li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li>
</ul>
<p>hashCode 的作用：</p>
<ul>
<li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li>
<li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li>
<li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li>
</ul>
<h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p>
<p>深浅拷贝（克隆）的概念：</p>
<ul>
<li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p>
<p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p>
</li>
<li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p>
</li>
</ul>
<p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p>
<ul>
<li><p>Clone &amp; Copy：<code>Student s = new Student</code></p>
<p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p>
<p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p>
</li>
<li><p>Shallow Clone &amp; Deep Clone：</p>
<p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p>
<ul>
<li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li>
<li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p>
<p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        s.date = (Date) date.clone();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>SDP → 创建型 → 原型模式</p>
<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p>
<p>Objects 的方法：</p>
<ul>
<li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line"><span class="comment">// 进行非空判断，从而可以避免空指针异常</span></span><br><span class="line"><span class="keyword">return</span> a == b || a != <span class="literal">null</span> &amp;&amp; a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* `public static boolean isNull(Object obj)`：判断变量是否为 null ，为 null 返回 true</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象)`：返回参数中对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象, 默认字符串)`：返回对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class ObjectsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = null;</span><br><span class="line">        Student s2 = new Student();</span><br><span class="line">        System.out.println(Objects.equals(s1 , s2));//推荐使用</span><br><span class="line">        // System.out.println(s1.equals(s2)); // 空指针异常</span><br><span class="line"> </span><br><span class="line">        System.out.println(Objects.isNull(s1));</span><br><span class="line">        System.out.println(s1 == null);//直接判断比较好</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> 	<span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p>
<p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p>
<ul>
<li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p>
</li>
<li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p>
</li>
<li><p><code>public int length()</code>：返回此字符串的长度</p>
</li>
<li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p>
</li>
<li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p>
</li>
<li><p><code>public char charAt(int index)</code>：取索引处的值</p>
</li>
<li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p>
</li>
<li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p>
</li>
<li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p>
</li>
<li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p>
</li>
<li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p>
</li>
<li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p>
</li>
<li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p>
</li>
<li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p>
</li>
<li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>-<span class="number">78</span>;</span><br><span class="line">s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure>

<h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p>
<ul>
<li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li>
<li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li>
<li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li>
</ul>
<p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p>
<ul>
<li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li>
<li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li>
</ul>
<p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p>
<ul>
<li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li>
<li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;"></li>
</ul>
<p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p>
<ul>
<li><p>对象 1：new StringBuilder()</p>
</li>
<li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p>
</li>
<li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p>
<img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;">
</li>
<li><p>StringBuilder 的 toString()：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象 6：new String(“ab”)</li>
<li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li>
</ul>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool &#x2F; StringTable &#x2F; 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p>
<ul>
<li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li>
<li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li>
<li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li>
<li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li>
</ul>
<h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p>
<ul>
<li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li>
<li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li>
</ul>
<p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; 	<span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;	<span class="comment">// 串池</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;	<span class="comment">// 返回的是堆内地址</span></span><br><span class="line">        <span class="comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        <span class="comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值</li>
<li>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</li>
</ul>
<p>结论：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;								<span class="comment">// 仅放入串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);	<span class="comment">// 仅放入堆</span></span><br><span class="line"><span class="comment">// 上面两条指令的结果和下面的 效果 相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2 == str2.intern());<span class="comment">//false，字符串池中存在，直接返回已经存在的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<ul>
<li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">launcher_name</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_name</span> <span class="operator">=</span> <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_profile_name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221-b11&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p>
<p>演示 StringTable 位置：</p>
<ul>
<li><p><code>-Xmx10m</code> 设置堆内存 10m</p>
</li>
<li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p>
</li>
<li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(j).intern());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p>
<h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p>
<ul>
<li><p>调整 -XX:StringTableSize&#x3D;桶个数，数量越少，性能越差</p>
</li>
<li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//很多数据</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul>
<li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li>
<li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li>
<li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li>
<li>防止子类继承，破坏 String 的 API 的使用</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p>
<ul>
<li>String : <strong>不可变</strong>的字符序列，线程安全</li>
<li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li>
<li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li>
</ul>
<p>相同点：底层使用 char[] 存储</p>
<p>构造方法：</p>
<ul>
<li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li>
<li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li>
</ul>
<p>常用API : </p>
<ul>
<li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li>
<li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li>
<li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li>
</ul>
<p>存储原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//new byte[16] </span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>append 源码：扩容为二倍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span></span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到目标字符数组中</span></span><br><span class="line">	<span class="comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p>
<p>常用API：</p>
<ul>
<li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li>
<li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li>
<li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li>
<li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//按照数字顺序排列指定的数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//1,数组必须有序</span></span><br><span class="line">        <span class="comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span></span><br><span class="line">        <span class="comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span></span><br><span class="line">            <span class="comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p>
<p>使用步骤：</p>
<ol>
<li><p>导入包：<code>import java.util.Random</code></p>
</li>
<li><p>创建对象：<code>Random r = new Random()</code></p>
</li>
<li><p>随机整数：<code>int num = r.nextInt(10)</code></p>
<ul>
<li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li>
<li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li>
</ul>
</li>
<li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p>
</li>
</ol>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p>
<p>静态方法：</p>
<ul>
<li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p>
</li>
<li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p>
</li>
<li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p>
<ul>
<li>参数一：原数组</li>
<li>参数二：从原数组的哪个位置开始赋值</li>
<li>参数三：目标数组</li>
<li>参数四：从目标数组的哪个位置开始赋值</li>
<li>参数五：赋值几个</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.exit(0); // 0代表正常终止!!</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//定义sdf 按照格式输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">		System.out.println( (endTime - startTime)/<span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);<span class="comment">//程序用时</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> ,<span class="number">60</span> ,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span></span><br><span class="line">        <span class="comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">2</span>, arr2, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p>
<ul>
<li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li>
<li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li>
</ul>
<p>时间记录的两种方式：</p>
<ol>
<li>Date 日期对象</li>
<li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s &#x3D; 1000ms</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + <span class="number">121</span>*<span class="number">1000</span>;<span class="comment">//过121s是什么时间</span></span><br><span class="line">        System.out.println(time);<span class="comment">//1602856875485</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d1);<span class="comment">//Fri Oct 16 22:01:15 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="comment">//运行一万次输出需要多长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p>
<ol>
<li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li>
<li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li>
</ol>
<p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p>
<p>SimpleDateFormat  简单日期格式化类：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li>
<li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li>
<li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li>
<li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li>
</ul>
<blockquote>
<p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);</span></span><br><span class="line"><span class="string">    String time = sdf.format(date);</span></span><br><span class="line"><span class="string">    System.out.println(time);//2020-10-18 19:58:34</span></span><br><span class="line"><span class="string">    //过121s后是什么时间</span></span><br><span class="line"><span class="string">    long time = date.getTime();</span></span><br><span class="line"><span class="string">    time+=121;</span></span><br><span class="line"><span class="string">    System.out.println(sdf.formate(time));</span></span><br><span class="line"><span class="string">    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致</span></span><br><span class="line"><span class="string">    Date newDate = sdf.parse(d);</span></span><br><span class="line"><span class="string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p>
<p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p>
<p>Calendar 的方法：</p>
<ul>
<li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li>
<li><code>public int get(int field)</code>：取日期中的某个字段信息</li>
<li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li>
<li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li>
<li><code>public final Date getTime()</code>：拿到此刻日期对象</li>
<li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInsance(); </span><br><span class="line">	<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> rightNow.get(Calendar.YEAR);<span class="comment">//获取年</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> rightNow.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月要+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    rightNow.set(Calendar.YEAR , <span class="number">2099</span>);<span class="comment">//修改某个字段</span></span><br><span class="line">    rightNow.add(Calendar.HOUR , <span class="number">15</span>);<span class="comment">//加15小时  -15就是减去15小时</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> rightNow.getTime();<span class="comment">//日历对象</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rightNow.getTimeInMillis();<span class="comment">//时间毫秒值</span></span><br><span class="line">    <span class="comment">//700天后是什么日子</span></span><br><span class="line">    rightNow.add(Calendar.DAY_OF_YEAR , <span class="number">701</span>);</span><br><span class="line">    Date <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(sdf.format(d));<span class="comment">//输出700天后的日期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p>
<ul>
<li>LocalDate       表示日期（年月日）  </li>
<li>LocalTime       表示时间（时分秒）</li>
<li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li>
</ul>
<p>构造方法：</p>
<ul>
<li>public static LocalDateTime now()：获取当前系统时间 </li>
<li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li>
</ul>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int getYear()</td>
<td>获取年</td>
</tr>
<tr>
<td>public int getMonthValue()</td>
<td>获取月份（1-12）</td>
</tr>
<tr>
<td>public int getDayOfMonth()</td>
<td>获取月份中的第几天（1-31）</td>
</tr>
<tr>
<td>public int getDayOfYear()</td>
<td>获取一年中的第几天（1-366）</td>
</tr>
<tr>
<td>public DayOfWeek getDayOfWeek()</td>
<td>获取星期</td>
</tr>
<tr>
<td>public int getMinute()</td>
<td>获取分钟</td>
</tr>
<tr>
<td>public int getHour()</td>
<td>获取小时</td>
</tr>
<tr>
<td>public LocalDate  toLocalDate()</td>
<td>转换成为一个 LocalDate 对象（年月日）</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>转换成为一个 LocalTime 对象（时分秒）</td>
</tr>
<tr>
<td>public String format(指定格式)</td>
<td>把一个 LocalDateTime 格式化成为一个字符串</td>
</tr>
<tr>
<td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td>
<td>把一个日期字符串解析成为一个 LocalDateTime 对象</td>
</tr>
<tr>
<td>public static DateTimeFormatter ofPattern(String pattern)</td>
<td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> localDateTime.format(pattern);</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(s, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public LocalDateTime plusYears (long years)</td>
<td>添加或者减去年</td>
</tr>
<tr>
<td>public LocalDateTime withYear(int year)</td>
<td>直接修改年</td>
</tr>
</tbody></table>
<p><strong>时间间隔</strong> Duration 类API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Period between(开始时间,结束时间)</td>
<td>计算两个“时间”的间隔</td>
</tr>
<tr>
<td>public int getYears()</td>
<td>获得这段时间的年数</td>
</tr>
<tr>
<td>public int getMonths()</td>
<td>获得此期间的总月数</td>
</tr>
<tr>
<td>public int getDays()</td>
<td>获得此期间的天数</td>
</tr>
<tr>
<td>public long toTotalMonths()</td>
<td>获取此期间的总月数</td>
</tr>
<tr>
<td>public static Durationbetween(开始时间,结束时间)</td>
<td>计算两个“时间”的间隔</td>
</tr>
<tr>
<td>public long toSeconds()</td>
<td>获得此时间间隔的秒</td>
</tr>
<tr>
<td>public long toMillis()</td>
<td>获得此时间间隔的毫秒</td>
</tr>
<tr>
<td>public long toNanos()</td>
<td>获得此时间间隔的纳秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate2);</span><br><span class="line">        System.out.println(period);<span class="comment">//P28Y11M11D</span></span><br><span class="line">		<span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime2);</span><br><span class="line">        System.out.println(duration);<span class="comment">//PT21H57M58S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p>
<p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>获取参数a的绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>public static double pow(double a, double b)</td>
<td>获取 a 的 b 次幂</td>
</tr>
<tr>
<td>public static long round(double a)</td>
<td>四舍五入取整</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>返回较大值</td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td>返回较小值</td>
</tr>
<tr>
<td>public static double random()</td>
<td>返回值为 double 的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数。</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">4.00000001</span>));<span class="comment">//4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">4.99999999</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">    <span class="comment">//取一位整数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//取一位整数和两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">    <span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">    <span class="comment">//取所有整数部分</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">    <span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));<span class="comment">//2.99792E8</span></span><br><span class="line">    <span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));<span class="comment">//29.9792E7</span></span><br><span class="line">    <span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));<span class="comment">//299,792,458</span></span><br><span class="line">    <span class="comment">//将格式嵌入文本</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p>
<p>构造方法：</p>
<ul>
<li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li>
<li><code>public BigDecimal(double val)</code></li>
<li><code>public BigDecimal(String val)</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li>
<li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li>
<li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li>
<li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li>
<li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li>
<li><code>public int intValue()</code>：转为 int 其他类型相同</li>
<li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span></span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b ;</span><br><span class="line">        System.out.println(c);<span class="comment">//0.30000000000000004</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把浮点数转换成大数据对象运算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//a1.divide(b1);也可以</span></span><br><span class="line">		System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>BigDecimal 是用来进行精确计算的</li>
<li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li>
<li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line"><span class="comment">//参数1：表示参与运算的BigDecimal 对象。</span></span><br><span class="line"><span class="comment">//参数2：表示小数点后面精确到多少位</span></span><br><span class="line"><span class="comment">//参数3：舍入模式  </span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_UP  进一法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_FLOOR 去尾法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure>

<h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p>
<p>比如检验 qq 号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQRegex</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq!=<span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数</span></span><br><span class="line">&#125;<span class="comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure>

<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p>Pattern 类：</p>
<p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p>
</li>
<li><p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p>
</li>
<li><p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\</td>
<td>代表 \ 本身</td>
</tr>
<tr>
<td>()</td>
<td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td>
</tr>
</tbody></table>
<h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符，0~9 中的任意一个，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符，等价于  [ ^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>对\w取非，等价于[ ^\w]</td>
</tr>
<tr>
<td>\s</td>
<td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>对 \s 取非</td>
</tr>
</tbody></table>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p>
<h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[ab5@]</td>
<td>匹配 “a” 或 “b” 或 “5” 或 “@”</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配 “a”,”b”,”c” 之外的任意一个字符</td>
</tr>
<tr>
<td>[f-k]</td>
<td>匹配 “f”~”k” 之间的任意一个字母</td>
</tr>
<tr>
<td>[^A-F0-3]</td>
<td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[m-p]]</td>
<td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td>
</tr>
<tr>
<td>[^]</td>
<td>取反</td>
</tr>
</tbody></table>
<ul>
<li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p>
</li>
<li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p>
</li>
</ul>
<h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p>
<ul>
<li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li>
<li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X 一次或一次也没，有相当于 {0,1}</td>
</tr>
<tr>
<td>X*</td>
<td>X 不出现或出现任意次，相当于 {0,}</td>
</tr>
<tr>
<td>X+</td>
<td>X 至少一次，相当于 {1,}</td>
</tr>
<tr>
<td>X{n}</td>
<td>X 恰好 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>X 至少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>X 至少 n 次，但是不超过 m 次</td>
</tr>
</tbody></table>
<h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td>
</tr>
<tr>
<td>$</td>
<td>与字符串结束的地方匹配</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界</td>
</tr>
</tbody></table>
<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p>
<ul>
<li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li>
<li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>|  (分支结构)</td>
<td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td>
</tr>
<tr>
<td>()  (捕获组)</td>
<td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td>
</tr>
<tr>
<td>(?:Expression)   非捕获组</td>
<td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td>
</tr>
</tbody></table>
<h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p>
<ul>
<li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p>
</li>
<li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p>
</li>
<li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p>
</li>
<li><p>应用 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li>
<li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li>
<li>实例：43438n44</li>
</ul>
</li>
<li><p>应用 2：爬虫</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>匹配结果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//不匹配</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p>
<ul>
<li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p>
</li>
<li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p>
</li>
<li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(?&#x3D;exp)</td>
<td>断言自身出现的位置的后面能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;&#x3D;exp)</td>
<td>断言自身出现的位置的前面能匹配表达式exp</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>断言此位置的后面不能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>断言此位置的前面不能匹配表达式exp</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p>
<ul>
<li>IGNORECASE 忽略大小写模式<ul>
<li>匹配时忽略大小写。</li>
<li>默认情况下，正则表达式是要区分大小写的。</li>
</ul>
</li>
<li>SINGLELINE 单行模式<ul>
<li>整个文本看作一个字符串，只有一个开头，一个结尾。</li>
<li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li>
</ul>
</li>
<li>MULTILINE 多行模式<ul>
<li>每行都是一个字符串，都有开头和结尾。</li>
<li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li>
</ul>
</li>
</ul>
<h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p>
<ul>
<li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li>
<li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li>
<li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li>
</ul>
<p>Matcher 类：</p>
<ul>
<li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li>
<li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li>
<li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li>
<li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//表达式对象</span></span><br><span class="line">		<span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">		<span class="comment">//创建Matcher对象</span></span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);</span><br><span class="line">		<span class="comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span></span><br><span class="line">		<span class="comment">//System.out.println(b);//false</span></span><br><span class="line">		<span class="comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line">		<span class="comment">//System.out.println(b2);//true</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(m.find());</span></span><br><span class="line">		<span class="comment">//System.out.println(m.group());//asfsdf2</span></span><br><span class="line">		<span class="comment">//System.out.println(m.find());</span></span><br><span class="line">		<span class="comment">//System.out.println(m.group());//3323</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">			System.out.println(m.group());	<span class="comment">//group(),group(0)匹配整个表达式的子字符串</span></span><br><span class="line">			System.out.println(m.group(<span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line">		<span class="comment">//表达式对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="comment">//不需要加多余的括号</span></span><br><span class="line">		<span class="comment">//创建Matcher对象</span></span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aa232**ssd445&quot;</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">			System.out.println(m.group());<span class="comment">//aa232  ssd445</span></span><br><span class="line">			System.out.println(m.group(<span class="number">1</span>));<span class="comment">//aa232  ssd445</span></span><br><span class="line">			System.out.println(m.group(<span class="number">2</span>));<span class="comment">//aa     ssd</span></span><br><span class="line">            System.out.println(m.group(<span class="number">3</span>));<span class="comment">//232    445 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li>
<li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false 判断a是否在abc之外的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false 是否a是整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true 是否是字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));<span class="comment">//false 只能检验单个字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">	System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 验证。必须是数字和字符  必须是4位</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dsd22&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;A3dy&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机号码格式正确！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;.......&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1111@qq.com  zhy@pic.com.cn</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱格式正确！&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// .是任意字符 \\.就是点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul>
<li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li>
<li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// 1.split的基础用法</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">	<span class="comment">// 以“，”分割成字符串数组</span></span><br><span class="line">    String[] nameArrs = names.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.split集合正则表达式做分割</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> <span class="string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;</span><br><span class="line">    <span class="comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span></span><br><span class="line">	String[] nameArrs1 = names1.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用正则表达式定位出内容，替换成/</span></span><br><span class="line">	System.out.println(names1.replaceAll(<span class="string">&quot;\\w+&quot;</span>,<span class="string">&quot;/&quot;</span>));<span class="comment">//风清扬/张无忌/周芷若</span></span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">	System.out.println(names3.replaceAll(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;-&quot;</span>));<span class="comment">//风清扬-张无忌-周芷若</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="/2023/03/04/Java/java-high/" target="_blank">了解更多java高级内容</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhanghm0915.github.io">zhanghm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhanghm0915.github.io/2023/03/04/Java/java/">https://zhanghm0915.github.io/2023/03/04/Java/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhanghm0915.github.io" target="_blank">zhanghm的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/03%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/04/Java/java-high/"><img class="prev-cover" src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/04-1%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java高级(全)</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"><img class="next-cover" src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/02%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhanghm</div><div class="author-info__description">我裂开了只为给老板买劳斯莱斯</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zhanghm0915"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Zhanghm0915" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2769245720&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2769245720@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SE"><span class="toc-number">1.</span> <span class="toc-text">SE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">上下转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.2.4.</span> <span class="toc-text">类型对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">装箱拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">缓存池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">输入数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">元素访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">数组异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">形参实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">方法概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">定义调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.5.4.1.</span> <span class="toc-text">重载介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%89%E5%8F%96"><span class="toc-number">1.1.5.4.2.</span> <span class="toc-text">方法选取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.5.4.3.</span> <span class="toc-text">继承重载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.6.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug"><span class="toc-number">1.1.7.</span> <span class="toc-text">Debug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.2.5.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.2.6.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">static 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.7.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">变量访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">方法访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">常见问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">1.2.8.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.2.9.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">修饰变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.9.2.1.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.9.2.2.</span> <span class="toc-text">实例变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.2.10.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%84%8F%E4%B9%89"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">存在意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.11.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.11.2.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.11.3.</span> <span class="toc-text">新增功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.2.11.4.</span> <span class="toc-text">对比抽象类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.12.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.2.12.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B-1"><span class="toc-number">1.2.12.2.</span> <span class="toc-text">上下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">1.2.12.3.</span> <span class="toc-text">instanceof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.13.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.2.13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.13.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.13.3.</span> <span class="toc-text">实例内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.13.4.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.13.5.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AC%A6"><span class="toc-number">1.2.14.</span> <span class="toc-text">权限符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.15.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.15.1.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.2.15.2.</span> <span class="toc-text">实例代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">1.3.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">1.3.1.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E5%85%8B%E9%9A%86"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">深浅克隆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Objects"><span class="toc-number">1.3.2.</span> <span class="toc-text">Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">1.3.3.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">构造方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-Pool"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">String Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">1.3.3.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#intern"><span class="toc-number">1.3.3.4.2.</span> <span class="toc-text">intern()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2"><span class="toc-number">1.3.3.4.3.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.3.4.4.</span> <span class="toc-text">内存位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">优化常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%A5%BD%E5%A4%84"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">不可变好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.3.4.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays"><span class="toc-number">1.3.5.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random"><span class="toc-number">1.3.6.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System"><span class="toc-number">1.3.7.</span> <span class="toc-text">System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">1.3.8.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateFormat"><span class="toc-number">1.3.9.</span> <span class="toc-text">DateFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar"><span class="toc-number">1.3.10.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDateTime"><span class="toc-number">1.3.11.</span> <span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">1.3.12.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DecimalFormat"><span class="toc-number">1.3.13.</span> <span class="toc-text">DecimalFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-number">1.3.14.</span> <span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Regex"><span class="toc-number">1.3.15.</span> <span class="toc-text">Regex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.15.2.</span> <span class="toc-text">字符匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.15.2.1.</span> <span class="toc-text">普通字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.15.2.2.</span> <span class="toc-text">特殊字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.15.2.3.</span> <span class="toc-text">标准字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AC%A6"><span class="toc-number">1.3.15.2.4.</span> <span class="toc-text">自定义符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.15.2.5.</span> <span class="toc-text">量词字符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.15.3.</span> <span class="toc-text">位置匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%B9%E7%95%8C"><span class="toc-number">1.3.15.3.1.</span> <span class="toc-text">字符边界</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="toc-number">1.3.15.3.2.</span> <span class="toc-text">捕获组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.15.3.3.</span> <span class="toc-text">反向引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80"><span class="toc-number">1.3.15.3.4.</span> <span class="toc-text">零宽断言</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.15.4.</span> <span class="toc-text">匹配模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.15.5.</span> <span class="toc-text">分组匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.15.6.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.15.6.1.</span> <span class="toc-text">基本验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8F%B7%E7%A0%81"><span class="toc-number">1.3.15.6.2.</span> <span class="toc-text">验证号码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.15.6.3.</span> <span class="toc-text">查找替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8F%B7%E7%A0%81"><span class="toc-number">1.3.15.6.4.</span> <span class="toc-text">搜索号码</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/myleetcode/myleetcode/" title="我的leetcode刷题记录"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/003731-16221334517645.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的leetcode刷题记录"/></a><div class="content"><a class="title" href="/2023/03/29/myleetcode/myleetcode/" title="我的leetcode刷题记录">我的leetcode刷题记录</a><time datetime="2023-03-29T08:49:03.000Z" title="发表于 2023-03-29 16:49:03">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/28/juc/juc-h/" title="juc-JMM"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/223619-16762989795a96.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="juc-JMM"/></a><div class="content"><a class="title" href="/2023/03/28/juc/juc-h/" title="juc-JMM">juc-JMM</a><time datetime="2023-03-28T10:42:06.000Z" title="发表于 2023-03-28 18:42:06">2023-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/juc/juc/" title="juc"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230327104551.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="juc"/></a><div class="content"><a class="title" href="/2023/03/27/juc/juc/" title="juc">juc</a><time datetime="2023-03-27T03:02:48.000Z" title="发表于 2023-03-27 11:02:48">2023-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/design-pattern/singleton-design-pattern/" title="设计模式-单例&amp;代理设计模式"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/00680bX5gy1g6xrlzvfagj30u01hc7wh.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-单例&amp;代理设计模式"/></a><div class="content"><a class="title" href="/2023/03/26/design-pattern/singleton-design-pattern/" title="设计模式-单例&amp;代理设计模式">设计模式-单例&amp;代理设计模式</a><time datetime="2023-03-26T07:13:12.000Z" title="发表于 2023-03-26 15:13:12">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/xml-basic/xml-basic/" title="xml基础介绍"><img src="/img/loading.gif" data-original="https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/%E5%9C%B0%E9%9D%A2%E5%B0%8F%E5%88%86%E9%98%9F%E6%82%AC%E7%96%91%E6%B5%B7%E6%8A%A5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xml基础介绍"/></a><div class="content"><a class="title" href="/2023/03/26/xml-basic/xml-basic/" title="xml基础介绍">xml基础介绍</a><time datetime="2023-03-26T07:05:48.000Z" title="发表于 2023-03-26 15:05:48">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://zhm-blog-oss.oss-cn-beijing.aliyuncs.com/pic/03%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B81920x1080.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zhanghm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>