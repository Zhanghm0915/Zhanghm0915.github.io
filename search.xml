<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的leetcode刷题记录</title>
      <link href="/2023/03/29/myleetcode/myleetcode/"/>
      <url>/2023/03/29/myleetcode/myleetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="①-二分查找"><a href="#①-二分查找" class="headerlink" title="① 二分查找"></a>① 二分查找</h2><h3 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h3><ol><li>有序数组</li><li>无重复元素(有重复元素时的返回值不唯一，需要深思)</li></ol><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li><p>左闭右开</p><blockquote><p>区间【left,right),对应代码：while(left &lt; right)<br>  右指针没意义，即right &#x3D; nums.length</p></blockquote></li><li><p>左闭右闭</p><blockquote><p>区间【left,right】,对应代码：while(left &lt;&#x3D; right)<br>  右指针有意义，即right &#x3D; nums.length - 1;</p></blockquote></li></ul><h3 id="题目1：二分查找（力扣704）"><a href="#题目1：二分查找（力扣704）" class="headerlink" title="题目1：二分查找（力扣704）"></a><font color="red">题目1：二分查找（力扣704）</font></h3><p>给定一个 n 个元素<strong>有序</strong>的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1 </p><p>提示：</p><p>你可以假设 nums 中的<strong>所有元素是不重复的</strong>。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p><p><a href="https://leetcode.cn/problems/binary-search">题目地址</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>暴力法(次)<br>直接遍历数组，判断是否等于target,等于就返回当前索引值，否则继续。</li><li>二分法<br>由题目知该数组的元素为有序且无重复的，适合二分法。<br>① 首先选择数组中间的数字和需要查找的目标值比较<br>② 如果相等最好，就可以直接返回答案了<br>③ 如果不相等<ul><li>如果中间的数字大于目标值，则中间数字向右的所有数字都大于目标值，全部排除</li><li>如果中间的数字小于目标值，则中间数字向左的所有数字都小于目标值，全部排除</li></ul></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [-1,0,3,5,9,12], target = 8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;      <span class="comment">//指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;      <span class="comment">//中间值的索引</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;                 <span class="comment">//目标值大于中间值,则中间值左边的值去掉，即左指针右移</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;           <span class="comment">//目标值小于中间值，则去除右边的值，即右指针左移</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;                         <span class="comment">//相等，返回索引值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                  <span class="comment">//目标值不在数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题目2-搜索插入位置（力扣35）"><a href="#题目2-搜索插入位置（力扣35）" class="headerlink" title="题目2:搜索插入位置（力扣35）"></a><font color="red">题目2:搜索插入位置（力扣35）</font></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4 </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 为 无重复元素 的 升序 排列数组<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p><a href="https://leetcode.cn/problems/search-insert-position">题目地址</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目中<strong>排序数组</strong>，适合用二分法<br>分析情况：</p><ol><li>目标值在数组里，且是数组中的元素<ul><li>套模板就能够找到目标值</li></ul></li><li>目标值在数组范围内，但不是数组中的元素<ul><li>思考：在终止条件时，即右指针right在左指针的前面，会发现右指针对应的值总是小于目标值，左指针的对应的值总是大于目标值，因此在right+1处即为插入的位置。</li></ul></li><li>目标值在数组范围两边，即小于数组的第一个或大于最后一个元素。<ul><li>同上面思考一样，右指针总是在左指针的左边，插入位置依然为right+1;</li></ul></li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;     <span class="comment">//情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;       <span class="comment">//其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"><a href="#题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）" class="headerlink" title="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"></a><font color="red">题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）</font></h3><p>给定一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ </p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>nums 是一个非递减数组<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">题目地址</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>分析:</p><ol><li>非递减顺序的数组即<strong>升序但可以有重复元素的数组</strong></li><li>情况①：target 在数组范围的右边或者左边，返回[-1,-1]</li><li>情况②：target 在数组范围中，且数组中不存在target，返回[-1,-1]</li><li>情况③：target 在数组范围中，且数组中存在target</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> searchLeftBorder(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> searchRightBorder(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == -<span class="number">2</span> || rightBorder == -<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchLeftBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchRightBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：x的平方根（力扣69）"><a href="#题目4：x的平方根（力扣69）" class="headerlink" title="题目4：x的平方根（力扣69）"></a><font color="red">题目4：x的平方根（力扣69）</font></h3><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p> </p><p>示例 1：</p><p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p><p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 </p><p>提示：</p><p>0 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/sqrtx/">题目地址</a></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>暴力法<br>直接从0开始遍历，当该平方的数小于等于x的值时，记录当前的值。否则跳出循环。</li><li>二分法<br>使用二分法，左指针为0，右指针为x值。当中间值的平方小于等于x的值时，记录中间值，此时需要往后移动指针判断下一个值是否满足条件。注意：中间值平方过后可能造成溢出，需要强转为long类型的数据进行判断</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ol><li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= x/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)i*i &lt;= x)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( (<span class="type">long</span>)mid*mid &lt;= x)&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题目5：有效的完全平方数（力扣367）"><a href="#题目5：有效的完全平方数（力扣367）" class="headerlink" title="题目5：有效的完全平方数（力扣367）"></a><font color="red">题目5：有效的完全平方数（力扣367）</font></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p><p> </p><p>示例 1：</p><p>输入：num &#x3D; 16<br>输出：true<br>示例 2：</p><p>输入：num &#x3D; 14<br>输出：false </p><p>提示：</p><p>1 &lt;&#x3D; num &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/valid-perfect-square">题目地址</a></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>与题目4思路是一致的，这里仅写二分法的代码</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid*mid == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid*mid &lt; num)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：山脉数组的峰顶索引（力扣852）"><a href="#题目6：山脉数组的峰顶索引（力扣852）" class="headerlink" title="题目6：山脉数组的峰顶索引（力扣852）"></a><font color="red">题目6：山脉数组的峰顶索引（力扣852）</font></h3><p>符合下列属性的数组 arr 称为 山脉数组 ：<br>arr.length &gt;&#x3D; 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p><p> </p><p>示例 1：</p><p>输入：arr &#x3D; [0,1,0]<br>输出：1<br>示例 2：</p><p>输入：arr &#x3D; [0,2,1,0]<br>输出：1<br>示例 3：</p><p>输入：arr &#x3D; [0,10,5,2]<br>输出：1<br>示例 4：</p><p>输入：arr &#x3D; [3,4,5,1]<br>输出：2<br>示例 5：</p><p>输入：arr &#x3D; [24,69,100,99,79,78,67,36,26,19]<br>输出：2 </p><p>提示：</p><p>3 &lt;&#x3D; arr.length &lt;&#x3D; 10^4<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10^6<br>题目数据保证 arr 是一个山脉数组 </p><p>进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？</p><p><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array">题目地址</a></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>分析题目：<br>使用二分法解决该问题，可知满足的条件为中间索引对应的值大于前一个索引对应的值同时大于后一个索引对应的值</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="number">1</span>])&#123;         <span class="comment">//当前值小于前面的值而大于后面的值，峰顶在左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid+<span class="number">1</span>])&#123;   <span class="comment">//当前值大于前面值而小于后面值，峰顶在右边</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//比前、后值都大,即为峰顶</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//无意义，本题中必定能找到峰顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：寻找比目标字母大的最小字母（力扣744）"><a href="#题目7：寻找比目标字母大的最小字母（力扣744）" class="headerlink" title="题目7：寻找比目标字母大的最小字母（力扣744）"></a><font color="red">题目7：寻找比目标字母大的最小字母（力扣744）</font></h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p><p>在比较时，字母是依序循环出现的。举个例子：</p><p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’ </p><p>示例 1：</p><p>输入: letters &#x3D; [“c”, “f”, “j”]，target &#x3D; “a”<br>输出: “c”<br>示例 2:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “c”<br>输出: “f”<br>示例 3:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “d”<br>输出: “f” </p><p>提示：</p><p>2 &lt;&#x3D; letters.length &lt;&#x3D; 104<br>letters[i] 是一个小写字母<br>letters 按非递减顺序排序<br>letters 最少包含两个不同的字母<br>target 是一个小写字母</p><p><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target">题目地址</a></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><pre><code>分析：        情况①：目标值在列表左边或者在列表的右边（可以等于最右的那个值），返回letters[0];        情况②：目标值在列表里，可以不等于列表的值。        思考：用二分法时，在终止条件是，左指针指向的值总是大于目标值，右指针指向的值总是小于目标值。利用该特性与本题结合，可知返回值为letters[left]</code></pre><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//情况①</span></span><br><span class="line">        <span class="keyword">if</span>(letters[<span class="number">0</span>] &gt; target || letters[letters.length-<span class="number">1</span>] &lt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况②</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> letters.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②移除元素之双指针法"><a href="#②移除元素之双指针法" class="headerlink" title="②移除元素之双指针法"></a>②移除元素之双指针法</h2><h3 id="题目1：移除元素（力扣27）"><a href="#题目1：移除元素（力扣27）" class="headerlink" title="题目1：移除元素（力扣27）"></a><font color="red">题目1：移除元素（力扣27）</font></h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p> </p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);</p><p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>} </p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/remove-element">题目地址</a></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>须知：在数组内“移除”元素只能是覆盖。<br>移除所有等于val的元素，相当于用不等于val的元素去覆盖等于val的元素。<br>本题中使用双指针法，快指针fast指向不等于val的值就覆盖前一个值，慢指针指向的就是前一个值。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;      <span class="comment">//快指针指向的值不等于val</span></span><br><span class="line">                nums[slow] = nums[fast];    <span class="comment">//覆盖</span></span><br><span class="line">                slow++;                     <span class="comment">//慢指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;                        <span class="comment">//此时慢指针的值就是不等于val的数组新长度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：删除有序数组中的重复项（力扣26）"><a href="#题目2：删除有序数组中的重复项（力扣26）" class="headerlink" title="题目2：删除有序数组中的重复项（力扣26）"></a><font color="red">题目2：删除有序数组中的重复项（力扣26）</font></h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p><p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p><p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 升序 排列</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">题目地址</a></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>无</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：移动零（力扣283）"><a href="#题目3：移动零（力扣283）" class="headerlink" title="题目3：移动零（力扣283）"></a><font color="red">题目3：移动零（力扣283）</font></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums &#x3D; [0]<br>输出: [0] </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/move-zeroes">题目地址</a></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>无</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,slow,fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> slow,<span class="type">int</span> fast)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：比较含退格的字符串（力扣844）"><a href="#题目4：比较含退格的字符串（力扣844）" class="headerlink" title="题目4：比较含退格的字符串（力扣844）"></a><font color="red">题目4：比较含退格的字符串（力扣844）</font></h3><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>示例 1：</p><p>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。<br>示例 2：</p><p>输入：s &#x3D; “ab##”, t &#x3D; “c#d#”<br>输出：true<br>解释：s 和 t 都会变成 “”。<br>示例 3：</p><p>输入：s &#x3D; “a#c”, t &#x3D; “b”<br>输出：false<br>解释：s 会变成 “c”，但 t 仍然是 “b”。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 200<br>s 和 t 只含有小写字母以及字符 ‘#’ </p><p>进阶：</p><p>你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？</p><p><a href="https://leetcode.cn/problems/backspace-string-compare">题目地址</a></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>没理清</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipS</span> <span class="operator">=</span> <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先找到 s 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS ++;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS --;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再找到 t 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT --;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后开始比较,注意有下面这个 if 条件的原因是：如果 index = 0 位置上为 &#x27;#&#x27;，则 i, j 会为 -1</span></span><br><span class="line">            <span class="comment">// 而 index = -1 的情况应当处理。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果待比较字符不同，return false</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (i &gt;= 0 &amp;&amp; j &gt;= 0) 为 false 情况为</span></span><br><span class="line">            <span class="comment">// 1. i &lt; 0 &amp;&amp; j &gt;= 0</span></span><br><span class="line">            <span class="comment">// 2. j &lt; 0 &amp;&amp; i &gt;= 0</span></span><br><span class="line">            <span class="comment">// 3. i &lt; 0 &amp;&amp; j &lt; 0</span></span><br><span class="line">            <span class="comment">// 其中，第 3 种情况为符合题意情况，因为这种情况下 s 和 t 都是 index = 0 的位置为 &#x27;#&#x27; 而这种情况下</span></span><br><span class="line">            <span class="comment">// 退格空字符即为空字符，也符合题意，应当返回 True。</span></span><br><span class="line">            <span class="comment">// 但是，情况 1 和 2 不符合题意，因为 s 和 t 其中一个是在 index &gt;= 0 处找到了待比较字符，另一个没有找到</span></span><br><span class="line">            <span class="comment">// 这种情况显然不符合题意，应当返回 False，下式便处理这种情况。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：有序数组的平方（力扣977）"><a href="#题目5：有序数组的平方（力扣977）" class="headerlink" title="题目5：有序数组的平方（力扣977）"></a><font color="red">题目5：有序数组的平方（力扣977）</font></h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p><p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 非递减顺序 排序 </p><p>进阶：</p><p>请你设计时间复杂度为 O(n) 的算法解决本问题</p><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array">题目地址</a></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>题目中的数组是非递减顺序排序，可知数值平方后的最大值是在左右两边产生的。<br>需要双指针分别指向左，右。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                res[index] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：验证回文串（力扣125）"><a href="#题目6：验证回文串（力扣125）" class="headerlink" title="题目6：验证回文串（力扣125）"></a><font color="red">题目6：验证回文串（力扣125）</font></h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入: s &#x3D; “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p><p>输入：s &#x3D; “race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p><p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 10^5<br>s 仅由可打印的 ASCII 字符组成</p><p><a href="https://leetcode.cn/problems/valid-palindrome">题目地址</a></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[i]) &amp;&amp; i&lt;j)&#123;   <span class="comment">//非数字字母</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[j]) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c[i] != c[j])&#123;       <span class="comment">//数字字母，判断是否相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是小写字母或数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③子数组、子串之滑动窗口"><a href="#③子数组、子串之滑动窗口" class="headerlink" title="③子数组、子串之滑动窗口"></a>③子数组、子串之滑动窗口</h2><h3 id="题目1：长度最小的子数组（力扣209）"><a href="#题目1：长度最小的子数组（力扣209）" class="headerlink" title="题目1：长度最小的子数组（力扣209）"></a><font color="red">题目1：长度最小的子数组（力扣209）</font></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p> </p><p>示例 1：</p><p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0 </p><p>提示：</p><p>1 &lt;&#x3D; target &lt;&#x3D; 10^9<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum">题目地址</a></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];             <span class="comment">//求和</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;      <span class="comment">//计算满足条件的数组子长度</span></span><br><span class="line">                res = res &lt; subLength ? res : subLength;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若res为整型的最大值，说明数组的所有数加起来都比target小，返回0；</span></span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：水果成篮（力扣904）"><a href="#题目2：水果成篮（力扣904）" class="headerlink" title="题目2：水果成篮（力扣904）"></a><font color="red">题目2：水果成篮（力扣904）</font></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p> </p><p>示例 1：</p><p>输入：fruits &#x3D; [1,2,1]<br>输出：3<br>解释：可以采摘全部 3 棵树。<br>示例 2：</p><p>输入：fruits &#x3D; [0,1,2,2]<br>输出：3<br>解释：可以采摘 [1,2,2] 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。<br>示例 3：</p><p>输入：fruits &#x3D; [1,2,3,2,2]<br>输出：4<br>解释：可以采摘 [2,3,2,2] 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。<br>示例 4：</p><p>输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：可以采摘 [1,2,1,1,2] 这五棵树。</p><p><a href="https://leetcode.cn/problems/fruit-into-baskets">题目地址</a></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>题目分析：<br>    从某一棵树开始采摘，且必须连续采摘而不多于2种类型（值相同为同类型）的果树。如fruits &#x3D; [1,2,3,2,2]，若从1开始采摘，则只能采摘到2，因为3与前面的都不是同一类型的果树。从2开始的话，能够采摘到2,3,2,2。题目中需要返回的是子数组的最大长度。<br>思考：<br>    如果从头遍历数组，在遍历到该元素时，也就从该元素开始采摘。如何记录果树的类型不大于2 ??<br>    解决完果树类型不大于2时，同时记录子数组的长度，再返回即可。</p><p>现需要记录当前遍历的左右果树，分别用ln表示左果树类型、rn表示右果树类型。同时左（慢）指针，右（快）指针开始寻找能够装下篮子（果树类型）的水果，若右指针指向的果树类型与ln或者rn相同，记下此时能够装下的最大长度，右指针继续移动。若右指针指向的果树类型不同于ln、rn，即当前有3中类型的果树，因此需要左指针右移到右指针的前一个位置（不能是left++,参考示例4），再更新左、右果树类型。由于开始时左、右果树类型都是一样，此时需要进行判断，因为左指针移到右指针的前一个位置，但可能出现与左果树类型相同的情况。记录长度，返回即可。</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = <span class="number">0</span>;                  <span class="comment">//左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;                            <span class="comment">//记录长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> fruits[left],rn = fruits[right];   <span class="comment">//篮子一号和二号（左、右果树类型，此时果树类型相同）</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right] == rn || fruits[right] == ln)&#123;<span class="comment">//属于篮子某个种类</span></span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);  <span class="comment">//更新结果，每次取一个数就更新一下</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果遇到第三种，把慢指针移动到快指针前一步，该步的水果种类必然不同于快指针，此时慢指针慢慢回退齐所有的连续同类。</span></span><br><span class="line">                left = right - <span class="number">1</span>;  <span class="comment">//取到第三种则移动左标到right -1</span></span><br><span class="line">                ln = fruits[left]; <span class="comment">//更新第一个篮子</span></span><br><span class="line">                <span class="keyword">while</span>(left &gt;= <span class="number">1</span> &amp;&amp; fruits[left - <span class="number">1</span>] == ln) &#123;    <span class="comment">//左果树更新后回退至相同种类的开始位置</span></span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                rn = fruits[right];</span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="题目1：移除链表元素（力扣203）"><a href="#题目1：移除链表元素（力扣203）" class="headerlink" title="题目1：移除链表元素（力扣203）"></a><font color="red">题目1：移除链表元素（力扣203）</font></h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]</p><p>示例 2：</p><p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[] </p><p>提示：</p><p>列表中的节点数目在范围 [0, 10^4] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p><p><a href="https://leetcode.cn/problems/remove-linked-list-elements">题目地址</a></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);    <span class="comment">//虚拟结点：仅仅是串起整条链，统一操作链表</span></span><br><span class="line">        node.next = head;                   <span class="comment">//虚拟结点指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;                <span class="comment">//当前结点指向虚拟结点（node）</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val )&#123;</span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">//删除等于val的结点并后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;                  <span class="comment">//后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：设计链表（力扣707）"><a href="#题目2：设计链表（力扣707）" class="headerlink" title="题目2：设计链表（力扣707）"></a><font color="red">题目2：设计链表（力扣707）</font></h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 </p><p>示例：</p><p>MyLinkedList linkedList &#x3D; new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回2<br>linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回3 </p><p>提示：</p><p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p><p><a href="https://leetcode.cn/problems/design-linked-list">题目地址</a></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode dummy;     <span class="comment">//虚拟头结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;     <span class="comment">//初始化</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123; <span class="comment">//超出索引位置</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; index;i++)&#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);   <span class="comment">//添加</span></span><br><span class="line">        add.next = pre.next;</span><br><span class="line">        pre.next = add;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next,prev;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;            <span class="comment">//从head开始</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;                                  <span class="comment">//从tail开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123; </span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;   </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：反转链表（力扣206）"><a href="#题目3：反转链表（力扣206）" class="headerlink" title="题目3：反转链表（力扣206）"></a><font color="red">题目3：反转链表（力扣206）</font></h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[] </p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000 </p><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p><a href="https://leetcode.cn/problems/reverse-linked-list">题目地址</a></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针、迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;    </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//保存下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;<span class="comment">// 先保存下一个节点</span></span><br><span class="line">        cur.next = prev;<span class="comment">// 反转</span></span><br><span class="line">        <span class="comment">// 更新prev、cur位置</span></span><br><span class="line">        <span class="comment">// prev = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力，构建新链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> head; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x.val,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：两两交换链表中的节点（力扣24）"><a href="#题目4：两两交换链表中的节点（力扣24）" class="headerlink" title="题目4：两两交换链表中的节点（力扣24）"></a><font color="red">题目4：两两交换链表中的节点（力扣24）</font></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p><p>输入：head &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [1]<br>输出：[1] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs">题目地址</a></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑：</span></span><br><span class="line"><span class="comment">// 保存第二个节点，第一个节点指向第二层的返回值，再两两交换。</span></span><br><span class="line"><span class="comment">// 例子：1-&gt;2-&gt;3-&gt;4 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一层：  </span></span><br><span class="line"><span class="comment">// 定义指针-&gt;2    1-&gt;??(第二层返回值)                    1-&gt;4-&gt;3</span></span><br><span class="line"><span class="comment">//                                                     当前层又进行交互：</span></span><br><span class="line"><span class="comment">//                                                     2-&gt;1-&gt;4-&gt;3,返回定义的指针，即新的head</span></span><br><span class="line">    ||</span><br><span class="line">    \/</span><br><span class="line"><span class="comment">// 进入第二层：</span></span><br><span class="line">    ||</span><br><span class="line">    \/                                                      /\</span><br><span class="line">                                                            ||</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">// 定义指针指向-&gt;4</span></span><br><span class="line"><span class="comment">// 3-&gt;??(进入第三层)                                    交换：4-&gt;3,返回</span></span><br><span class="line">                                                            /\</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">//     --&gt;                  ----&gt;                       第三层为空，返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//假设链表是 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//这句就先保存节点2</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="comment">//继续递归，处理节点3-&gt;4</span></span><br><span class="line"><span class="comment">//当递归结束返回后，就变成了4-&gt;3</span></span><br><span class="line"><span class="comment">//于是head节点就指向了4，变成1-&gt;4-&gt;3</span></span><br><span class="line">head.next = swapPairs(tmp.next);</span><br><span class="line"><span class="comment">//将2节点指向1</span></span><br><span class="line">tmp.next = head;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：删除链表的倒数第N个结点（力扣19）"><a href="#题目5：删除链表的倒数第N个结点（力扣19）" class="headerlink" title="题目5：删除链表的倒数第N个结点（力扣19）"></a><font color="red">题目5：删除链表的倒数第N个结点（力扣19）</font></h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]<br> <br>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">题目地址</a></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：计算链表长度，找到要删除的前一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);           <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; length -n +<span class="number">1</span>;i++)&#123;    <span class="comment">//要删除的前一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = cur.next.next;           <span class="comment">//删除倒数第n的节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法二：前后双指针（你走一步，我走一步）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;       <span class="comment">//first指针比second指针多n步</span></span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">null</span>)&#123;           <span class="comment">//你一步我一步，结束时second在要删除节点的前一个节点</span></span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;     <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法三：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFormEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;   <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = removeNthFormEnd(head.next,n);</span><br><span class="line">        cur++;          <span class="comment">//递归返回时都会执行，即寻找要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(n == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;       <span class="comment">//直接抛弃要删除的节点，返回下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：面试题02-07-链表相交-lt-力扣同题160-gt"><a href="#题目6：面试题02-07-链表相交-lt-力扣同题160-gt" class="headerlink" title="题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;"></a><font color="red">题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;</font></h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p> </p><p>示例 1：</p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br> <br>提示：</p><p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 10^4<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA + 1] &#x3D;&#x3D; listB[skipB + 1] </p><p>进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">题目地址</a></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>思考：两链表长度不一，如何进行遍历？<br>可以计算出两链表的长度，进行差值，即有一个链表先移动（差值）步，再开始比较。分别用两指针指向当前该判断的位置。判断是否指针相等，若相等，则返回当前指针。若不等，则同时移动两个指针到下一个位置。</p><h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;    <span class="comment">//计算headA的长度</span></span><br><span class="line">            lengthA++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;      <span class="comment">//计算headB的长度</span></span><br><span class="line">            lengthB++;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;          <span class="comment">//判断长度的差值，使得指针在不同链表中的同一步</span></span><br><span class="line">            lengthA = lengthA - lengthB;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     <span class="comment">//指针先移动lengthA步</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lengthA = lengthB - lengthA;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     </span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;            <span class="comment">//判断当前指针是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;           <span class="comment">//相等</span></span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;                    <span class="comment">//不相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：环形链表-lt-力扣142-gt"><a href="#题目7：环形链表-lt-力扣142-gt" class="headerlink" title="题目7：环形链表||&lt;力扣142&gt;"></a><font color="red">题目7：环形链表||&lt;力扣142&gt;</font></h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。<br> <br>提示：</p><p>链表中节点的数目范围在范围 [0, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>pos 的值为 -1 或者链表中的一个有效索引 </p><p>进阶：你是否可以使用 O(1) 空间解决此题？</p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii">题目地址</a></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.add(a);</span><br><span class="line">            a = a.next;</span><br><span class="line">            <span class="keyword">while</span>(temp.contains(a))&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="题目1：有效的字母异位词（力扣242）"><a href="#题目1：有效的字母异位词（力扣242）" class="headerlink" title="题目1：有效的字母异位词（力扣242）"></a><font color="red">题目1：有效的字母异位词（力扣242）</font></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true</p><p>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false<br> <br>提示:</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 10^4<br>s 和 t 仅包含小写字母 </p><p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p><a href="https://leetcode.cn/problems/valid-anagram">题目地址</a></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通哈希,不符合unicode字符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : record)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">var</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//进阶哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(ch) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：两个数组的交集（力扣349）"><a href="#题目2：两个数组的交集（力扣349）" class="headerlink" title="题目2：两个数组的交集（力扣349）"></a><font color="red">题目2：两个数组的交集（力扣349）</font></h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p><p>示例 2：</p><p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的<br> <br>提示：</p><p>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays">题目地址</a></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums1)&#123;</span><br><span class="line">            set.add(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(<span class="keyword">var</span>))&#123;</span><br><span class="line">                res.add(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] str = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : res)&#123;</span><br><span class="line">            str[i++] = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">// return res.stream().mapToInt(x -&gt; x).toArray();  //流操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：快乐数（力扣202）"><a href="#题目3：快乐数（力扣202）" class="headerlink" title="题目3：快乐数（力扣202）"></a><font color="red">题目3：快乐数（力扣202）</font></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><p>示例 1：</p><p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 2<br>输出：false<br> <br>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/happy-number">题目地址</a></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;  <span class="comment">//前一个条件用于循环，后一个条件用于判断不重复</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;          <span class="comment">//计算当前数的每一个位数的平方和，用total保存</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n;</span><br><span class="line">                temp = temp%<span class="number">10</span>;</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">                total += temp * temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total == <span class="number">1</span>)&#123;         <span class="comment">//位数的平方和为1，符号条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = total;          <span class="comment">//赋值重新进入循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：两数之和（力扣1）"><a href="#题目4：两数之和（力扣1）" class="headerlink" title="题目4：两数之和（力扣1）"></a><font color="red">题目4：两数之和（力扣1）</font></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p><p>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1] </p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-109 &lt;&#x3D; target &lt;&#x3D; 10^9<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？</p><p><a href="https://leetcode.cn/problems/two-sum">题目地址</a></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;Integer,Integer&gt; set = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     int n = target - nums[i];</span></span><br><span class="line">        <span class="comment">//     if(set.containsKey(n))&#123;</span></span><br><span class="line">        <span class="comment">//         return new int[]&#123;set.get(n),i&#125;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     set.put(nums[i],i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return new int[0];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：四数相加-（力扣454）"><a href="#题目5：四数相加-（力扣454）" class="headerlink" title="题目5：四数相加||（力扣454）"></a><font color="red">题目5：四数相加||（力扣454）</font></h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<br> <br>示例 1：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p><ol><li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ol><p>示例 2：</p><p>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1 </p><p>提示：</p><p>n &#x3D;&#x3D; nums1.length<br>n &#x3D;&#x3D; nums2.length<br>n &#x3D;&#x3D; nums3.length<br>n &#x3D;&#x3D; nums4.length<br>1 &lt;&#x3D; n &lt;&#x3D; 200<br>-2^28 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 2^28</p><p><a href="https://leetcode.cn/problems/4sum-ii">题目地址</a></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：赎金信（力扣383）"><a href="#题目6：赎金信（力扣383）" class="headerlink" title="题目6：赎金信（力扣383）"></a><font color="red">题目6：赎金信（力扣383）</font></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p>示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p><p>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p><p>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true<br> <br>提示：<br>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 10^5<br>ransomNote 和 magazine 由小写英文字母组成</p><p><a href="https://leetcode.cn/problems/ransom-note">题目地址</a></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> magazine.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.put(c,map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ransomNote.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(c,map.get(c)-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">============================================================</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote,String magazine)</span>&#123;</span><br><span class="line">        <span class="comment">//记录杂志字符串出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            temp = magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            arr[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            temp = ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//对于金信中的每一个字符都在数组中查找</span></span><br><span class="line">            <span class="comment">//找到相应位减一，否则找不到返回false</span></span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：三数之和（力扣15）"><a href="#题目7：三数之和（力扣15）" class="headerlink" title="题目7：三数之和（力扣15）"></a><font color="red">题目7：三数之和（力扣15）</font></h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p><p>示例 2：</p><p>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。</p><p>示例 3：</p><p>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。 </p><p>提示：</p><p>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/3sum">题目地址</a></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>大概懂</p><h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums); <span class="comment">// O(nlogn)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; <span class="comment">// O(n^2)</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 第一个数大于 0，后面的数都比它大，肯定不成立了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去掉重复情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                    ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    left++; right--; <span class="comment">// 首先无论如何先要进行加减操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// nums[left] + nums[right] &gt; target</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目8：四数之和（力扣18）"><a href="#题目8：四数之和（力扣18）" class="headerlink" title="题目8：四数之和（力扣18）"></a><font color="red">题目8：四数之和（力扣18）</font></h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p><p><a href="https://leetcode.cn/problems/4sum">题目地址</a></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= nums.length -<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;  <span class="comment">//排序后的数组第一个正数都比target大。</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt;= nums.length -<span class="number">3</span>;j++)&#123;      <span class="comment">//第二个指针j</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j];            <span class="comment">//前2个指针的数值之和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;                       <span class="comment">//第三个指针</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;             <span class="comment">//第四个指针</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> temp + nums[left] + nums[right]; </span><br><span class="line">                    <span class="keyword">if</span>(total &gt; target)&#123;         <span class="comment">//目标值小</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(total &lt; target)&#123;   <span class="comment">//目标值大</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//相等</span></span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i],nums[j],nums[left],nums[right])));</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;   <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; </span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;  <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++; <span class="comment">//继续看其他情况是否符合</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="题目1：反转字符串（力扣344）"><a href="#题目1：反转字符串（力扣344）" class="headerlink" title="题目1：反转字符串（力扣344）"></a><font color="red">题目1：反转字符串（力扣344）</font></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”] </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5<br>s[i] 都是 ASCII 码表中的可打印字符</p><p><a href="https://leetcode.cn/problems/reverse-string">题目地址</a></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">                s[right] ^= s[left];</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="comment">//其他精简写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span> - i;</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">            s[j] ^= s[i];</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">        &#125;</span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：反转字符串-（力扣541）"><a href="#题目2：反转字符串-（力扣541）" class="headerlink" title="题目2：反转字符串||（力扣541）"></a><font color="red">题目2：反转字符串||（力扣541）</font></h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br> <br>示例 1：</p><p>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：</p><p>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由小写英文组成<br>1 &lt;&#x3D; k &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/reverse-string-ii">题目地址</a></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>题目理解：每隔2k个反转前k个，尾数不够k个时候全部反转</p><h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);<span class="comment">//字符串长度可能小于k，则尾指针使用总长度-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：剑指Offer-05-替换空格（力扣？？？）"><a href="#题目3：剑指Offer-05-替换空格（力扣？？？）" class="headerlink" title="题目3：剑指Offer 05.替换空格（力扣？？？）"></a><font color="red">题目3：剑指Offer 05.替换空格（力扣？？？）</font></h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”<br> <br>限制：</p><p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">题目地址</a></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">        <span class="comment">//if (&quot; &quot;.equals(String.valueOf(str.charAt(i))))&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：反转字符串中的单词（力扣151）"><a href="#题目4：反转字符串中的单词（力扣151）" class="headerlink" title="题目4：反转字符串中的单词（力扣151）"></a><font color="red">题目4：反转字符串中的单词（力扣151）</font></h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p>示例 1：</p><p>输入：s &#x3D; “the sky is blue”<br>输出：”blue is sky the”</p><p>示例 2：</p><p>输入：s &#x3D; “  hello world  “<br>输出：”world hello”<br>解释：反转后的字符串中不能存在前导空格和尾随空格。</p><p>示例 3：</p><p>输入：s &#x3D; “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 包含英文大小写字母、数字和空格 ‘ ‘<br>s 中 至少存在一个 单词</p><p>进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。</p><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string">题目地址</a></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();                           <span class="comment">//去除前后空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;               <span class="comment">//单词的尾指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;                        <span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span>)&#123;                      <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;                     <span class="comment">//当start为0时，直接加</span></span><br><span class="line">                sb.append(s,start,end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != <span class="string">&#x27; &#x27;</span>)&#123;         <span class="comment">//当前字符不为&#x27; &#x27;,头指针找单词的头</span></span><br><span class="line">                start--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// sb.append(s.substring(start + 1 , end+1)).append(&#x27; &#x27;);</span></span><br><span class="line">                sb.append(s,start + <span class="number">1</span>,end + <span class="number">1</span>).append(<span class="string">&#x27; &#x27;</span>);     <span class="comment">//当前字符为&#x27; &#x27;,start指针此时在单词头的前一个索引位置，添加到sb中。</span></span><br><span class="line">                end = start - <span class="number">1</span>;                                <span class="comment">//移动尾指针</span></span><br><span class="line">                <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;                   <span class="comment">//两单词之间多空格的情况，找尾指针不为空字符的时候，即尾指针指向第二个单词的尾部</span></span><br><span class="line">                    end--;                                      </span><br><span class="line">                &#125;</span><br><span class="line">                start = end;                                    <span class="comment">//头指针与尾指针都指向第二个单词的尾部，重复如此</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：剑指Offer-58-左旋转字符串（力扣？？？）"><a href="#题目5：剑指Offer-58-左旋转字符串（力扣？？？）" class="headerlink" title="题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）"></a><font color="red">题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）</font></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p><p>示例 2：</p><p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”<br> <br>限制：</p><p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">题目地址</a></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">// sb.append(s,n,s.length());</span></span><br><span class="line">        <span class="comment">// sb.append(s,0,n);</span></span><br><span class="line">        <span class="comment">// return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：找出字符串中第一个匹配的下标（力扣28）"><a href="#题目6：找出字符串中第一个匹配的下标（力扣28）" class="headerlink" title="题目6：找出字符串中第一个匹配的下标（力扣28）"></a><font color="red">题目6：找出字符串中第一个匹配的下标（力扣28）</font></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>示例 1：</p><p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p><p>示例 2：</p><p>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。</p><p>提示：</p><p>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 10^4<br>haystack 和 needle 仅由小写英文字符组成</p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">题目地址</a></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>未理清kmp</p><h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="type">char</span>[] s = haystack.toCharArray(), p = needle.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举原串的「发起点」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从原串的「发起点」和匹配串的「首位」开始，尝试匹配</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; m &amp;&amp; s[a] == p[b]) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果能够完全匹配，返回原串的「发起点」下标</span></span><br><span class="line">            <span class="keyword">if</span> (b == m) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack,String needle)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;        <span class="comment">//构造next数组（pi）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;          <span class="comment">//匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：重复的子字符串（力扣459）"><a href="#题目7：重复的子字符串（力扣459）" class="headerlink" title="题目7：重复的子字符串（力扣459）"></a><font color="red">题目7：重复的子字符串（力扣459）</font></h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p>示例 1:</p><p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p><p>输入: s &#x3D; “aba”<br>输出: false<br>示例 3:</p><p>输入: s &#x3D; “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)<br> <br>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 由小写英文字母组成</p><p><a href="https://leetcode.cn/problems/repeated-substring-pattern">题目地址</a></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= m/<span class="number">2</span>;i++)&#123;        <span class="comment">//能够由子字符串构成的字符串，子字符串的长度必定是字符串长度的一半以内</span></span><br><span class="line">            <span class="keyword">if</span>(m % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ;j &lt; m; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="题目1：用栈实现队列-力扣232"><a href="#题目1：用栈实现队列-力扣232" class="headerlink" title="题目1：用栈实现队列(力扣232)"></a><font color="red">题目1：用栈实现队列(力扣232)</font></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>示例 1：</p><p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p><p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false<br> <br>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用 100 次 push、pop、peek 和 empty<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）<br> <br>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks">题目地址</a></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>根据队列FIFO的特性，用两个栈(LIFO特性)模拟。栈1负责元素进栈，栈2负责接收栈1的元素，并做出栈等操作。</p><h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//用栈模拟队列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;  <span class="comment">//栈1(元素进栈)</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;  <span class="comment">//栈2(栈1的元素出栈，该栈负责元素出栈及获取栈顶元素)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();       <span class="comment">//将栈1的元素弹出并进栈2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队空?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty()&amp;&amp;stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈1元素出栈到栈2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outStack1_AndInStack2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：用队列实现栈-力扣225"><a href="#题目2：用队列实现栈-力扣225" class="headerlink" title="题目2：用队列实现栈(力扣225)"></a><font color="red">题目2：用队列实现栈(力扣225)</font></h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br> <br>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False<br> <br>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空<br> <br>进阶：你能否仅用一个队列来实现栈。</p><p><a href="https://leetcode.cn/problems/implement-stack-using-queues">题目地址</a></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><p>根据栈的特性LIFO，以及队列的特性FIFO,使用两个队列实现栈。首先队列1负责元素进出队，队列2负责临时存储元素。在元素进入队列1时，为达到LIFO的特性，用上临时存储队列2，先将队列2中所有的元素全部进队到队列1中，再交换队列，即交换存储空间（队列交换）达到队列1始终为空.</p><h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; a;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        a.offer(x);             <span class="comment">//元素进入队列1</span></span><br><span class="line">        <span class="keyword">while</span>(!b.isEmpty())&#123;    <span class="comment">//将队列2中的所有元素入队1</span></span><br><span class="line">            a.offer(b.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换保证a始终为空</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//一个队列实现栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：有效的括号-力扣20"><a href="#题目3：有效的括号-力扣20" class="headerlink" title="题目3：有效的括号(力扣20)"></a><font color="red">题目3：有效的括号(力扣20)</font></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true</p><p>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true</p><p>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由括号 ‘()[]{}’ 组成</p><p><a href="https://leetcode.cn/problems/valid-parentheses">题目地址</a></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h4><p>该题不是那种穿插的括号，直接进行判断即可</p><h4 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;[&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">//哈希快速匹配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//右括号为键，左括号为值</span></span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;    <span class="comment">//右括号进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != map.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">//左括号直接进栈</span></span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈为空，即全部匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：删除字符串中的所有相邻重复项-力扣1047"><a href="#题目4：删除字符串中的所有相邻重复项-力扣1047" class="headerlink" title="题目4：删除字符串中的所有相邻重复项(力扣1047)"></a><font color="red">题目4：删除字符串中的所有相邻重复项(力扣1047)</font></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br> <br>提示：<br>1 &lt;&#x3D; S.length &lt;&#x3D; 20000<br>S 仅由小写英文字母组成。</p><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">题目地址</a></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈思想实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">0</span> &amp;&amp; stack.charAt(top) == ch) &#123;</span><br><span class="line">                stack.deleteCharAt(top);</span><br><span class="line">                --top;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.append(ch);</span><br><span class="line">                ++top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================================================</span><br><span class="line"><span class="comment">//数组实现（还是栈的思想）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;   <span class="comment">//栈顶指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == -<span class="number">1</span> || ch[top] != ch[i]) &#123;    <span class="comment">//当前元素与栈顶元素不一致就进栈</span></span><br><span class="line">                ch[++top] = ch[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top--;      <span class="comment">//删除栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch, <span class="number">0</span>, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：逆波兰表达式求值-力扣150"><a href="#题目5：逆波兰表达式求值-力扣150" class="headerlink" title="题目5：逆波兰表达式求值(力扣150)"></a><font color="red">题目5：逆波兰表达式求值(力扣150)</font></h3><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p><p>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</p><p>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22 </p><p>提示：</p><p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 10^4<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">题目地址</a></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h4><p>是数字就进栈，是运算符则出栈2个数进行操作后再进栈。</p><h4 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String item : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>) || item.equals(<span class="string">&quot;-&quot;</span>) || item.equals(<span class="string">&quot;*&quot;</span>) || item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1+num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2-num1);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1*num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(item));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span></span><br><span class="line">                stack.push(stack.pop() + stack.pop());      <span class="comment">// 注意 - 和/ 需要特殊处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：滑动窗口最大值-力扣239"><a href="#题目6：滑动窗口最大值-力扣239" class="headerlink" title="题目6：滑动窗口最大值(力扣239)"></a><font color="red">题目6：滑动窗口最大值(力扣239)</font></h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                  最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><p>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]<br> <br>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p><a href="https://leetcode.cn/problems/sliding-window-maximum">题目地址</a></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h4><p>难啊</p><h4 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加元素时，如果要添加的元素大于队尾处的元素，就将队尾元素弹出（保证对首元素始终大于队尾元素）</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 如果队首存储的角标就是滑动窗口左边界数值，就移除队首（保证窗口大小为k）</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; (i - k) == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当i增长到第一个窗口右边界时，每滑动一步都将队首角标对应元素(窗口最大值)放入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：前K个高频元素-力扣347"><a href="#题目7：前K个高频元素-力扣347" class="headerlink" title="题目7：前K个高频元素(力扣347)"></a><font color="red">题目7：前K个高频元素(力扣347)</font></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的<br> <br>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements">题目地址</a></p><h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h4><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><h4 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    解法<span class="number">1</span>：基于大顶堆实现</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//大顶堆需要对所有元素进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//依次从队头弹出k个,就是出现频率前k高的元素</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//解法2：基于小顶堆实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;<span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();<span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="题目1：二叉树的前序遍历-力扣144"><a href="#题目1：二叉树的前序遍历-力扣144" class="headerlink" title="题目1：二叉树的前序遍历(力扣144)"></a><font color="red">题目1：二叉树的前序遍历(力扣144)</font></h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>示例 4：</p><p>输入：root &#x3D; [1,2]<br>输出：[1,2]</p><p>示例 5：</p><p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]<br> <br>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">题目地址</a></p><h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pre(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        pre(root.left,list);</span><br><span class="line">        pre(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//官方迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="comment">//morris算法(二叉搜索树)</span></span><br><span class="line"><span class="comment">//实现原则</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.如果cur无左孩子，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">    2.如果cur有左孩子，找到cur左子树上最右的节点，记为mostright</span></span><br><span class="line"><span class="comment">        1.如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</span></span><br><span class="line"><span class="comment">        2.如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur表示当前节点，mostRight表示cur的左孩子的最右节点</span></span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// cur有左孩子，找到cur左子树最右节点</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// mostRight的右孩子指向空，让其指向cur，cur向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// mostRight的右孩子指向cur，让其指向空，cur向右移动</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.print(cur.value + &quot; &quot;);</span></span><br><span class="line">                res.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">//二叉树的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node root; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        createTree(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        List &lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//新建一个list集合，将数据变为各个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> temp : data) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        root=list.get(<span class="number">0</span>);<span class="comment">//将第一个元素设置为根节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用构建完全二叉树的方式构建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(( i*<span class="number">2</span> + <span class="number">1</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setLeft(list.get(i*<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i*<span class="number">2</span>+<span class="number">2</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setRight(list.get(i*<span class="number">2</span>+<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="comment">// 得到根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value,Node left,Node right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(Node left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：二叉树的中序遍历-力扣94"><a href="#题目2：二叉树的中序遍历-力扣94" class="headerlink" title="题目2：二叉树的中序遍历(力扣94)"></a><font color="red">题目2：二叉树的中序遍历(力扣94)</font></h3><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">题目地址</a></p><h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：二叉树的后序遍历-力扣145"><a href="#题目3：二叉树的后序遍历-力扣145" class="headerlink" title="题目3：二叉树的后序遍历(力扣145)"></a><font color="red">题目3：二叉树的后序遍历(力扣145)</font></h3><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]<br> <br>提示：</p><p>树中节点的数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">题目地址</a></p><h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postorder(root.left,list);</span><br><span class="line">        postorder(root.right,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：二叉树的层序遍历-力扣102"><a href="#题目4：二叉树的层序遍历-力扣102" class="headerlink" title="题目4：二叉树的层序遍历(力扣102)"></a><font color="red">题目4：二叉树的层序遍历(力扣102)</font></h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">题目地址</a></p><h4 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS（breadth first search：广度优先算法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();   <span class="comment">//存放结果集</span></span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//存放结点的队列</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;  </span><br><span class="line">        que.offerLast(root);            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();                   </span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.right);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：二叉树的层序遍历-力扣107"><a href="#题目5：二叉树的层序遍历-力扣107" class="headerlink" title="题目5：二叉树的层序遍历||(力扣107)"></a><font color="red">题目5：二叉树的层序遍历||(力扣107)</font></h3><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii">题目地址</a></p><h4 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每一层的结点数量</span></span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//存放第i层数组的值，i从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,ret);         <span class="comment">//往结果集中的第0个位置存放，使得遍历完每一层的结果都在最前面，达到从下往上遍历的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：二叉树的右视图-力扣199"><a href="#题目6：二叉树的右视图-力扣199" class="headerlink" title="题目6：二叉树的右视图(力扣199)"></a><font color="red">题目6：二叉树的右视图(力扣199)</font></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p><p>示例 2:</p><p>输入: [1,null,3]<br>输出: [1,3]</p><p>示例 3:</p><p>输入: []<br>输出: []<br> <br>提示:</p><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view">题目地址</a></p><h4 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，取最后一个节点的值即可</p><h4 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();   <span class="comment">//同一层的结点数量</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：二叉树的层平均值-力扣637"><a href="#题目7：二叉树的层平均值-力扣637" class="headerlink" title="题目7：二叉树的层平均值(力扣637)"></a><font color="red">题目7：二叉树的层平均值(力扣637)</font></h3><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。</p><p>示例 2:</p><p>输入：root &#x3D; [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p><p>提示：</p><p>树中节点数量在 [1, 10^4] 范围内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">题目地址</a></p><h4 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，遍历一层就计算出每一层的平均值。</p><h4 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> len;        <span class="comment">//每层节点数量</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;     <span class="comment">//层序遍历每一层，得到每一层的总值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(sum/count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目8：N叉树的层序遍历-力扣637"><a href="#题目8：N叉树的层序遍历-力扣637" class="headerlink" title="题目8：N叉树的层序遍历(力扣637)"></a><font color="red">题目8：N叉树的层序遍历(力扣637)</font></h3><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p><p>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]<br> <br>提示：</p><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal">题目地址</a></p><h4 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">for</span>(Node ch : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Iterator&lt;Node&gt; iter = node.children.iterator();</span></span><br><span class="line">                <span class="comment">// while(iter.hasNext())&#123;</span></span><br><span class="line">                <span class="comment">//     que.offer(iter.next());</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目9：在每个树中找最大值-力扣515"><a href="#题目9：在每个树中找最大值-力扣515" class="headerlink" title="题目9：在每个树中找最大值(力扣515)"></a><font color="red">题目9：在每个树中找最大值(力扣515)</font></h3><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p><p>示例2：</p><p>输入: root &#x3D; [1,2,3]<br>输出: [1,3]</p><p>提示：</p><p>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row">题目地址</a></p><h4 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h4><p>层序遍历</p><h4 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                max = node.val &gt; max ? node.val : max;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目10：填充每个节点的下一个右侧节点指针-力扣116"><a href="#题目10：填充每个节点的下一个右侧节点指针-力扣116" class="headerlink" title="题目10：填充每个节点的下一个右侧节点指针(力扣116)"></a><font color="red">题目10：填充每个节点的下一个右侧节点指针(力扣116)</font></h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3,4,5,6,7]</p><p>输出：[1,#,2,3,#,4,5,6,7,#]</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p><p>示例 2:</p><p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p><p>树中节点的数量在 [0, 2^12 - 1] 范围内</p><p>-1000 &lt;&#x3D; node.val &lt;&#x3D; 1000<br> <br>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node">题目地址</a></p><h4 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//先前出队的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//当前出队的节点</span></span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每层的节点数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;             </span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();       </span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;      <span class="comment">//非最右侧节点指向先前出队的节点</span></span><br><span class="line">                    cur.next = pre;     </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;      <span class="comment">//每层的节点遵循从右往左入队</span></span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目11：填充每个节点的下一个右侧节点指针-力扣117"><a href="#题目11：填充每个节点的下一个右侧节点指针-力扣117" class="headerlink" title="题目11：填充每个节点的下一个右侧节点指针||(力扣117)"></a><font color="red">题目11：填充每个节点的下一个右侧节点指针||(力扣117)</font></h3><p>给定一个二叉树</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 </p><p>示例：</p><p>输入：root &#x3D; [1,2,3,4,5,null,7]</p><p>输出：[1,#,2,3,#,4,5,7,#]</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。 </p><p>提示：</p><p>树中的节点数小于 6000<br>-100 &lt;&#x3D; node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">题目地址</a></p><h4 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;</span><br><span class="line">                    cur.next = pre;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目12：二叉树的最大深度-力扣104"><a href="#题目12：二叉树的最大深度-力扣104" class="headerlink" title="题目12：二叉树的最大深度(力扣104)"></a><font color="red">题目12：二叉树的最大深度(力扣104)</font></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>返回它的最大深度 3 。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">题目地址</a></p><h4 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS(深度优先搜索)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="comment">//BFS(广度优先遍历)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125; </span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目13：二叉树的最小深度-力扣111"><a href="#题目13：二叉树的最小深度-力扣111" class="headerlink" title="题目13：二叉树的最小深度(力扣111)"></a><font color="red">题目13：二叉树的最小深度(力扣111)</font></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p><p>示例 2：</p><p>输入：root &#x3D; [2,null,3,null,4,null,5,null,6]<br>输出：5<br> <br>提示：</p><p>树中节点数的范围在 [0, 10^5] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree">题目地址</a></p><h4 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;  <span class="comment">//该层的节点若没有左右节点即为最小的深度</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目14：翻转二叉树-力扣226"><a href="#题目14：翻转二叉树-力扣226" class="headerlink" title="题目14：翻转二叉树(力扣226)"></a><font color="red">题目14：翻转二叉树(力扣226)</font></h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>示例 2：</p><p>输入：root &#x3D; [2,1,3]<br>输出：[2,3,1]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目范围在 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/invert-binary-tree">题目地址</a></p><h4 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//前序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(rightTree);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//后序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.right = leftNode;</span><br><span class="line">        root.left = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//层序</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = rightNode;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目15：对称二叉树-力扣101"><a href="#题目15：对称二叉树-力扣101" class="headerlink" title="题目15：对称二叉树(力扣101)"></a><font color="red">题目15：对称二叉树(力扣101)</font></h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p><p><a href="https://leetcode.cn/problems/symmetric-tree">题目地址</a></p><h4 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode leftNode,TreeNode rightNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(leftNode.left,rightNode.right) &amp;&amp; check(leftNode.right,rightNode.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        que.offer(root.left);</span><br><span class="line">        que.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.offer(leftNode.left);</span><br><span class="line">            que.offer(rightNode.right);</span><br><span class="line"></span><br><span class="line">            que.offer(leftNode.right);</span><br><span class="line">            que.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目16：相同的树-力扣100"><a href="#题目16：相同的树-力扣100" class="headerlink" title="题目16：相同的树(力扣100)"></a><font color="red">题目16：相同的树(力扣100)</font></h3><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><p>输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]<br>输出：true</p><p>示例 2：</p><p>输入：p &#x3D; [1,2], q &#x3D; [1,null,2]<br>输出：false</p><p>示例 3：</p><p>输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]<br>输出：false<br> <br>提示：</p><p>两棵树上的节点数目都在范围 [0, 100] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/same-tree">题目地址</a></p><h4 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> check(p.left,q.left) &amp;&amp; check(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(p);</span><br><span class="line">        que.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            que.offer(node1.left);</span><br><span class="line">            que.offer(node2.left);</span><br><span class="line"></span><br><span class="line">            que.offer(node1.right);</span><br><span class="line">            que.offer(node2.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目17：另一棵树的子树-力扣572"><a href="#题目17：另一棵树的子树-力扣572" class="headerlink" title="题目17：另一棵树的子树(力扣572)"></a><font color="red">题目17：另一棵树的子树(力扣572)</font></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p>示例 1：</p><p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [3,4,5,1,2,null,null,null,null,0], subRoot &#x3D; [4,1,2]<br>输出：false<br> <br>提示：</p><p>root 树上的节点数量范围是 [1, 2000]<br>subRoot 树上的节点数量范围是 [1, 1000]<br>-10^4 &lt;&#x3D; root.val &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; subRoot.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/subtree-of-another-tree">题目地址</a></p><h4 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//树的子树的结果</span></span><br><span class="line">    <span class="comment">//1.树相同</span></span><br><span class="line">    <span class="comment">//2.是该树的左子树的子树</span></span><br><span class="line">    <span class="comment">//3.是该树的右子树的子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//1.树相同</span></span><br><span class="line">        <span class="keyword">if</span>(isSameTree(root,subRoot))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子树</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || subRoot == <span class="literal">null</span> || root.val != subRoot.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(root.left,subRoot.left) &amp;&amp; isSameTree(root.right,subRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目18：N叉树的最大深度-力扣559"><a href="#题目18：N叉树的最大深度-力扣559" class="headerlink" title="题目18：N叉树的最大深度(力扣559)"></a><font color="red">题目18：N叉树的最大深度(力扣559)</font></h3><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：3</p><p>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：5</p><p>提示：</p><p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 10^4] 之间。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree">题目地址</a></p><h4 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            depth = Math.max(depth,maxDepth(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node n : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; </span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目19：完全二叉树的节点个数-力扣222"><a href="#题目19：完全二叉树的节点个数-力扣222" class="headerlink" title="题目19：完全二叉树的节点个数(力扣222)"></a><font color="red">题目19：完全二叉树的节点个数(力扣222)</font></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：0</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：1<br> <br>提示：</p><p>树中节点的数目范围是[0, 5 * 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 1^04<br>题目数据保证输入的树是 完全二叉树</p><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes">题目地址</a></p><h4 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目20：完全二叉树的节点个数-力扣222"><a href="#题目20：完全二叉树的节点个数-力扣222" class="headerlink" title="题目20：完全二叉树的节点个数(力扣222)"></a><font color="red">题目20：完全二叉树的节点个数(力扣222)</font></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：true<br> <br>提示：</p><p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/balanced-binary-tree">题目地址</a></p><h4 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目21：二叉树的所有路径-力扣257"><a href="#题目21：二叉树的所有路径-力扣257" class="headerlink" title="题目21：二叉树的所有路径(力扣257)"></a><font color="red">题目21：二叉树的所有路径(力扣257)</font></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><p>叶子节点 是指没有子节点的节点。<br> <br>示例 1：</p><p>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[“1”]</p><p>提示：</p><p>树中节点的数目在范围 [1, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/binary-tree-paths">题目地址</a></p><h4 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,StringBuffer s,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        s.append(root.val); <span class="comment">//根值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;    <span class="comment">//叶子节点</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res);</span><br><span class="line">        dfs(root.right,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目22：左子树之和-力扣404"><a href="#题目22：左子树之和-力扣404" class="headerlink" title="题目22：左子树之和(力扣404)"></a><font color="red">题目22：左子树之和(力扣404)</font></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><p>示例 1：</p><p>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p>示例 2:</p><p>输入: root &#x3D; [1]<br>输出: 0</p><p>提示:</p><p>节点数在 [1, 1000] 范围内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/sum-of-left-leaves">题目地址</a></p><h4 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;    <span class="comment">//当前遍历的左节点不为null时，且是叶子节点</span></span><br><span class="line">            res += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目23：找树左下角的值-力扣513"><a href="#题目23：找树左下角的值-力扣513" class="headerlink" title="题目23：找树左下角的值(力扣513)"></a><font color="red">题目23：找树左下角的值(力扣513)</font></h3><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例 1:</p><p>输入: root &#x3D; [2,1,3]<br>输出: 1</p><p>示例 2:</p><p>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7<br> <br>提示:</p><p>二叉树的节点个数的范围是 [1,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 </p><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value">题目地址</a></p><h4 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            root = que.poll();</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目24：前中、中后构造二叉树-力扣xxx-不会"><a href="#题目24：前中、中后构造二叉树-力扣xxx-不会" class="headerlink" title="题目24：前中、中后构造二叉树(力扣xxx)不会"></a><font color="red">题目24：前中、中后构造二叉树(力扣xxx)不会</font></h3><h3 id="题目26：最大二叉树-力扣654"><a href="#题目26：最大二叉树-力扣654" class="headerlink" title="题目26：最大二叉树(力扣654)"></a><font color="red">题目26：最大二叉树(力扣654)</font></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p><ul><li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul><li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul><li>空数组，无子节点。</li><li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul><li>空数组，无子节点。</li><li>只有一个元素，所以子节点是一个值为 1 的节点。</li></ul></li></ul></li><li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul><li>只有一个元素，所以子节点是一个值为 0 的节点。</li><li>空数组，无子节点。</li></ul></li></ul></li></ul><p>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[3,null,2,null,1]<br> <br>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums 中的所有整数 互不相同</p><p><a href="https://leetcode.cn/problems/maximum-binary-tree">题目地址</a></p><h4 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>;i &lt;= end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[index]);</span><br><span class="line">        node.left = construct(nums, start, index - <span class="number">1</span>);</span><br><span class="line">        node.right = construct(nums, index + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目27：合并二叉树-力扣617"><a href="#题目27：合并二叉树-力扣617" class="headerlink" title="题目27：合并二叉树(力扣617)"></a><font color="red">题目27：合并二叉树(力扣617)</font></h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><p>示例 1：</p><p>输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p><p>示例 2：</p><p>输入：root1 &#x3D; [1], root2 &#x3D; [1,2]<br>输出：[2,2]<br> <br>提示：</p><p>两棵树中的节点数目在范围 [0, 2000] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees">题目地址</a></p><h4 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目28：二叉搜索树的搜索-力扣700"><a href="#题目28：二叉搜索树的搜索-力扣700" class="headerlink" title="题目28：二叉搜索树的搜索(力扣700)"></a><font color="red">题目28：二叉搜索树的搜索(力扣700)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><p>示例 1:</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2<br>输出：[2,1,3]</p><p>示例 2:</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[]<br> <br>提示：</p><p>数中节点数在 [1, 5000] 范围内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^7<br>root 是二叉搜索树<br>1 &lt;&#x3D; val &lt;&#x3D; 10^7</p><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree">题目地址</a></p><h4 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> searchBST(val &lt; root.val ? root.left : root.right, val); <span class="comment">//根据二叉搜索树的性质，根的值比左边大，比右边小。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目29：验证二叉搜索树-力扣98"><a href="#题目29：验证二叉搜索树-力扣98" class="headerlink" title="题目29：验证二叉搜索树(力扣98)"></a><font color="red">题目29：验证二叉搜索树(力扣98)</font></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<br> <br>提示：</p><p>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/validate-binary-search-tree">题目地址</a></p><h4 id="思路-70"><a href="#思路-70" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左子树小于当前根节点，右子树大于当前根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(TreeNode root,<span class="type">long</span> min,<span class="type">long</span> max)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> validBST(root.left,min,root.val) &amp;&amp; validBST(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目30：二叉搜索树的最小绝对差-力扣530或783"><a href="#题目30：二叉搜索树的最小绝对差-力扣530或783" class="headerlink" title="题目30：二叉搜索树的最小绝对差(力扣530或783)"></a><font color="red">题目30：二叉搜索树的最小绝对差(力扣530或783)</font></h3><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,6,1,3]<br>输出：1</p><p>示例 2：</p><p>输入：root &#x3D; [1,0,48,null,null,12,49]<br>输出：1<br> <br>提示：</p><p>树中节点的数目范围是 [2, 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">题目地址</a></p><h4 id="思路-71"><a href="#思路-71" class="headerlink" title="思路"></a>思路</h4><p>利用二叉搜索树的性质（左子树小于根，根小于右），当转成数组时，二叉搜索树（中序遍历）就是一个升序的数组，<strong>即BST的中序遍历就是遍历一个有序数组</strong>，利用这个可以解决本题。</p><h4 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目31：二叉搜索树中的众数-力扣501"><a href="#题目31：二叉搜索树中的众数-力扣501" class="headerlink" title="题目31：二叉搜索树中的众数(力扣501)"></a><font color="red">题目31：二叉搜索树中的众数(力扣501)</font></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树<br> <br>示例 1：</p><p>输入：root &#x3D; [1,null,2,2]<br>输出：[2]</p><p>示例 2：</p><p>输入：root &#x3D; [0]<br>输出：[0]<br> <br>提示：</p><p>树中节点的数目在范围 [1, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree">题目地址</a></p><h4 id="思路-72"><a href="#思路-72" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curent</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最大的重复数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="comment">//把集合list转化为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        inOrderTraversal(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是对当前节点的一些逻辑操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeValue</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">if</span> (nodeValue == curent) &#123;</span><br><span class="line">            <span class="comment">//如果节点值等于curent，count就加1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，就表示遇到了一个新的值，curent和count都要</span></span><br><span class="line">            <span class="comment">//重新赋值</span></span><br><span class="line">            curent = nodeValue;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            <span class="comment">//如果count == maxCount，就把当前节点加入到集合中</span></span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//否则，当前节点的值重复量是最多的，直接把list清空，然后</span></span><br><span class="line">            <span class="comment">//把当前节点的值加入到集合中</span></span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历右子树</span></span><br><span class="line">        inOrderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目32：二叉树的最近公共祖先-力扣236"><a href="#题目32：二叉树的最近公共祖先-力扣236" class="headerlink" title="题目32：二叉树的最近公共祖先(力扣236)"></a><font color="red">题目32：二叉树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><p>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p><p>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1<br> <br>提示：</p><p>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">题目地址</a></p><h4 id="思路-73"><a href="#思路-73" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="comment">//当遍历到叶结点后就会返回null</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;<span class="comment">//当找到p或者q的是时候就会返回pq</span></span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外</span></span><br><span class="line"><span class="comment">                     一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);<span class="comment">//返回的结点进行保存，可能是null</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);<span class="comment">//也可能是pq，还可能是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;<span class="comment">//否则我们返回已经找到的那个值（存储在left，与right中），p或者q</span></span><br><span class="line">            <span class="keyword">return</span> left;<span class="comment">//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目33：二叉搜索树的最近公共祖先-力扣236"><a href="#题目33：二叉搜索树的最近公共祖先-力扣236" class="headerlink" title="题目33：二叉搜索树的最近公共祖先(力扣236)"></a><font color="red">题目33：二叉搜索树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><p>示例 2:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">题目地址</a></p><h4 id="思路-74"><a href="#思路-74" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目34：二叉搜索树的插入操作-力扣701"><a href="#题目34：二叉搜索树的插入操作-力扣701" class="headerlink" title="题目34：二叉搜索树的插入操作(力扣701)"></a><font color="red">题目34：二叉搜索树的插入操作(力扣701)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p><p>示例 2：</p><p>输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25<br>输出：[40,20,60,10,30,50,70,null,null,25]</p><p>示例 3：</p><p>输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br> <br>提示：</p><p>树中的节点数将在 [0, 10^4]的范围内。<br>-10^8 &lt;&#x3D; Node.val &lt;&#x3D; 10^8<br>所有值 Node.val 是 独一无二 的。<br>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8<br>保证 val 在原始BST中不存在。</p><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree">题目地址</a></p><h4 id="思路-75"><a href="#思路-75" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目35：刪除二叉搜索树的节点-力扣450"><a href="#题目35：刪除二叉搜索树的节点-力扣450" class="headerlink" title="题目35：刪除二叉搜索树的节点(力扣450)"></a><font color="red">题目35：刪除二叉搜索树的节点(力扣450)</font></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p><p>示例 1:</p><p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p><p>示例 2:</p><p>输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点</p><p>示例 3:</p><p>输入: root &#x3D; [], key &#x3D; 0<br>输出: []</p><p>提示:</p><p>节点数的范围 [0, 10^4].<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>节点值唯一<br>root 是合法的二叉搜索树<br>-10^5 &lt;&#x3D; key &lt;&#x3D; 10^5</p><p>进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h4 id="思路-76"><a href="#思路-76" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 去右子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val)    </span><br><span class="line">            root.left = deleteNode(root.left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;  <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>)   <span class="keyword">return</span> root.right;      <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>)  <span class="keyword">return</span> root.left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.left!=<span class="literal">null</span> &amp;&amp; root.right !=<span class="literal">null</span>)&#123;  <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;   </span><br><span class="line">                <span class="keyword">while</span> (node.left != <span class="literal">null</span>)      <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                    node = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = root.left;     <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">                root = root.right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目36：修剪二叉搜索树-力扣669"><a href="#题目36：修剪二叉搜索树-力扣669" class="headerlink" title="题目36：修剪二叉搜索树(力扣669)"></a><font color="red">题目36：修剪二叉搜索树(力扣669)</font></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p>示例 1：</p><p>输入：root &#x3D; [1,0,2], low &#x3D; 1, high &#x3D; 2<br>输出：[1,null,2]</p><p>示例 2：</p><p>输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3<br>输出：[3,2,null,1]</p><p>提示：</p><p>树中节点数在范围 [1, 10^4] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^4<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 10^4</p><h4 id="思路-77"><a href="#思路-77" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最大值大，直接返回左子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最小值小，直接返回右子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别对左右子树进行处理</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目37：将有序数组转换为二叉搜索树-力扣108"><a href="#题目37：将有序数组转换为二叉搜索树-力扣108" class="headerlink" title="题目37：将有序数组转换为二叉搜索树(力扣108)"></a><font color="red">题目37：将有序数组转换为二叉搜索树(力扣108)</font></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p>示例 1：</p><p>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p><p>示例 2：</p><p>输入：nums &#x3D; [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 按 严格递增 顺序排列</p><h4 id="思路-78"><a href="#思路-78" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, left, mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目38：把二叉搜索树转换为累加树-力扣538"><a href="#题目38：把二叉搜索树转换为累加树-力扣538" class="headerlink" title="题目38：把二叉搜索树转换为累加树(力扣538)"></a><font color="red">题目38：把二叉搜索树转换为累加树(力扣538)</font></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038</a> 相同</p><p>示例 1：</p><p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>示例 2：</p><p>输入：root &#x3D; [0,null,1]<br>输出：[1,null,1]</p><p>示例 3：</p><p>输入：root &#x3D; [1,0,2]<br>输出：[3,3,2]</p><p>示例 4：</p><p>输入：root &#x3D; [3,2,4,1]<br>输出：[7,9,4,10]</p><p>提示：</p><p>树中的节点数介于 0 和 10^4 之间。<br>每个节点的值介于 -10^4 和 10^4 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p><h4 id="思路-79"><a href="#思路-79" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convertBST1(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按右中左顺序遍历，累加即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertBST1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST1(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST1(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h3 id="题目1：组合-力扣77"><a href="#题目1：组合-力扣77" class="headerlink" title="题目1：组合(力扣77)"></a><font color="red">题目1：组合(力扣77)</font></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p>示例 1：</p><p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><p>示例 2：</p><p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 20<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><h4 id="思路-80"><a href="#思路-80" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化（剪枝）</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            1.已经选择的元素个数：ret.size();</span></span><br><span class="line"><span class="comment">            2.还需要的元素个数为: k - ret.size();</span></span><br><span class="line"><span class="comment">            3.列表中可选元素（n-i） &gt;= 还需要的元素个数（k - ret.size()）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            为什么需要+1？？（限制最大搜索起点）</span></span><br><span class="line"><span class="comment">                举个例子，n = 4，k = 3， 目前已经选取的元素为0（ret.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。即+1后，【2，3，,4】这个组合都是可以成立的</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt;= n - (k-ret.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            backTrack(n,k,i+<span class="number">1</span>);</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：组合-力扣216"><a href="#题目2：组合-力扣216" class="headerlink" title="题目2：组合|||(力扣216)"></a><font color="red">题目2：组合|||(力扣216)</font></h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>示例 1:</p><p>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。</p><p>示例 2:</p><p>输入: k &#x3D; 3, n &#x3D; 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>没有其他符合的组合了。</p><p>示例 3:</p><p>输入: k &#x3D; 4, n &#x3D; 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 &#x3D; 10，因为10 &gt; 1，没有有效的组合。</p><p>提示:</p><p>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60</p><h4 id="思路-81"><a href="#思路-81" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backTrack(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTrack(k,n,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">backTracking(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line"><span class="comment">// 减枝</span></span><br><span class="line"><span class="keyword">if</span> (sum &gt; targetSum) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == targetSum) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减枝 9 - (k - path.size()) + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">path.add(i);</span><br><span class="line">sum += i;</span><br><span class="line">backTracking(targetSum, k, i + <span class="number">1</span>, sum);</span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line">path.removeLast();</span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line">sum -= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：电话号码的字母组合-力扣17"><a href="#题目3：电话号码的字母组合-力扣17" class="headerlink" title="题目3：电话号码的字母组合(力扣17)"></a><font color="red">题目3：电话号码的字母组合(力扣17)</font></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]</p><p>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h4 id="思路-82"><a href="#思路-82" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：组合总和-力扣39"><a href="#题目4：组合总和-力扣39" class="headerlink" title="题目4：组合总和(力扣39)"></a><font color="red">题目4：组合总和(力扣39)</font></h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><p>示例 2：</p><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：</p><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><p>提示：</p><p>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>2 &lt;&#x3D; candidates[i] &lt;&#x3D; 40<br>candidates 的所有元素 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 40</p><h4 id="思路-83"><a href="#思路-83" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要先进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝操作：若 sum + candidates[i] &gt; target, 则不进入循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            ret.add(candidates[i]);</span><br><span class="line">            backtrack(i, candidates, target);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            ret.remove(ret.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc-JMM</title>
      <link href="/2023/03/28/juc/juc-h/"/>
      <url>/2023/03/28/juc/juc-h/</url>
      
        <content type="html"><![CDATA[<h1 id="juc高级"><a href="#juc高级" class="headerlink" title="juc高级"></a>juc高级</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>规定了线程和内存之间的一些关系</li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><p>主内存和工作内存：</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li><li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-内存交互.png" style="zoom: 67%;"><ul><li>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</li><li>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</li><li>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</li><li>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</li><li>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</li><li>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</li><li>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//添加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BE%8B%E5%AD%90.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响 </p><p>定义原子操作的使用规则：</p><ol><li>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</li><li>不允许一个线程丢弃 assign 操作，必须同步回主存</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li><li>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li><li>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li><li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li></ul><p>补充知识：</p><ul><li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li><li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li><li>振荡周期指周期性信号作周期性重复变化的时间间隔</li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-CPU缓存结构.png" style="zoom: 50%;"><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-内存伪共享.png" style="zoom: 67%;"><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></li><li>内存地址格式：[高位组标记] [低位索引] [偏移量]</li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-缓存一致性.png" style="zoom:80%;"><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p><p>当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p></li><li><p>E：独享的（Exclusive）</p><p>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p></li><li><p>I：无效的（Invalid）</p><p>该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li><li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>保证有序性（禁止指令重排）</li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li><li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</li></ul><hr><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySort</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>;<span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//语句2  谁先执行效果一样</span></span><br><span class="line">x = x + <span class="number">5</span>;<span class="comment">//语句3</span></span><br><span class="line">y = x * x;<span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</p><p>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</p></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况一：线程 1 先执行，ready &#x3D; false，结果为 r.r1 &#x3D; 1</p><p>情况二：线程 2 先执行 num &#x3D; 2，但还没执行 ready &#x3D; true，线程 1 执行，结果为 r.r1 &#x3D; 1</p><p>情况三：线程 2 先执行 ready &#x3D; true，线程 1 执行，进入 if 分支结果为 r.r1 &#x3D; 4</p><p>情况四：线程 2 执行 ready &#x3D; true，切换到线程 1，进入 if 分支为 r.r1 &#x3D; 0，再切回线程 2 执行 num &#x3D; 2，发生指令重排</p></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><p>内存屏障有三个作用：</p><ul><li>确保对内存的读-改-写操作原子执行</li><li>阻止屏障两侧的指令重排序</li><li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li></ul><hr><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;"></li><li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p>保证<strong>有序性</strong>：</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i++&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i--&#125;);</span><br></pre></td></tr></table></figure><p>i++ 反编译后的指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1<span class="comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span></span><br><span class="line"><span class="number">1</span>: istore_1<span class="comment">// 将操作数栈顶数据弹出，存入局部变量表的 slot 1</span></span><br><span class="line"><span class="number">2</span>: iinc<span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;"></li></ul><hr><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li><li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li><li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2，这里的判断不是线程安全的</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li>INSTANCE 要重新赋值</li><li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li></ul><p>实现特点： </p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><ul><li>17 表示创建对象，将对象引用入栈 </li><li>20 表示复制一份对象引用，引用地址</li><li>21 表示利用一个对象引用，调用构造方法初始化对象</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonDemo</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong>  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//线程 start 前对变量的写，对该线程开始后对该变量的读可见</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;System.out.println(x);&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                    System.out.println(thread.getName() + <span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;被打断，退出睡眠&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitor.interrupt();<span class="comment">// 让线程尽快退出Timed Waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">    tpt.start();</span><br><span class="line">    Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">    tpt.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</li><li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    doInit();</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：<br><img src="/../../images/juc/2023-03-29-15-23-21.png"></p><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li><li>CAS 是基于乐观锁的思想</li></ul><p>CAS 缺点：</p><ul><li>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</li><li>只能保证一个共享变量的原子操作<ul><li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li></ul></li><li>引出来 ABA 问题</li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li><li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回<br>实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁  + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li>当旧的预期值 A &#x3D;&#x3D; 内存值 V   此时可以修改，将 V 改为 B</li><li>当旧的预期值 A !&#x3D;  内存值 V   此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">//调用本地方法   --&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field var1)</span>;</span><br></pre></td></tr></table></figure></li><li><p>unsafe 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5: 用 var1 和 var2 找到的内存中的真实值</span></span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value</span><br></pre></td></tr></table></figure><p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();<span class="comment">//当前值，cas的期望值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//期望值更新到该值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口：可以自定义操作逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>compareAndSet：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * expect:期望的值</span></span><br><span class="line"><span class="comment">    * update: 更新的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li><li><code>public final void set(V newValue)</code>：将值设置为 newValue </li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">33</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;Student&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置主内存共享变量为s1</span></span><br><span class="line">        atomicReference.set(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">44</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   ithe index</span></span><br><span class="line"><span class="comment">* expect the expected value</span></span><br><span class="line"><span class="comment">* update the new value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li><li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span> AtomicIntegerFieldUpdater</span><br><span class="line">            .newUpdater(UpdateDemo.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">UpdateDemo</span> <span class="variable">updateDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateDemo</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(updateDemo, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(updateDemo.field);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator </p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li><li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x) </p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc_多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/2023/03/27/juc/juc/"/>
      <url>/2023/03/27/juc/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC基础"><a href="#JUC基础" class="headerlink" title="JUC基础"></a>JUC基础</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源。</li><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的</li><li>并发性：任何进程都可以同其他进行一起并发执行</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位</li><li>结构性：进程由程序，数据和进程控制块三部分组成</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。</li><li>线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,(新建)</span><br><span class="line">    RUNNABLE,（准备就绪）</span><br><span class="line">    BLOCKED,（阻塞）</span><br><span class="line">    WAITING,（不见不散）</span><br><span class="line">    TIMED_WAITING,（过时不候）</span><br><span class="line">    TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程几个状态的介绍：</p><ul><li>New：表示刚刚创建的线程，这种线程还没有开始执行</li><li>RUNNABLE：运行状态，线程的start()方法调用后，线程会处于这种状态</li><li>BLOCKED：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE）</li><li>WAITING：等待状态。和TIME_WAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIME_WAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。</li><li>TERMINATED：表示结束状态，线程执行完毕之后进入结束状态。<br><font color="red">注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态</font></li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行(多核执行多任务)</li><li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行（单核执行多任务）</li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li><li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li><li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong><ul><li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li><li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li></ul></li><li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：<ul><li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li></ul></li></ul><p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p><strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>Monitor(监视器)，也就是我们平时所说的锁.后面介绍。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</span></span><br><span class="line"><span class="comment">// JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="comment">// Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</span></span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV16J411h7Rd">参考视频</a></p><h1 id="JUC进阶"><a href="#JUC进阶" class="headerlink" title="JUC进阶"></a>JUC进阶</h1><h2 id="创建线程-3种-线程池创建不列举"><a href="#创建线程-3种-线程池创建不列举" class="headerlink" title="创建线程(3种,线程池创建不列举)"></a>创建线程(3种,线程池创建不列举)</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li><li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li></ul><p>Thread 构造器：</p><ul><li><code>public Thread()</code></li><li><code>public Thread(String name)</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程写法1：可加参数指定线程名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//写法2：</span></span><br><span class="line">        <span class="comment">/* Thread t = new Thread()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run()&#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li>优点：编码简单</li><li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li></ul><hr><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><code>public Thread(Runnable target)</code></li><li><code>public Thread(Runnable target, String name)</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//写法1：</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//写法2：</span></span><br><span class="line">        <span class="comment">/* Runnable target = new Runnable()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk8后用lambda简化写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//对于只含有一个方法的接口，底层使用了注解@FunctionalInterface</span></span><br><span class="line">        <span class="comment">//因此可以用lambda简化写法</span></span><br><span class="line">        <span class="comment">//原来写法：</span></span><br><span class="line">        <span class="comment">/* Runnable target = new Runnable()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="comment">//idea简化只需要鼠标指到Runnable()那里，alt+enter,提示lambda</span></span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        <span class="comment">//1.只有一个方法的话，去掉函数，只保留参数部分与方法体</span></span><br><span class="line">        <span class="comment">//2.在参数部分与方法体之间用-&gt;</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            <span class="comment">//要执行的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><hr><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>实现 Callable 接口：</p><ol><li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li><li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li><li>把未来任务对象包装成线程对象</li><li>调用线程的 start() 方法启动线程</li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li><li>线程池部分详解了 FutureTask 的源码</li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get() 线程会阻塞等待任务执行完成</li><li>run() 执行完后会把结果设置到 FutureTask  的一个成员变量，get() 线程可以获取到该变量的值</li></ul><p>优缺点：</p><ul><li>优点：同 Runnable，并且能得到线程执行的结果</li><li>缺点：编码复杂</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get(); <span class="comment">// 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匿名内部类写法</span></span><br><span class="line">    <span class="comment">/* public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new Callable&lt;String&gt;&#123;</span></span><br><span class="line"><span class="comment">            @Override//重写线程任务类方法</span></span><br><span class="line"><span class="comment">            public String call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">                return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        //进一步简写</span></span><br><span class="line"><span class="comment">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        Thread t = new Thread(task);</span></span><br><span class="line"><span class="comment">        t.start();</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            String s = task.get(); // 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line"><span class="comment">            System.out.println(s);</span></span><br><span class="line"><span class="comment">        &#125;  catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span><span class="comment">//重写线程任务类方法</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th><th>注意</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td><td>start方法只是让线程进入就绪，里面代码不一定立刻运行(cpu的时间片还没分给它)。每个线程对象的start方法只能调用一次，多次会IllegalThreadStateException</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td><td>如果在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为。</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td><td></td></tr><tr><td>public void getName()</td><td>获取当前线程的名字<br>线程存在默认名称：子线程是 Thread-索引，主线程是 main</td><td></td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td><td></td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行<br><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td><td>从Running进入到Timed Waiting状态(阻塞)</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td><td>主要是为了测试和调试，从Running进到Runnable就绪状态，区别于sleep()</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td><td></td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10(大)</td><td></td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td><td>如果被打断线程正在sleep,wait,join会导致被打断的线程抛出InterruptedException,并清除标记；如果打断的正在运行的线程，则会设置打断标记；park的线程被打断也会设置打断标记</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td><td></td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td><td></td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td><td></td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td><td></td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td><td></td></tr><tr><td>public Thread.State getState()</td><td>返回该线程的状态</td><td></td></tr></tbody></table><hr><h3 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h3><p><code>run：</code>称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p><code>start：</code>使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li><li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li></ul><hr><h3 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h3><p><code>sleep：</code></p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li><li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p><code>yield：</code></p><ul><li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li><li>具体的实现依赖于操作系统的任务调度器</li><li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li></ul><hr><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>public final void join()</code>：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul><li>需要外部共享变量，不符合面向对象封装的思想</li><li>必须等待线程结束，不能配合线程池使用</li></ul></li><li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul><li>main 线程接收结果</li><li>get 方法是让调用线程同步等待</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//不等待线程执行结束，输出的10</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><h4 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h4><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li><p>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="comment">// 打断状态: &#123;&#125;false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打断正常运行的线程：不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="comment">//打断状态: &#123;&#125;true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.park();<span class="comment">//失效，不会阻塞</span></span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);<span class="comment">//和上一个unpark同时执行</span></span><br></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h4 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h4><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li><li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul><p>两阶段终止模式图示：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-两阶段终止模式.png" style="zoom: 67%;"><p>解释说明：在一个正常运行的线程中，当没有被打断，此线程会睡眠2秒，此时若没有异常（sleep被打断会抛出异常），则继续监控该线程。但在正常运行的线程中被打断时，抛出异常，设置打断标记后该线程继续执行，到了判断该标志的时候，处理后事(如释放资源)，退出循环线程。</p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">        tpt.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="comment">//isInterrupted不会清除打断标志,interrupt会</span></span><br><span class="line">                    <span class="keyword">if</span> (thread.isInterrupted()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控记录&quot;</span>);<span class="comment">// 在此被打断不会异常</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">// 在睡眠期间被打断，进入异常处理的逻辑</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 重新设置打断标记，打断 sleep 会清除打断状态</span></span><br><span class="line">                        <span class="comment">//清除后为false</span></span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程 </p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程前设置该线程为守护线程</span></span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><hr><h3 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h3><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="/../../images/juc/2023-03-27-14-42-00.png" alt="1"></p><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park 等方法</li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。Context Switch频繁发生会影响性能。</p><p>JVM 规范并没有限定线程模型，以 HotSpot 为例：</p><ul><li>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</li><li><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程。线程debug(鼠标移动到断点处，ctrl+f8,选择Thread)</p><hr><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</li><li>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</li><li>缺点：无法主动为某个线程多分配时间</li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p>说明：并不能通过优先级来判断线程执行的先后顺序</p><hr><h3 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h3><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</li><li>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li>执行过程：用于维护执行现场，保护、恢复上下文状态</li><li>调度器：负责编排所有要执行的代码顺序</li></ul><hr><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%BA%BF%E7%A8%8B6%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li>竞争锁成功，t 线程从 WAITING → RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING → BLOCKED</li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;    <span class="comment">//NEW,该线程创建并不执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>)&#123;      <span class="comment">//RUNNABLE,一直运行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>)&#123;     <span class="comment">//TERMINATED，正常结束</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>)&#123;     <span class="comment">//TIMED_WAITING，有时间的等待</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.class)&#123;    <span class="comment">//此时没有线程跟t4竞争锁</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t4.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>)&#123;         <span class="comment">//WAITING，等待t2线程，但t2一直运行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            t2.join();  <span class="comment">//等待t2</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t5.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>)&#123;     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.class)&#123;    <span class="comment">//BLOCKED，跟t4竞争锁失败</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t6.start();</span><br></pre></td></tr></table></figure><hr><h2 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h2><p>Windows：</p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><p>Linux：</p><ul><li>ps -ef 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</PID></li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></li></ul><p>Java：</p><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</PID></li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h1 id="JUC高级-并发"><a href="#JUC高级-并发" class="headerlink" title="JUC高级-并发"></a>JUC高级-并发</h1><h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>性能：</p><ul><li>线程安全，性能差</li><li>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li></ul><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块-代码块"><a href="#同步块-代码块" class="headerlink" title="同步块(代码块)"></a>同步块(代码块)</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li>锁对象建议使用共享资源</li><li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li><li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li></ul><p>同步代码块格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line"><span class="comment">// 访问共享资源的核心代码(临界区)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;    <span class="comment">//保证临界区代码块的原子性</span></span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的线程安全类有String、Integer、StringBuffer、Random、Vector、HashTable、java.util.concurrent包下的类,因为多个线程调用它们同一个实例的某个方法时，都是线程安全的，加了synchronized。但方法不能组合.如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合使用无法保证线程安全</span></span><br><span class="line"><span class="type">HashTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>)== <span class="literal">null</span>)&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>,valur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程(操作系统中)</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁。说明：<code>对象头包括Mark Word 和 Klass Word</code></p><ul><li><p>Mark Word 结构：最后两位是<strong>锁标志位</strong>,上锁从01变为10,其他位(hashcode等)都不要，变成指向monitor的指针</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"></p></li><li><p>64 位虚拟机 Mark Word：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"></p></li></ul><h6 id="原理之synchronized"><a href="#原理之synchronized" class="headerlink" title="原理之synchronized"></a>原理之synchronized</h6><p>工作流程：</p><ul><li>开始时 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor工作原理1.png" style="zoom:67%;"></li><li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li><li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li><li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><hr><h6 id="原理之synchronized进阶-字节码-不懂"><a href="#原理之synchronized进阶-字节码-不懂" class="headerlink" title="原理之synchronized进阶(字节码)不懂"></a>原理之synchronized进阶(字节码)<strong>不懂</strong></h6><p><img src="/../../images/juc/2023-03-27-22-52-02.png"><br><img src="/../../images/juc/2023-03-27-22-53-51.png"><br>说明：</p><ul><li>通过异常 try-catch 机制，确保一定会被解锁</li><li>方法级别的 synchronized 不会在字节码指令中有所体现</li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                        锁重入(需要cas操作)</span><br><span class="line">       默认延时开启    ============</span><br><span class="line">          /\          ||          ||</span><br><span class="line">          ||          ||          \/</span><br><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br><span class="line">                           ||      /\</span><br><span class="line">                           \/      ||</span><br><span class="line">                          锁膨胀===||</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，Mark Word后三位标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord结构64位.png" style="zoom: 67%;"><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li><li>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈(yu)值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS(比较并交换，乐观锁) 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png"></p></li><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p></li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li><li>自旋失败的线程会进入阻塞状态</li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋成功.png" style="zoom: 80%;"></p></li><li><p>自旋失败的情况：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋失败.png" style="zoom:80%;"></li></ul><p>自旋锁说明：</p><ul><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型装的是Thread，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始自旋，期望值为null，更新值是当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; 正在自旋&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; 自旋成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程使用完锁把引用变为null</span></span><br><span class="line">atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; invoke unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//占有锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sleepRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li><li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li><li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li><li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程1：占用资源1 ，请求资源2</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//休息两秒，防止线程1直接运行完成。</span></span><br><span class="line">                <span class="comment">//2秒内线程2肯定可以锁住资源2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resources2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1已经占用了资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程2：占用资源2 ，请求资源1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resources1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2已经占用了资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting formonitor entry [0x000000001f54f000]</span></span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略    </span></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000]</span></span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略</span></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line">    </span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715</span><br></pre></td></tr></table></figure></li><li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack <pid>的输出来看各个线程栈</pid></p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一count:&quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait-notify"></a>wait-notify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></pre></td></tr></table></figure><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li><li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li><li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li></ul><p>相同：状态都是TIMED_WAITING</p><p>底层原理：</p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//有没有烟</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;<span class="comment">//while防止虚假唤醒</span></span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//log.debug(&quot;烟到了噢！&quot;);</span></span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park-unpark"></a>park-unpark</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);<span class="comment">//1</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">// Thread.sleep(3000)</span></span><br><span class="line">        <span class="comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;resume...&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark...&quot;</span>);<span class="comment">//3</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p>原理：类似生产者消费者</p><ul><li>先 park：<ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ol></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%861.png"></p><ul><li><p>先 unpark：</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li></ol><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%862.png"></p></li></ul><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li></ul></li></ul><p>局部变量：</p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">// 线程安全</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">// 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</span></span><br></pre></td></tr></table></figure></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectV2</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//模拟下载</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        object.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> object.get(<span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="comment">//timeout(参数：millis) :最大等待时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="comment">//经历时间超过最大等待时间退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Postman</span>(id, id + <span class="string">&quot;号快递到了&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于解耦的邮箱类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mailboxes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生唯一的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象并从map中移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有ids</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//标识，Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//添加get set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span><span class="params">(id)</span>&#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2  1 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line">            <span class="comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">day2_14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：<br><img src="/../../images/juc/2023-03-29-13-00-53.png"></p><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断  防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraditionalProducerConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">        <span class="comment">// t1线程，生产</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t2线程，消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列类，Java间线程之间通信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;:队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列的头部获取消息返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;：已消费消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">//检查队列是否满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName()+<span class="string">&quot;:队列为已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;:已生产消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">consumer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">producer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">    producer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待消费...&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2023/03/28/juc/juc-h/" target="_block">了解更多juc知识?</a></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc_多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例&amp;代理设计模式</title>
      <link href="/2023/03/26/design-pattern/singleton-design-pattern/"/>
      <url>/2023/03/26/design-pattern/singleton-design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><hr><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p><ul><li><p>静态变量的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决序列化问题</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p></li><li><p>防止反序列化破坏单例的方式：</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private&#x2F;protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p></li><li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p></li><li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p></li></ul></li><li><p>静态代码块的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.INSTANCE.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Singleton&gt; &#123; <span class="comment">// Enum实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li><p>线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><hr><h3 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h3><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p><ul><li><p>Singleton</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化接口</span></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><ul><li><p>反射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 反射破解单例模式需要添加的代码</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>Runtime 类就是使用的单例设计模式中的饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> currentRuntime;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Runtime</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代售点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><hr><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"><span class="comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用 Proxy 获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//必须时代理ji</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);<span class="comment">//InvocationHandler对象传递给父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span>&#123;</span><br><span class="line">    <span class="comment">// InvocationHandler 为空则抛出异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一份 interfaces</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置可访问的权限</span></span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 的静态内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类型的名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：Proxy.newInstance 时传递的</span></span><br><span class="line">    <span class="comment">//参数二：Proxy.newInstance 时传递的接口集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 遍历接口集合</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载接口类到 JVM</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证接口 interfaces 集合中没有重复的接口</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">        <span class="comment">// 【生成的代理类访问修饰符 public final】 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span></span><br><span class="line">        <span class="comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 获取访问修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取当前接口的全限定名 包名.类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="comment">// 获取包名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取唯一的编号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// 包名+ $proxy + 数字，比如 $proxy1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代理工厂类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//因为返回值为void</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><hr><h3 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h3><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> design-pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdp </tag>
            
            <tag> Singleton Pattern </tag>
            
            <tag> Proxy Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml基础介绍</title>
      <link href="/2023/03/26/xml-basic/xml-basic/"/>
      <url>/2023/03/26/xml-basic/xml-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XML介绍：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li><li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li><li>XML 标签没有被预定义，需要自行定义标签</li><li>XML 被设计为具有自我描述性，易于阅读</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的区别</strong>：</p><ul><li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li><li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li><li>HTML 旨在显示信息，而 XML 旨在传输信息</li></ul><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>person.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;110&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="comment">&lt;!--年龄--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--姓名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>/&gt;</span><span class="comment">&lt;!--性别--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p><ul><li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p><ul><li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li><li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li><li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes&#x2F;no</li></ul></li><li><p><strong>元素</strong>        </p><ul><li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li><li>格式 2：<code>&lt;person/&gt;</code></li><li>普通元素的结构由开始标签、元素体、结束标签组成</li><li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;&#x2F;&gt;</li></ul></li><li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p><ul><li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li><li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li><li>必须存在一个根标签，有且只能有一个</li></ul></li><li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p><ul><li>属性是元素的一部分，它必须出现在元素的开始标签中</li><li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li><li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li><li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li></ul></li><li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p></li><li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p><table><thead><tr><th align="center">字符</th><th align="center">预定义的转义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center"><code> &amp;gt;</code></td><td align="center">大于</td></tr><tr><td align="center">“</td><td align="center"><code> &amp;quot;</code></td><td align="center">双引号</td></tr><tr><td align="center">‘</td><td align="center"><code> &amp;apos;</code></td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center"><code> &amp;amp;</code></td><td align="center">和号</td></tr></tbody></table></li><li><p><strong>字符区</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">文本数据</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><ul><li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li></ul></li><li><p>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束；</p><ul><li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p></li><li><p>规则：</p><ul><li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li><li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;../css/xml.css&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.属性信息：id , desc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>32<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span></span><br><span class="line">        select * from student where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age <span class="symbol">&amp;gt;</span> 10;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符</span></span><br><span class="line"><span class="comment">        或者也可以选择使用字符数据区，里面的内容可以随便了！</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql2</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p><p>DTD 规则：</p><ul><li><p>约束元素的嵌套层级</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;</span><br></pre></td></tr></table></figure></li><li><p>约束元素体里面的数据</p></li><li><p>语法</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 标签名字 标签类型&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">* 判断元素</span><br><span class="line">           简单元素：没有子元素。</span><br><span class="line">           复杂元素：有子元素的元素；</span><br><span class="line">   </span><br><span class="line">   * 标签类型</span><br><span class="line">   </span><br><span class="line">  | 标签类型 | 代码写法  | 说明                 |</span><br><span class="line">  | -------- | --------- | -------------------- |</span><br><span class="line">  | PCDATA   | (#PCDATA) | 被解释的字符串数据   |</span><br><span class="line">  | EMPTY    | EMPTY     | 即空元素，例如\&lt;hr/&gt; |</span><br><span class="line">  | ANY      | ANY       | 即任意类型           |</span><br><span class="line">  </span><br><span class="line">   * 代码</span><br><span class="line">  </span><br><span class="line">     ```dtd</span><br><span class="line">  &lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;</span><br><span class="line">     &lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;</span><br><span class="line">     &lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;</span><br><span class="line">     &lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br></pre></td></tr></table></figure><ul><li><p>数量词</p><table><thead><tr><th>数量词符号</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>表示元素出现一次</td></tr><tr><td>*</td><td>表示元素可以出现0到多个</td></tr><tr><td>+</td><td>表示元素可以出现至少1个</td></tr><tr><td>?</td><td>表示元素可以是0或1个</td></tr><tr><td>,</td><td>表示元素需要按照顺序显示</td></tr><tr><td>|</td><td>表示元素需要选择其中的某一个</td></tr></tbody></table></li></ul></li><li><p>属性声明</p><ul><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 标签名称 </span><br><span class="line">属性名称1 属性类型1 属性说明1</span><br><span class="line">属性名称2 属性类型2 属性说明2</span><br><span class="line">…</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性类型</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>CDATA</td><td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td></tr><tr><td>ID</td><td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td></tr><tr><td>ENUMERATED</td><td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td></tr></tbody></table></li><li><p>属性说明</p><table><thead><tr><th>属性说明</th><th>含义</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>代表属性是必须有的</td></tr><tr><td>#IMPLIED</td><td>代表属性可有可无</td></tr><tr><td>#FIXED</td><td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td></tr></tbody></table></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 书   &lt;!--设置&quot;书&quot;元素的的属性列表--&gt;</span><br><span class="line">id ID #REQUIRED&lt;!--&quot;id&quot;属性值为必须有--&gt;</span><br><span class="line">编号 CDATA #IMPLIED   &lt;!--&quot;编号&quot;属性可有可无--&gt;</span><br><span class="line">出版社 (清华|北大) &quot;清华&quot;   &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“123”--&gt;</span><br><span class="line">type CDATA #FIXED &quot;IT&quot;&lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>XSD 定义：</p><ol><li>Schema 语言也可作为 XSD（XML Schema Definition）</li><li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li><li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li><li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li><li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li></ol><p>XSD 规则：</p><ol><li>创建一个文件，这个文件的后缀名为 .xsd</li><li>定义文档声明</li><li>schema 文件的根标签为： <schema></schema></li><li>在 <schema> 中定义属性：<ul><li>xmlns&#x3D;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li><li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>targetNamespace &#x3D; 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li><li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>elementFormDefault&#x3D;”qualified“，表示当前 schema 文件是一个质量良好的文件。</li></ul></schema></li><li>通过 element 定义元素</li><li><strong>判断当前元素是简单元素还是复杂元素</strong></li></ol><p>person.xsd</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;</span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;</span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span>  &lt;!--本文件是质量好的--&gt;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;      &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">        &lt;complexType&gt;             &lt;!--复杂的元素--&gt;</span><br><span class="line">            &lt;sequence&gt;  &lt;!--里面的元素必须按照顺序定义--&gt;</span><br><span class="line">                &lt;element name = <span class="string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p><p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p><p>Dom4J 实现：</p><ul><li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p></li><li><p>SAXReader 常用 API：</p><ul><li><code>public Document read(File file)</code>：Reads a Document from the given File</li><li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li></ul></li><li><p>Java Class 类 API：</p><ul><li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li></ul></li></ul><hr><h3 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h3><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span></span><br><span class="line">        <span class="comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span></span><br><span class="line">        <span class="comment">// 这里的“/”是直接去src类路径下寻找文件。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="string">&quot;/books.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        System.out.println(document);</span><br><span class="line"><span class="comment">//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]</span></span><br><span class="line"><span class="comment">// 4.从document文档树对象中提取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());<span class="comment">//books</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0001&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一本书&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>  JavaWeb开发教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>    张三<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元   <span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元<span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><p>Element 元素的 API:</p><ul><li>String getName()：取元素的名称。</li><li>List<Element> elements()：获取当前元素下的全部子元素（一级）</Element></li><li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</Element></li><li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.获取根元素下的全部子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements = root.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.获取根源下的全部book子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements1 = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements1) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.获取根源下的指定的某个元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(son.getName());</span><br><span class="line">        <span class="comment">// 默认会提取第一个名称一样的子元素对象返回！</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son1</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(son1.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Element 元素的 API：</p><ul><li>List<Attribute> attributes()：获取元素的全部属性对象</Attribute></li><li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li><li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li></ul><p>Attribute 对象的 API：</p><ul><li>String getName()：获取属性名称</li><li>String getValue()：获取属性值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.获取book子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取book元素的全部属性对象</span></span><br><span class="line">        List&lt;Attribute&gt; attributes = bookEle.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName()+<span class="string">&quot;-&gt;&quot;</span>+attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.获取Book元素的某个属性对象</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">descAttr</span> <span class="operator">=</span> bookEle.attribute(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(descAttr.getName()+<span class="string">&quot;-&gt;&quot;</span>+descAttr.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.可以直接获取元素的属性值</span></span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;desc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>Element：</p><ul><li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li><li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li><li>String getText()：直接获取当前元素的文本内容</li><li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.得到第一个子元素book</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.直接拿到当前book元素下的子元素文本值</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;author&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.先获取到子元素对象，再获取该文本值</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookNameEle</span> <span class="operator">=</span> bookEle.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(bookNameEle.getText());</span><br><span class="line">        System.out.println(bookNameEle.getTextTrim());<span class="comment">// 去前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p><p>XPath 常用API：</p><ul><li>List<Node> selectNodes(String var1) : 检索出一批节点集合</Node></li><li>Node selectSingleNode(String var1) : 检索出一个节点返回</li></ul><p>XPath 提供的四种检索数据的写法：</p><ol><li>绝对路径：&#x2F;根元素&#x2F;子元素&#x2F;子元素</li><li>相对路径：.&#x2F;子元素&#x2F;子元素 (.代表了当前元素)</li><li>全文搜索：<ul><li>&#x2F;&#x2F;元素：在全文找这个元素</li><li>&#x2F;&#x2F;元素1&#x2F;元素2：在全文找元素1下面的一级元素 2</li><li>&#x2F;&#x2F;元素1&#x2F;&#x2F;元素2：在全文找元素1下面的全部元素 2</li></ul></li><li>属性查找：<ul><li>&#x2F;&#x2F;@属性名称：在全文检索属性对象</li><li>&#x2F;&#x2F;元素[@属性名称]：在全文检索包含该属性的元素对象</li><li>&#x2F;&#x2F;元素[@属性名称&#x3D;值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contact.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        <span class="comment">//1.使用绝对路径定位全部的name名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            System.out.println(nameNode.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.相对路径。从根元素开始检索，.代表很根元素</span></span><br><span class="line">        List&lt;Node&gt; nameNodes2 = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.1 在全文中检索name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//name&quot;</span>);<span class="comment">//全部的</span></span><br><span class="line">        <span class="comment">//3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="comment">//3.3 在全文中检索所有contact下的直接name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact/name&quot;</span>);<span class="comment">//不包括sql和外面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1 检索全部属性对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//@id&quot;</span>);<span class="comment">//包括sql4</span></span><br><span class="line">        <span class="comment">//4.2 在全文检索包含该属性的元素对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//contact[@id]&quot;</span>);</span><br><span class="line">        <span class="comment">//4.3 在全文检索包含该属性的元素且属性值为该值的元素对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeEle</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//contact[@id=2]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element)nodeEle;</span><br><span class="line">        System.out.println(ele.elementTextTrim(<span class="string">&quot;name&quot;</span>));<span class="comment">//xi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小白<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>bai@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小黑<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hei@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sql4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小虎<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hu@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>外面的名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java高级(全)</title>
      <link href="/2023/03/04/Java/java-high/"/>
      <url>/2023/03/04/Java/java-high/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p><p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p><p>数组：类型和长度一旦定义出来就都固定</p><p>作用：</p><ul><li>在开发中，很多时候元素的个数是不确定的</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li></ul><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><ul><li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p></li><li><p>栈（stack）：后进先出，先进后出 （LIFO）</p></li><li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p><p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p></li><li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p></li><li><p>树：</p><ul><li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） </p><p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p></li><li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p><p>特点：<strong>红黑树的增删查改性能都好</strong></p></li></ul></li></ul><p>各数据结构时间复杂度对比：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png"></p><p>图片来源：<a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p><hr><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p><p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection集合的体系:</span><br><span class="line">                      Collection&lt;E&gt;(接口)</span><br><span class="line">                 /                         \</span><br><span class="line">          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)</span><br><span class="line">      /               \                  /             \</span><br><span class="line"> HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类)</span><br><span class="line"> /</span><br><span class="line">LinkedHashSet&lt;&gt;(实现类)</span><br></pre></td></tr></table></figure><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><hr><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sets.add(<span class="string">&quot;MyBatis&quot;</span>);</span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        sets.add(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">        sets.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(sets)<span class="comment">//[]无序的;</span></span><br><span class="line">        System.out.println(sets.contains(<span class="string">&quot;java&quot;</span>));<span class="comment">//true 存在</span></span><br><span class="line">        Object[] arrs = sets.toArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c1.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;ee&quot;</span>);</span><br><span class="line">        c1.addAll(c2);<span class="comment">// c1:[java,ee]  c2:[ee];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器</p><ul><li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li><li><code>E next()</code>：获取下一个元素值</li><li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li><li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li></ul></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        System.out.println(lists); <span class="comment">// lists = [aa, bb, cc]</span></span><br><span class="line"><span class="comment">//迭代器流程</span></span><br><span class="line">        <span class="comment">// 1.得到集合的迭代器对象。</span></span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="comment">// 2.使用while循环遍历。</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>List 集合继承了 Collection 集合全部的功能。</p><p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p><p>List 系列集合：</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引</p></li></ul><hr><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//多态</span></span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);<span class="comment">//可以重复</span></span><br><span class="line">    lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; lists.size() ; i++ ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e 插入的元素  elementData底层数组   size 插入的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">// 插入size位置，然后加一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断elementData是不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值和最小需求容量最大的一个</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的容量大于数组长度，进行扩容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 索引越界</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将指定索引后的数据后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity&#x2F;2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;<span class="comment">//不需要扩容计算</span></span><br><span class="line">    <span class="comment">//检查新容量是否大于最大数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span></span><br><span class="line">        <span class="comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取下一个元素时首先判断结构是否发生变化</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount 被其他线程改变抛出并发修改异常</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【允许删除操作】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 删除后重置 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code> 数组存储</p></li></ol><hr><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue); <span class="comment">// [1号, 2号, 3号]</span></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//1号</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//2号</span></span><br><span class="line">        System.out.println(queue);<span class="comment">//[3号]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做一个栈 先进后出</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);<span class="comment">//addFirst(e);</span></span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack); <span class="comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span></span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        System.out.println(stack.pop());<span class="comment">//removeFirst(); 第3颗子弹</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);<span class="comment">// [第1颗子弹]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index&#x3D;0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index&#x3D;-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Set 系列集合：</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p><hr><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT &#x3D; new Object()</strong></p><p>Set 集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。</span><br><span class="line"><span class="number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。</span><br><span class="line">    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）</span><br><span class="line">    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。</span><br><span class="line">    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了</span><br><span class="line">    如果不相同认为不重复。</span><br><span class="line"></span><br><span class="line">            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较</span><br><span class="line">               /                     \</span><br><span class="line">            <span class="literal">false</span>                    <span class="literal">true</span></span><br><span class="line">            /                          \</span><br><span class="line">        不重复                        继续让两个对象进行equals比较</span><br><span class="line">                                       /          \</span><br><span class="line">                                     <span class="literal">false</span>        <span class="literal">true</span></span><br><span class="line">                                      /             \</span><br><span class="line">                                    不重复          重复了</span><br></pre></td></tr></table></figure></li><li><p>Set 系列集合元素无序的根本原因</p><p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><ul><li>JDK 1.8 之前：哈希表 &#x3D; 数组（初始容量16) + 链表  + （哈希算法）</li><li>JDK 1.8 之后：哈希表 &#x3D; 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul><li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li><li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><hr><h4 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h4><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><hr><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>   方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><pre><code>  * 比较者大于被比较者，返回正数  * 比较者小于被比较者，返回负数  * 比较者等于被比较者，返回 0</code></pre></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">Collections.add(students,s1,s2,s3);</span><br><span class="line">        System.out.println(students);<span class="comment">//按照年龄比较 升序</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// o1比较者   o2被比较者</span></span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 重写了比较方法。</span></span><br><span class="line">    <span class="comment">// e1.compareTo(o)</span></span><br><span class="line">    <span class="comment">// 比较者：this</span></span><br><span class="line">    <span class="comment">// 被比较者：o</span></span><br><span class="line">    <span class="comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? <span class="built_in">this</span>.getName().compareTo(o.getName):result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p><hr><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="comment">//实现大顶堆</span></span><br></pre></td></tr></table></figure></li></ul><p>常用 API：</p><ul><li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列的<strong>尾部</strong></li><li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null </li><li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li><li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li></ul><hr><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p><p>Collections 有几个常用的API：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li><li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;赵&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">98.5</span>, <span class="number">66.5</span> , <span class="number">59.5</span> , <span class="number">66.5</span> , <span class="number">99.5</span> );</span><br><span class="line">        Collections.shuffle(scores);</span><br><span class="line">        Collections.sort(scores); <span class="comment">// 默认升序排序！</span></span><br><span class="line">        System.out.println(scores);</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(students,s1,s2,s3,s4);</span><br><span class="line">        Collections.sort(students,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key&#x3D;value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map集合的体系：</span><br><span class="line">        Map&lt;K , V&gt;(接口,Map集合的祖宗类)</span><br><span class="line">       /                      \</span><br><span class="line">      TreeMap&lt;K , V&gt;           HashMap&lt;K , V&gt;(实现类,经典的，用的最多)</span><br><span class="line">                                 \</span><br><span class="line">                                  LinkedHashMap&lt;K, V&gt;(实现类)</span><br></pre></td></tr></table></figure><p>Map 集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><hr><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(.....);</span><br><span class="line">        System.out.println(maps.isEmpty());<span class="comment">//false</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(<span class="string">&quot;....&quot;</span>);<span class="comment">//返回键值对象</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();<span class="comment">//获取Map集合中所有的键，</span></span><br><span class="line">        <span class="comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        <span class="comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//(1)键找值</span></span><br><span class="line">    Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key : keys) &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Iterator&lt;String&gt; iterator = hm.keySet().iterator();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)键值对</span></span><br><span class="line">    <span class="comment">//(2.1)普通方式</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">             System.out.println(entry.getKey() + <span class="string">&quot;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2.2)迭代器方式</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) Lamda</span></span><br><span class="line">    maps.forEach((k,v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;==&gt;&quot;</span> + v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 &#x3D; 数组 + 链表，8 &#x3D; 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由数组+链表组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><p><a href="https://www.bilibili.com/video/BV1nJ411J7AA">参考视频</a></p><hr><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>HashMap 继承关系如下图所示：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li></ul><hr><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>HashMap 构造方法指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity)<span class="comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合最大容量 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合最大容量的上限是：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span></span><br></pre></td></tr></table></figure></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p> 为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="number">0.75</span>，平均参数约为<span class="number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="number">0.5</span>)*pow(<span class="number">0.5</span>, k)/factorial(k))</span><br><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br><span class="line">一个bin中链表长度达到<span class="number">8</span>个元素的概率为<span class="number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="number">8</span>这个数字</span><br></pre></td></tr></table></figure></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)&#x3D;3，链表的平均查找长度为 n&#x2F;2，当长度为 8 时，平均查找长度为 8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，而 log(6)&#x3D;2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小于 6 则会从红黑树转回链表</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p> 原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>HashMap 中<strong>存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></li><li><p>记录 HashMap 的修改次数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br></pre></td></tr></table></figure></li><li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希表的加载因子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size&#x2F;capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p><p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)<span class="comment">//构造指定初始容量和加载因子的空HashMap</span></span><br></pre></td></tr></table></figure></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;&#x3D; threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p></li></ul></li></ol><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"><span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// 最后调用了tableSizeFor</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putMapEntries 源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">            <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s &#x2F; loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><hr><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p></li><li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p><p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span></span><br><span class="line">    <span class="comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  <span class="comment">//。。。。。。。。。。。。。。</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="comment">// 如果这里允许覆盖，就直接返回了</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数量大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;"><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY &#x3D; 64 就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;<span class="comment">//int cap = 10</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n&#x3D;0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位或之后是13</span></span><br><span class="line"><span class="comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span></span><br></pre></td></tr></table></figure></li><li><p>第二次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位或之后是15</span></span><br><span class="line"><span class="comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span></span><br></pre></td></tr></table></figure><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure></li><li><p>JDK 11</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">//无符号右移，高位补0</span></span><br><span class="line"><span class="comment">//-1补码: 11111111 11111111 11111111 11111111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最高位之前的0的位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始化的threshold赋值给newCap</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// oldCap 旧数组大小，2 的 n 次幂</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;<span class="comment">//指向低位链表头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;<span class="comment">//指向低位链表尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;<span class="comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span></span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果低位链表首节点不为null，说明有这个链表存在</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果链表下的元素小于等于6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span></span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span></span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//需要构建新的红黑树了</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span></span><br><span class="line">    <span class="comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;<span class="comment">//临时变量，储存要返回的节点信息</span></span><br><span class="line">        <span class="comment">//key和value都相等，直接返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="comment">//跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//把当前节点p指向e 继续遍历</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line">        <span class="comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//node是首节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//node不是首节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//LinkedHashMap</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><hr><h4 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h4><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.keySet().iterator();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 底层获取的是 KeyIterator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 回调 HashMap.HashIterator#nextNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> nextNode().key; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for 【fast-fail】，快速失败</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// iterator.next() 会调用这个函数</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li><li><p>维护顺序的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>put()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用父类HashMap的put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">→ afterNodeInsertion(evict);<span class="comment">// evict为true</span></span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);<span class="comment">//移除头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断 p 是否是首节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//是头节点 让p后继节点成为头节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 判断p是否是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 不是尾节点 让p后继节点指向p的前驱节点</span></span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 是尾节点 让last指向p的前驱节点</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 判断last是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// last为空说明p是尾节点或者只有p一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// last和p相互连接</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用HashMap的remove方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,<span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span></span><br><span class="line">→ afterNodeRemoval(node);</span><br></pre></td></tr></table></figure><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 让p节点与前驱节点和后继节点断开链接</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断p是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是头节点 让head指向p的后继节点</span></span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);<span class="comment">//把1放入尾部</span></span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());<span class="comment">//[3, 1, 4]只能存3个，移除2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p><p>成员属性：</p><ul><li><p>Entry 节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;<span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;<span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;<span class="comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator == <span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p><hr><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p><ul><li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p></li><li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p></li><li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p></li><li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">            <span class="built_in">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>泛型（Generic）：</p><ul><li>泛型就是一个标签：&lt;数据类型&gt;</li><li>泛型可以在编译阶段约束只能操作某种数据类型。</li></ul><p>注意：</p><ul><li>JDK 1.7 开始之后，泛型后面的申明可以省略不写</li><li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">lists.add(<span class="number">99.9</span>);</span><br><span class="line">lists.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">lists.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lists1.add(<span class="number">10</span>);</span><br><span class="line">lists1.add(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p><hr><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类：使用了泛型定义的类就是泛型类</p><p>泛型类格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">泛型变量建议使用 E , T , K , V</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;String&gt;();</span><br><span class="line">        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;自定义泛型类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法：定义了泛型的方法就是泛型方法</p><p>泛型方法的定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p><p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] num = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> arrToString(nums);</span><br><span class="line">     </span><br><span class="line">        String[] name = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> arrToString(names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">arrToString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        --------------</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><p>泛型接口：使用了泛型定义的接口就是泛型接口。</p><p>泛型接口的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentData</span>();</span><br><span class="line">        d.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        ................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;重写所有方法&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符：？</p><ul><li>? 可以用在使用泛型的时候代表一切类型</li><li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li><li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;AD&gt; ads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        run(bmws);</span><br><span class="line">        <span class="comment">//run(dogs);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ArrayList&lt;? extends Car&gt; car)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AD</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异常的体系:</span><br><span class="line">         Throwable(根类，不是异常类)</span><br><span class="line">      /              \</span><br><span class="line">    Error           Exception（异常，需要研究和处理）</span><br><span class="line">                    /            \</span><br><span class="line">                   编译时异常     RuntimeException(运行时异常)</span><br></pre></td></tr></table></figure><p>Exception 异常的分类:</p><ul><li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li><li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li></ul><hr><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点终止当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。。。。。。。&quot;</span>);</span><br><span class="line">        chu( <span class="number">10</span> ,<span class="number">0</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b ;<span class="comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p><p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p><p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h4><p>可以处理异常，并且出现异常后代码也不会死亡</p><ul><li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;...finall&#123;</span><br><span class="line"><span class="comment">//资源释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace(); <span class="comment">// **直接打印异常栈信息**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Throwable成员方法:</strong></p><ul><li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li><li><code>public String toString()</code>：返回此可抛出的简短描述</li><li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h4><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseDate(<span class="string">&quot;2013-03-23 10:19:23&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseDate</span><span class="params">(String time)</span> <span class="keyword">throws</span> Exception&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常：NumberFormatException</li></ol><hr><h3 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h3><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            chu(<span class="number">10</span> / <span class="number">0</span>);<span class="comment">//ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作成功！&quot;</span>);<span class="comment">//没输出</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;操作失败！&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>  &#123; System.out.println( a / b );&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>用在捕获处理的异常格式中的，放在最后面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>: <span class="number">1</span>次。</span><br><span class="line"><span class="keyword">catch</span>：<span class="number">0</span>-N次  (如果有<span class="keyword">finally</span>那么<span class="keyword">catch</span>可以没有!!)</span><br><span class="line"><span class="keyword">finally</span>: <span class="number">0</span>-<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(chu());<span class="comment">//一定会输出 finally,优先级比return高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">return</span> a ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====finally被执行&quot;</span>);</span><br><span class="line">            <span class="comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/cang.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==finally被执行===&quot;</span>);</span><br><span class="line">            <span class="comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h2><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li></ul><p>throws：用在方法上，用于抛出方法中的异常</p><p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIllegalException &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>)&#123;<span class="comment">//年龄在0-200之间</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;/ age is illegal!&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄是：&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    Alt + Insert-&gt;Constructor </span><br><span class="line">&#125;<span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//运行时异常</span></span><br></pre></td></tr></table></figure><hr><h2 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h2><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li><li>在 try&#x2F;catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//请输入一个合法的年龄</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入您的年年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄：&quot;</span>+age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;您的年龄是瞎输入的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda 表达式的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line"><span class="comment">//被重写方法的方法体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h3 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h3><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p><ul><li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; System.out.println(s) );</span><br></pre></td></tr></table></figure><hr><h3 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h3><p>Comparator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//...s1 s2 s3</span></span><br><span class="line">        Collections.addAll(lists , s1 , s2 , s3);</span><br><span class="line">        Collections.sort(lists, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.getAge() - t2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 参数类型可以省略,最简单的</span></span><br><span class="line">        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lists.forEach( s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 方法引用！</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义集合加入几个Student元素</span></span><br><span class="line"><span class="comment">// 使用静态方法进行简化！</span></span><br><span class="line">Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));</span><br><span class="line"><span class="comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span></span><br><span class="line">Collections.sort(lists, Student::compareByAge);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1 , Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        <span class="comment">// 对象是 System.out = new PrintStream();</span></span><br><span class="line">        <span class="comment">// 实例方法：println()</span></span><br><span class="line">        <span class="comment">// 前后参数正好都是一个</span></span><br><span class="line">        lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Patricia&quot;</span>,<span class="string">&quot;Dlei&quot;</span> , <span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Boom&quot;</span>, <span class="string">&quot;Cao&quot;</span> ,<span class="string">&quot;black&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>,<span class="string">&quot;cao&quot;</span>,<span class="string">&quot;after&quot;</span>,<span class="string">&quot;sa&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span></span><br><span class="line">        <span class="comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span></span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.compareToIgnoreCase(s2);<span class="comment">//按照元素的首字符(忽略大小写)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特定类型的方法引用：</span></span><br><span class="line">        Arrays.sort(strs,  String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合默认只能转成Object类型的数组。</span></span><br><span class="line">        Object[] objs = lists.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span></span><br><span class="line">        String[] strs = lists.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String[] strs1 = lists.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]);</span><br><span class="line">        String[] strs2 = lists.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p><ul><li>可以解决已有集合类库或者数组 API 的弊端</li><li>Stream 流简化集合和数组的操作</li><li>链式编程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p><p>数组：Arrays.stream(数组)   &#x2F;  Stream.of(数组);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection集合获取Stream流。</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; listStream = c.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map集合获取流</span></span><br><span class="line"><span class="comment">// 先获取键的Stream流。</span></span><br><span class="line">Stream&lt;String&gt; keysStream = map.keySet().stream();</span><br><span class="line"><span class="comment">// 在获取值的Stream流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = map.values().stream();</span><br><span class="line"><span class="comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组获取流</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaEE&quot;</span> ,<span class="string">&quot;Spring Boot&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;String&gt; arrStream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>逐一处理（遍历）</td></tr><tr><td>long count</td><td>返回流中的元素数</td></tr><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</T></td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</T></td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream<T> skip(long n)</T></td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</R></R></td><td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</T></T></td><td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td></tr><tr><td>Stream<T> distinct()</T></td><td>返回由该流的不同元素组成的流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>); list.add(<span class="string">&quot;周芷若&quot;</span>); list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>); list.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">        <span class="comment">//取以张开头并且名字是三位数的</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).count();</span><br><span class="line"><span class="comment">//取前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).limit(<span class="number">2</span>).forEach(...);</span><br><span class="line"><span class="comment">//跳过前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).skip(<span class="number">2</span>).forEach(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：把名称都加上“张三的:+xxx”</span></span><br><span class="line">list.stream().map(s -&gt; <span class="string">&quot;张三的&quot;</span> + s).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 需求：把名称都加工厂学生对象放上去!!</span></span><br><span class="line"><span class="comment">// list.stream().map(name -&gt; new Student(name));</span></span><br><span class="line">list.stream.map(Student::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">                                          </span><br><span class="line"><span class="comment">//数组流</span></span><br><span class="line">Stream&lt;Integer&gt; s1 = Stream.of(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">//集合流</span></span><br><span class="line">Stream&lt;String&gt; s2 = list.stream();</span><br><span class="line"><span class="comment">//合并流</span></span><br><span class="line">Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);</span><br><span class="line">s3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure><hr><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreach终结方法</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">    .filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h3><p>收集 Stream：把 Stream 流的数据转回到集合中去</p><ul><li>Stream 流：工具</li><li>集合：目的</li></ul><p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p><p>Collectors 方法：</p><ul><li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li><li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li><li><code>Object[] toArray()</code>：把元素收集数组中</li><li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));    </span><br><span class="line">    <span class="comment">//把stream流转换成Set集合。</span></span><br><span class="line">    Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成List集合。</span></span><br><span class="line">    <span class="comment">//重新定义，因为资源已经被关闭了</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成数组。</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    Object[] arr = stream2.toArray();</span><br><span class="line">    <span class="comment">// 可以借用构造器引用申明转换成的数组类型！！！</span></span><br><span class="line">    String[] arr1 = stream2.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p><p>File 类构造器：</p><ul><li><code>public File(String pathname)</code>：根据路径获取文件对象</li><li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li></ul><p>File 类创建文件对象的格式：</p><ul><li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p><ul><li>绝对路径：从磁盘的的盘符一路走到目的位置的路径<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li><li>一般是定位某个操作系统中的某个文件对象</li></ul></li><li><strong>相对路径</strong>：不带盘符的（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件，可以跨平台</li></ul></li></ul></li><li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象：使用绝对路径</span></span><br><span class="line">        <span class="comment">// 文件路径分隔符：</span></span><br><span class="line">        <span class="comment">//      -- a.使用正斜杠： /</span></span><br><span class="line">        <span class="comment">//      -- b.使用反斜杠： \\</span></span><br><span class="line">        <span class="comment">//      -- c.使用分隔符API:File.separator</span></span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator</span></span><br><span class="line"><span class="comment">//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 获取文件的大小，字节大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建文件对象：使用相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day09Demo/src/dlei.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建文件对象：代表文件夹。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片资源&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists());<span class="comment">// 判断路径是否存在！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getAbsolutePath()</td><td>返回此 File 的绝对路径名字符串</td></tr><tr><td>String getPath()</td><td>获取创建文件对象的时候用的路径</td></tr><tr><td>String getName()</td><td>返回由此 File 表示的文件或目录的名称</td></tr><tr><td>long length()</td><td>返回由此 File 表示的文件的长度（大小）</td></tr><tr><td>long length(FileFilter filter)</td><td>文件过滤器</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/图片/test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>方法列表：</p><ul><li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li><li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li><li><code>boolean isFile()</code>：此 File 表示的是否为文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// a.判断文件路径是否存在</span></span><br><span class="line">System.out.println(f.exists()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span></span><br><span class="line">System.out.println(f.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span></span><br><span class="line">System.out.println(f.isDirectory()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h4><p>方法列表：</p><ul><li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li><li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li><li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li><li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.创建新文件，创建成功返回true ,反之</span></span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f.delete());</span><br><span class="line">        <span class="comment">// 不能删除非空文件夹，只能删除空文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/it/aaaaa&quot;</span>);</span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/bbbb&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d.创建多级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><ul><li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li><li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li><li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified(); <span class="comment">// 最后修改时间！</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>递归实现文件搜索（非规律递归）</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去某个目录下搜索某个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 搜索文件的目录。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName 搜索文件的名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir , String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断是否存在该路径，是否是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">        <span class="comment">// 2.提取当前目录下的全部一级文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">files</span> <span class="operator">=</span> dir.listFiles();<span class="comment">// 可能是null/也可能是空集合[]</span></span><br><span class="line">        <span class="comment">// 3.判断是否存在一级文件对象,判断是否不为空目录</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.判断一级文件对象</span></span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="comment">// 5.判断file是文件还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 6.判断该文件是否为我要找的文件对象</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;<span class="comment">//模糊查找</span></span><br><span class="line">                        sout(f.getAbsolutePath());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 启动它（拓展）</span></span><br><span class="line">                            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                            r.exec(f.getAbsolutePath());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span></span><br><span class="line">                    searchFiles(file,fileName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>字符集：为字符编制的一套编号规则</p><p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p><p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 &#x3D; 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  97</span><br><span class="line">b  98</span><br><span class="line"></span><br><span class="line">A  65</span><br><span class="line">B  66</span><br><span class="line"></span><br><span class="line">0  48</span><br><span class="line">1  49</span><br></pre></td></tr></table></figure><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p><p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p><ul><li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li><li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li></ul><p>编码前与编码后的编码集必须一致才不会乱码</p><hr><h2 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>IO 输入输出流：输入&#x2F;输出流</p><ul><li>Input：输入</li><li>Output：输出</li></ul><p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p><p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p><p>IO 流的分类：</p><ul><li>按照流的方向分为：输入流，输出流。<ul><li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li></ul></li><li>按照流的内容分为：字节流，字符流<ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li></ul></li></ul><p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IO 流的体系：</span><br><span class="line">        字节流                                   字符流</span><br><span class="line">  字节输入流              字节输出流            字符输入流         字符输出流</span><br><span class="line">InputStream           OutputStream          Reader            <span class="title function_">Writer</span>   <span class="params">(抽象类)</span></span><br><span class="line">FileInputStream       FileOutputStream      FileReader        <span class="title function_">FileWriter</span><span class="params">(实现类)</span></span><br><span class="line">BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="title function_">BufferedWriter</span><span class="params">(实现类缓冲流)</span></span><br><span class="line">                                           InputStreamReader OutputStreamWriter</span><br><span class="line">ObjectInputStream     ObjectOutputStream</span><br></pre></td></tr></table></figure><hr><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h4><p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p><p>构造方法：</p><ul><li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li><li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象</li></ul><p>方法：</p><ul><li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li><li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li><li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li><li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象定位dlei01.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/dlei01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span></span><br><span class="line"><span class="comment">//int code1 = is.read(); // 读取一滴水，一个字节</span></span><br><span class="line"><span class="comment">//System.out.println((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.使用while读取字节数</span></span><br><span class="line">        <span class="comment">// 定义一个整数变量存储字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>((ch = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p><p>采取下面的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//简化写法，底层实质上创建了File对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];<span class="comment">//开发中使用byte[1024]</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取了多少就倒出多少！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"><span class="comment">// 读取全部的</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer);</span><br><span class="line">System.out.println(rs);</span><br></pre></td></tr></table></figure><hr><h4 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h4><p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p><p>构造方法：</p><ul><li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li><li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li><li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li><li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li></ul><p>API：</p><ul><li><p><code>public void write(int a)</code>：写一个字节出去 </p></li><li><p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p></li><li><p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p></li><li><p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p><ul><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot;)</code>：覆盖数据管道</li><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot; , true)</code>：追加数据的管道</li></ul></li></ul><p>说明：</p><ul><li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li><li>换行用：<strong>os.write(“\r\n”.getBytes())</strong></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/out05&quot;</span>);</span><br><span class="line">os.write(<span class="number">97</span>);<span class="comment">//a</span></span><br><span class="line">os.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">os.write(<span class="string">&quot;我爱Java&quot;</span>.getBytes());</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//（1）创建一个字节输入流管道与源文件接通。</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（2）创建一个字节输出流与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（3）创建一个字节数组作为桶</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//（4）从字节输入流管道中读取数据，写出到字节输出流管道即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**（5）关闭资源！ */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h4><p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p><p>构造器：</p><ul><li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li><li><code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li></ul><p>方法：</p><ul><li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li><li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li></ul><p>结论：</p><ul><li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li><li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li></ul><p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span>&#123;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个字符输入流管道与源文件路径接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h4><p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p><p>构造器：</p><ul><li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li><li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li><li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li><li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li></ul><p>方法：</p><ul><li><code>public void write(int c)</code>：写一个字符出去</li><li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li><li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li><li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li><li><code>fw.write(&quot;\r\n&quot;)</code>：换行</li></ul><p>读写字符文件数据建议使用字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">fw.write(<span class="number">97</span>);   <span class="comment">// 字符a</span></span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 字符b</span></span><br><span class="line">fw.write(<span class="string">&quot;Java是最优美的语言！&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">fw.close;</span><br></pre></td></tr></table></figure><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲流可以提高字节流和字符流的读写数据的性能</p><p>缓冲流分为四类：</p><ul><li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li><li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li><li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li><li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li></ul><hr><h4 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h4><p>字节缓冲输入流：BufferedInputStream</p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p><p>构造器：<code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个低级的字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span></span><br><span class="line">        <span class="type">BufferInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferInputStream</span>(is);</span><br><span class="line">        <span class="comment">// 3.定义一个字节数组按照循环读取。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h4><p>字节缓冲输出流：BufferedOutputStream</p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.写一个原始的字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输出流包装成一个高级的缓冲字节输出流</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 3.写数据出去</span></span><br><span class="line">        bos.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bos.write(<span class="number">100</span>);</span><br><span class="line">        bos.write(<span class="string">&quot;我爱中国&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h4><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p><p>复制流：</p><ul><li>使用低级的字节流按照一个一个字节的形式复制文件</li><li>使用低级的字节流按照一个一个字节数组的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li></ul><p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p><hr><h4 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h4><p>字符缓冲输入流：BufferedReader</p><p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p><p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个原始的字符输入流读取源文件</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">    <span class="comment">// 定义一个字符串变量存储每行数据</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">    <span class="comment">//淘汰数组循环读取</span></span><br><span class="line">    <span class="comment">//char[] buffer = new char[1024];</span></span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    <span class="comment">//while((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.println(new String(buffer , 0 , len));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h4><p>符缓冲输出流：BufferedWriter</p><p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code></p><p> 原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p><p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>,<span class="literal">true</span>);<span class="comment">//追加</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    </span><br><span class="line">    bw.write(<span class="string">&quot;我爱学习Java&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//换行</span></span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h4><p>字符型缓冲流高效的原因：（空间换时间）</p><ul><li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li><li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li></ul><p>字节型缓冲流高效的原因：</p><ul><li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li><li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。</li></ul><p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p><hr><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h4><p>字符流读取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码编码            文件编码         中文情况。</span><br><span class="line">UTF-8              UTF-8           不乱码!</span><br><span class="line">GBK                GBK             不乱码!</span><br><span class="line">UTF-8              GBK             乱码!</span><br></pre></td></tr></table></figure><ul><li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li><li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li></ul><hr><h4 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h4><p>字符输入转换流：InputStreamReader</p><p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li><li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.提取GBK文件的原始字节流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\Netty.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        <span class="comment">// 3.包装成缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h4><p>字符输出转换流：OutputStreamWriter</p><p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;我在学习Java&quot;</span>);   </span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 &#x3D;&gt; 文件中</p><p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 &#x3D;&gt; 对象</p><p>transient 关键字修饰的成员变量，将不参与序列化</p><hr><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p><p>作用：把内存中的 Java 对象数据保存到文件中去</p><p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建User用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;seazean&quot;</span>,<span class="string">&quot;980823&quot;</span>,<span class="string">&quot;七十一&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建低级的字节输出流通向目标文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.通过对象字节输出流序列化对象：</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">// 5.释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化对象成功~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">// get+set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化为二进制数据</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(obj);<span class="comment">// 将该对象序列化为二进制数据</span></span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] bytes = bos.toByteArray();</span><br></pre></td></tr></table></figure><hr><h4 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h4><p>对象反序列化（对象字节输入流）：ObjectInputStream</p><p>作用：读取序列化的对象文件恢复到 Java 对象中</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p><p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)ois.readObject();<span class="comment">//反序列化</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流 PrintStream &#x2F; PrintWriter</p><p>打印流的作用：</p><ul><li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li><li>PrintStream&#x2F;PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li><li><strong>System.out.print() 底层基于打印流实现的</strong></li></ul><p>构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><p>System 类：</p><ul><li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        ps.println(任何类型的数据);</span><br><span class="line">        ps.print(不换行);</span><br><span class="line">        ps.write(<span class="string">&quot;我爱你&quot;</span>.getBytes());</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean0==&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/log.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 让系统的输出流向打印流</span></span><br><span class="line"><span class="comment">//不输出在控制台，输出到文件里</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean1==&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean2==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h2><p>try-with-resources：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    <span class="comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span></span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p><p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"><span class="comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （2）创建一个字节输出流与目标文件接通。*/</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （5）关闭资源！是自动进行的 */</span></span><br><span class="line">)&#123;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p><p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p><p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key&#x3D;value</p><p>Properties 方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key, String value)</td><td>设置集合的键和值，底层调用 Hashtable 方法 put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String>   stringPropertyNames()</String></td><td>所有键的名称的集合</td></tr><tr><td>synchronized void load(Reader r)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>synchronized void load(InputStream in)</td><td>加载属性文件的数据到属性集对象中去</td></tr><tr><td>void store(Writer w, String comments)</td><td>将此属性列表(键和元素对)写入 Properties 表</td></tr><tr><td>void store(OutputStream os, String comments)</td><td>保存数据到属性文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.创建一个属性集对象：Properties的对象。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//&#123;&#125;</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span> , <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>);</span><br><span class="line">        properties.store(os,<span class="string">&quot;i am very happy!!我保存了用户数据!&quot;</span>);</span><br><span class="line">        <span class="comment">//参数一：被保存数据的输出管道</span></span><br><span class="line">        <span class="comment">//参数二：保存心得。就是对象保存的数据进行解释说明！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//底层基于map集合</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        </span><br><span class="line">Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(s);</span><br><span class="line">            System.out.println(s + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h2><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p><p>构造器：</p><ul><li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li><li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li></ul><p>常用方法：</p><ul><li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li><li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li><li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    rf.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">    rf.seek(<span class="number">5</span>);<span class="comment">//helloxxxxld</span></span><br><span class="line">    rf.write(<span class="string">&quot;xxxx&quot;</span>.getBytes());</span><br><span class="line">    rf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h2><p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p><p>commons-io 工具包提供了很多有关 IO 操作的类：</p><table><thead><tr><th>包</th><th align="left">功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td align="left">有关 Streams、Readers、Writers、Files 的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td align="left">输入流相关的实现类，包含 Reader 和 InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td align="left">输出流相关的实现类，包含 Writer 和 OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td align="left">序列化相关的类</td></tr></tbody></table><p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.完成文件复制！</span></span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>), </span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.完成文件复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyFileToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片服务器&quot;</span>) ,</span><br><span class="line">                                           <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span></span><br><span class="line">        Files.copy(Paths.get(<span class="string">&quot;Demo/src/books.xml&quot;</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new11.txt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p><p>单元测试：</p><ul><li>单元：在 Java 中，一个类就是一个单元<br>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试</li></ul><p></p><p>Junit 单元测试框架的作用：</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li><li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li></ul><p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p><p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p><ul><li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li><li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li></ul><p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p><ul><li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li><li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li></ul><p>作用：</p><ul><li>开始执行的方法：初始化资源</li><li>执行完之后的方法：释放资源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">     <span class="comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">/**断言预期结果的正确性。</span></span><br><span class="line"><span class="comment">         * 参数一：测试失败的提示信息。</span></span><br><span class="line"><span class="comment">         * 参数二：期望值。</span></span><br><span class="line"><span class="comment">         * 参数三：实际值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="string">&quot;success&quot;</span>,rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.chu(<span class="number">10</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h2><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p><ul><li><p>构造器对象：Constructor</p></li><li><p>成员变量对象：Field</p></li><li><p>成员方法对象：Method</p></li></ul><p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p><p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p><ul><li><code>Class c = HelloWorld.class</code></li></ul><p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p><p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p><p>反射的优点：</p><ul><li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li></ul><p>反射的缺点：</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li><li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li><li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li></ul><hr><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p><ul><li>类名.class</li><li>类的对象.getClass()</li><li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li></ul><p>Class 类下的方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getSimpleName()</td><td>获得类名字符串：类名</td></tr><tr><td>String getName()</td><td>获得类全名：包名+类名</td></tr><tr><td>T newInstance()</td><td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span></span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class _03反射_获取Class类对象.Student</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> swk.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName(&quot;类的全限名&quot;)</span></span><br><span class="line">        <span class="comment">// 直接去加载该类的class文件。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;_03反射_获取Class类对象.Student&quot;</span>);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获取类名本身（简名）Student</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取类的全限名_03反射_获取Class类对象.Student</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h3><p>获取构造器的 API：</p><ul><li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li><li>Constructor getDeclaredConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li><li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li><li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li></ul><p>Constructor 的常用 API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>创建对象，注入构造器需要的数据</td></tr><tr><td>void setAccessible(true)</td><td>修改访问权限，true 攻破权限（暴力反射）</td></tr><tr><td>String getName()</td><td>以字符串形式返回此构造函数的名称</td></tr><tr><td>int getParameterCount()</td><td>返回参数数量</td></tr><tr><td>Class&lt;?&gt;[] getParameterTypes</td><td>返回参数类型数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位全部构造器，只要申明了就可以拿到</span></span><br><span class="line">        Constructor[] cons = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历这些构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor con : cons) &#123;</span><br><span class="line">            System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位某个构造器，根据参数匹配，只要申明了就可以获取</span></span><br><span class="line">        <span class="comment">//Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//有参数的！!</span></span><br><span class="line">        <span class="comment">// c.构造器名称和参数</span></span><br><span class="line">        System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用无参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位无参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// c.暴力打开私有构造器的访问权限</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// d.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(); <span class="comment">// 最终还是调用无参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用有参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位有参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class , <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// c.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>); <span class="comment">// 最终还是调用有参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h3><p>获取 Field 成员变量 API：</p><ul><li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li><li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li><li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li><li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到</li></ul><p>Field 的方法：给成员变量赋值和取值</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td></tr><tr><td>Object get(Object obj)</td><td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td></tr><tr><td>void setAccessible(true)</td><td>暴力反射，设置为可以直接访问私有类型的属性</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回 Class 对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo</span> &#123;</span><br><span class="line">    <span class="comment">//获取全部成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.获取全部申明的成员变量对象</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName()+<span class="string">&quot;-&gt;&quot;</span>+field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某个成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.定位某个成员变量对象 :根据名称定位！！</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(ageF.getName()+<span class="string">&quot;-&gt;&quot;</span>+ageF.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_1</span> <span class="operator">=</span> <span class="string">&quot;宠物学校&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射的第一步获取Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.定位name成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// c.为这个成员变量赋值！</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(d,<span class="string">&quot;泰迪&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;</span></span><br><span class="line">        <span class="comment">// d.获取成员变量的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> name.get(d)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(value);<span class="comment">//泰迪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取 Method 方法 API：</p><ul><li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li><li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li><li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li><li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li></ul><p>Method 常用 API：</p><ul><li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="comment">//获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.获取全部申明的方法!</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历这些方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    + method.getParameterCount()+<span class="string">&quot;-&gt;&quot;</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">// c.触发方法执行!</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> run.invoke(d);</span><br><span class="line">        System.out.println(o);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力反射！</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//参数一：被触发方法所在的对象  参数二：方法需要的入参值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> eat.invoke(d,<span class="string">&quot;肉&quot;</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span>&#123;System.out.println(<span class="string">&quot;狗吃&quot;</span>+name);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;在吉山区有一只单身狗！&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h2><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p><ol><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        scores.add(<span class="number">99.3</span>);</span><br><span class="line">        scores.add(<span class="number">199.3</span>);</span><br><span class="line">        scores.add(<span class="number">89.5</span>);</span><br><span class="line">        <span class="comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span></span><br><span class="line">        <span class="comment">// a.先得到集合对象的Class文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> scores.getClass();</span><br><span class="line">        <span class="comment">// b.从ArrayList的Class对象中定位add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        <span class="comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span></span><br><span class="line">        add.invoke(scores, <span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">        System.out.println(scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p><ul><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li><li><strong>父类中的注解是不能被子类继承的</strong></li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><hr><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">     <span class="comment">// 注解属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解的格式：@注解名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Book</span></span><br><span class="line"><span class="meta">@MyTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBook</span> &#123;</span><br><span class="line">    <span class="comment">//方法变量都可以注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h2><h3 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h3><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p><p>属性的格式：</p><ul><li>格式 1：数据类型 属性名()</li><li>格式 2：数据类型 属性名() default 默认值</li></ul><p>属性适用的数据类型:</p><ul><li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li><li>以上类型的数组形式都支持</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span> &#123;</span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span></span><br><span class="line"><span class="meta">     price = 19.9 , address = &quot;北京&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义一个注解</span></span><br><span class="line"><span class="meta">@interface</span> MyBook&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String[] authors(); <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;武汉&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p>注解的特殊属性名称：value</p><ul><li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li><li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Book(&quot;/deleteBook.action&quot;)</span></span><br><span class="line"><span class="meta">@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是 sun 公司提供的，用来注解自定义注解</p><p>元注解有四个：</p><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">    <span class="comment">// @MyTest // 只能注解方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 申明只能注解方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 申明注解从写代码一直到运行还在，永远存活！！</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>注解解析相关的接口：</p><ul><li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li><li>AnnotatedElement：该接口定义了与注解解析相关的方法</li><li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li></ul><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定位Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// 2.判断这个类上是否使用了某个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="comment">// 3.获取这个注解对象</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)c.getDeclarAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.authors()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)run.getDeclaredAnnotation(Book.class);</span><br><span class="line">           sout(上面的三个);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;张三&quot;,&quot;李四&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line">    <span class="meta">@Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;王五&quot;,&quot;小六&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">// 类和成员方法上使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解永久存活</span></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] authors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础(全)</title>
      <link href="/2023/03/04/Java/java/"/>
      <url>/2023/03/04/Java/java/</url>
      
        <content type="html"><![CDATA[<h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table><thead><tr><th align="center"></th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中，方法外</td><td align="center">方法中或者方法的形参</td><td align="center">在类中，方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无，赋值后才能使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方法</td><td align="center">对象调用</td><td align="center"></td><td align="center">对象调用，类名调用</td></tr><tr><td align="center">存储位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区（JDK8 以后移到堆中）</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center"></td><td align="center">类变量，静态成员变量</td></tr></tbody></table><p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p><p><a href="https://www.bilibili.com/video/BV1TE41177m">参考视频</a></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li><li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li><li>默认值是 <code>0</code></li><li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li><li>例子：<code>byte a = 100，byte b = -50</code></li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li><li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li><li>默认值是 <code>0</code></li><li>例子：<code>short s = 1000，short r = -20000</code></li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li><li>一般地整型变量默认为 int 类型</li><li>默认值是 <code>0</code></li><li>例子：<code>int a = 100000, int b = -200000</code></li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li><li>这种类型主要使用在需要比较大整数的系统上</li><li>默认值是 <code> 0L</code></li><li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li><li>float 在储存大型浮点数组的时候可节省内存空间</li><li>默认值是 <code>0.0f</code></li><li>浮点数不能用来表示精确的值，如货币</li><li>例子：<code>float f1 = 234.5F</code></li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li><li>浮点数的默认类型为 double 类型</li><li>double 类型同样不能表示精确的值，如货币</li><li>默认值是 <code>0.0d</code></li><li>例子：<code>double d1 = 123.4</code></li></ul><p><strong>boolean：</strong></p><ul><li>boolean 数据类型表示一位的信息</li><li>只有两个取值：true 和 false</li><li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li><li>默认值是 <code>false</code></li><li>例子：<code>boolean one = true</code></li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li><li>最小值是 <code>\u0000</code>（即为 0）</li><li>最大值是 <code>\uffff</code>（即为 65535）</li><li>char 数据类型可以<strong>存储任何字符</strong></li><li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li></ul><h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul><li><p>float 与 double：</p><p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//1.1f 字面量才是 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> (<span class="type">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1245</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (<span class="type">int</span>) l2;</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换：</p><p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p><p>使用 +&#x3D; 或者 ++ 运算符会执行类型转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;<span class="comment">//s1++;</span></span><br><span class="line"><span class="comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span></span><br><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p><p>包装类的作用：</p><ul><li>包装类作为类首先拥有了 Object 类的方法</li><li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）</span><br><span class="line"><span class="type">byte</span>                      Byte</span><br><span class="line"><span class="type">short</span>                     Short</span><br><span class="line"><span class="type">int</span>                       Integer</span><br><span class="line"><span class="type">long</span>                      Long</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>                     Float</span><br><span class="line"><span class="type">double</span>                    Double</span><br><span class="line"><span class="type">char</span>                      Character</span><br><span class="line"><span class="type">boolean</span>                   Boolean</span><br></pre></td></tr></table></figure><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p><ul><li><p>可以把基本数据类型的值转换成字符串类型的值</p><ol><li>调用 toString() 方法</li><li>调用 Integer.toString(基本数据类型的值) 得到字符串</li><li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li></ol></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p><ol><li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li><li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClass02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.把基本数据类型的值转成字符串</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="comment">// a.调用toString()方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr</span> <span class="operator">=</span> it.toString();</span><br><span class="line">        System.out.println(itStr+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr1</span> <span class="operator">=</span> Integer.toString(it);</span><br><span class="line">        System.out.println(itStr1+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr2</span> <span class="operator">=</span> it + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(itStr2+<span class="number">1</span>);<span class="comment">// 1001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.valueOf(numStr);</span><br><span class="line">        System.out.println(numInt+<span class="number">1</span>);<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">doubleStr</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleDb</span> <span class="operator">=</span> Double.valueOf(doubleStr);</span><br><span class="line">        System.out.println(doubleDb+<span class="number">0.1</span>);<span class="comment">//100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul><li><p>有了基本数据类型，为什么还要引用数据类型？</p><blockquote><p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p><p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p></blockquote></li><li><p>引用数据类型那么好，为什么还用基本数据类型？</p><blockquote><p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p></blockquote></li><li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p><blockquote><p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p></blockquote></li><li><p>&#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值<br>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</p></blockquote></li></ul><h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p><p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackegeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">12</span> ;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> a ;   <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 引用数据类型的默认值可以为null</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c ;      <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(<span class="number">12</span>);  <span class="comment">// 手工装箱！</span></span><br><span class="line">        <span class="comment">// Integer it1 = new Integer(12); // 手工装箱！</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="number">111</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it33</span> <span class="operator">=</span> it3.intValue(); <span class="comment">// 手工拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 【缓存池】，本质上是一个数组</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li><p>new Integer(123)：每次都会新建一个对象</p></li><li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><p><strong>基本类型对应的缓存池如下：</strong></p><ul><li>Boolean values true and false</li><li>all byte values</li><li>Short values between -128 and 127</li><li>Long values between -128 and 127</li><li>Integer values between -128 and 127</li><li>Character in the range \u0000 to \u007F (0 and 127)</li></ul><p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 自动装箱，底层调用 Integer.valueOf(1)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// false，因为缓存池最大127</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p><ul><li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li><li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li></ul><p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p><ul><li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li><li>print：<code>PrintStream.write()</code></li></ul><blockquote><p>使用引用数据类型的API</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p><p>创建数组：</p><ul><li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li><li>数据类型 数组名[]：<code>int arr[]</code></li></ul><p>静态初始化：</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li><li>数据类型[] 数组名 &#x3D; {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li></ul><p>动态初始化</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li></ul><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul><li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p></li><li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p></li><li><p><strong>赋值：</strong><code>arr[0] = 10</code></p></li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给 CPU 使用</td></tr><tr><td>本地方法栈</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区</td><td>存储可以运行的 class 文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new 来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td></tr></tbody></table><p>内存分配图：<strong>Java 数组分配在堆内存</strong></p><ul><li><p>一个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>两个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>多个数组指向相同内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4></li><li><p>索引越界异常：ArrayIndexOutOfBoundsException </p></li><li><p>空指针异常：NullPointerException </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p><p>解决方案：给数组一个真正的堆内存空间引用即可</p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4></li></ul><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p><p>初始化：</p><ul><li><p>动态初始化：<code>数据类型[][] 变量名 = new 数据类型[m][n]</code>，<code>int[][] arr = new int[3][3]</code></p><ul><li>m 表示这个二维数组，可以存放多少个一维数组，行</li><li>n 表示每一个一维数组，可以存放多少个元素，列</li></ul></li><li><p>静态初始化:<code>数据类型[][] 变量名 = new 数据类型[m][n]&#123;&#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125;&#125; </code></p><ul><li><code>数据类型[][] 变量名 = &#123;&#123;元素1, 元素2...&#125;, &#123;元素1, 元素2...&#125;...&#125;`  * `int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li></ul></li></ul><p>遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        步骤:</span></span><br><span class="line"><span class="comment">            1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line"><span class="comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(arr[i]);</span></span><br><span class="line">            <span class="comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line">            <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>i++ 与 ++i 的区别？</p><p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p></li><li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p><p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p><p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p></li><li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p></li><li><p>同或：两位相同为 1，相异为 0</p></li><li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p></li><li><p>break：跳出一层循环</p></li><li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p><ul><li><p>正数的原码反码补码相同，最高位为 0</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure></li><li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">100</span> 原码:<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span><span class="comment">//32位</span></span><br><span class="line">-<span class="number">100</span> 反码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011011</span></span><br><span class="line">-<span class="number">100</span> 补码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011100</span></span><br></pre></td></tr></table></figure><p>补码 → 原码：符号位不变，其余位置取反加 1</p></li></ul><p>运算符：</p><ul><li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li><li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li><li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li></ul><p>运算规则：</p><ul><li><p>正数的左移与右移，空位补 0</p></li><li><p>负数原码的左移与右移，空位补 0</p><p>负数反码的左移与右移，空位补 1</p><p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p></li><li><p>无符号移位，空位补 0</p></li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p><ul><li>形式参数，用于定义方法的时候使用的参数，只能是变量</li><li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li></ul><p>实参：调用方法时传递的数据可以是常量，也可以是变量</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p><p>格式：数据类型… 参数名称</p><p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p><p>可变参数的注意事项：</p><ul><li>一个形参列表中可变参数只能有一个</li><li>可变参数必须放在形参列表的<strong>最后面</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">sum(); <span class="comment">// 可以不传输参数。</span></span><br><span class="line">sum(<span class="number">10</span>); <span class="comment">// 可以传输一个参数。</span></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 可以传输多个参数。</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">90</span>&#125;); <span class="comment">// 可以传输一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p><p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p><p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p><h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line"><span class="comment">//方法体;</span></span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 (参数) ;</span><br></pre></td></tr></table></figure><ul><li>方法名：调用方法时候使用的标识</li><li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li><li>方法体：完成功能的代码块</li><li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li></ul><p>如果方法操作完毕</p><ul><li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li><li>非 void 类型的方法，推荐用变量接收调用</li></ul><p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>方法不能嵌套定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p><ol><li>多个方法在<strong>同一个类</strong>中</li><li>多个方法具有<strong>相同的方法名</strong></li><li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li></ol><p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p><p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p><p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">/*正确格式*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ul><li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li><li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li><li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li></ul><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法，选取的第二阶段</span></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span></span><br><span class="line">    </span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span></span><br><span class="line">       <span class="comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此不提倡可变长参数方法的重载</strong></p><h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p><ul><li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li><li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p><p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p><ul><li><p>基本数据类型：形式参数的改变，不影响实际参数</p><p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">change(number);</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">number = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型：形式参数的改变，影响实际参数的值</p><p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p><p>定义枚举的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">第一行都是罗列枚举实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的特点：</p><ul><li>枚举类是用 final 修饰的，枚举类不能被继承</li><li>枚举类默认继承了 java.lang.Enum 枚举类</li><li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li><li>枚举类相当于是多例设计模式</li><li>每个枚举项都是一个实例，是一个静态成员变量</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E  o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <T> T  valueOf(Class<T> type,String  name)</T></T></td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类的编译以后源代码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Season&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season[] values();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>API 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        <span class="type">Season</span> <span class="variable">s</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(s);<span class="comment">//SPRING</span></span><br><span class="line">        System.out.println(s.ordinal()); <span class="comment">// 0，该值代表索引，summer 就是 1</span></span><br><span class="line">        s.s.doSomething();</span><br><span class="line">        <span class="comment">// 获取全部枚举</span></span><br><span class="line">        Season[] ss = Season.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Season.SPRING.compareTo(Season.WINTER);</span><br><span class="line">        System.out.println(result);<span class="comment">//-3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p><p>面向对象三大特征：<strong>封装，继承，多态</strong></p><p>两个概念：类和对象</p><ul><li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li><li>对象：是真实存在的实例， 实例 &#x3D;&#x3D; 对象，<strong>对象是类的实例化</strong></li><li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li><li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li><li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分</span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line"><span class="number">1.</span>成员变量(Field):  描述类或者对象的属性信息的。</span><br><span class="line">        <span class="number">2.</span>成员方法(Method):描述类或者对象的行为信息的。</span><br><span class="line"><span class="number">3.</span>构造器(Constructor): 初始化一个对象返回。</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">  &#125;</span><br><span class="line">类中有且仅有这五种成分，否则代码报错！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：初始化类的一个对象返回</p><p>分类：无参数构造器，有参数构造器</p><p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p><p>构造器初始化对象的格式：类名 对象名称 &#x3D; new 构造器</p><ul><li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li><li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li></ul><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p><p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p><p>导包格式：<code>import 包名.类名</code></p><p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p><p>封装最初的目的：提高代码的安全性和复用性，组件化</p><p>封装的步骤：</p><ol><li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li><li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li></ol><p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p><ul><li>this 关键字代表了当前对象的引用</li><li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li><li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li><li>this 可以区分变量是访问的成员变量还是局部变量</li></ul><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p><p>按照有无 static 修饰，成员变量和方法可以分为：</p><ul><li><p>成员变量：</p><ul><li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li><li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li></ul></li><li><p>成员方法：</p><ul><li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li><li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li></ul></li></ul><h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p><ul><li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p><ul><li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li><li>对象.静态成员变量（不推荐）</li></ul></li><li><p>实例成员变量：</p><ul><li>对象.实例成员变量（先创建对象）</li></ul></li></ul><p>成员方法的访问语法：</p><ul><li><p>静态方法：有 static 修饰，属于类</p><ul><li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li><li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li></ul></li><li><p>实例方法：无 static 修饰，属于对象</p><ul><li>对象.实例方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// a.类名.静态方法</span></span><br><span class="line">        Student.inAddr();</span><br><span class="line">        inAddr();</span><br><span class="line">        <span class="comment">// b.对象.实例方法</span></span><br><span class="line">        <span class="comment">// Student.eat(); // 报错了！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        sea.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>访问问题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li><li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li><li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li><li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li><li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li><li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p><ul><li>被继承的类称为：父类&#x2F;超类</li><li>继承父类的类称为：子类</li></ul><p>继承的作用：</p><ul><li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li><li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li><li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li></ul><p>继承的特点：</p><ol><li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li><li><strong>单继承</strong>：一个类只能继承一个直接父类</li><li>多层继承：一个类可以间接继承多个父类（家谱）</li><li>一个类可以有多个子类</li><li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li></ol><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类不能继承父类的东西：</p><ul><li>子类不能继承父类的构造器，子类有自己的构造器</li><li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li><li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// c.run();</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        System.out.println(Cat.schoolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span><span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p><p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wmain</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();w</span><br><span class="line">        w.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类狼&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部name</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类对象的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的</span></span><br><span class="line">        System.out.println(name1); <span class="comment">// 父类的</span></span><br><span class="line">        <span class="comment">//System.out.println(name2); // 报错。子类父类都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类动物名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;父类&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p><p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p><p>方法重写的校验注解：@Override</p><ul><li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li><li>@Override 优势：可读性好，安全，优雅</li></ul><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul><p>继承中的隐藏问题：</p><ul><li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li><li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        w.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>为什么子类构造器会先调用父类构造器？</p><ol><li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li><li>参考 JVM → 类加载 → 对象创建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的有参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么 Java 是单继承的？</strong></p><p>答：反证法，假如 Java 可以多继承，请看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> , B &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.test(); </span><br><span class="line">        <span class="comment">// 出现了类的二义性！所以Java不能多继承！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p><p>总结与拓展：</p><ul><li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li><li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li></ul><p>注意：</p><ul><li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li><li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li><li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;天蓬元帅&quot;</span>, <span class="number">1000</span> );</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;齐天大圣&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;清华大学&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Study</span> <span class="keyword">extends</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Study</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age , schoolName) ; </span><br><span class="line">       <span class="comment">// 根据参数匹配调用父类构造器</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String schoolName ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 借用兄弟构造器的功能！</span></span><br><span class="line">        <span class="built_in">this</span>(name , age , <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......get + set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p><ul><li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li><li>final 可以修饰方法，方法就不能被重写</li><li>final 修饰变量总规则：变量有且仅能被赋值一次</li></ul><p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p><p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p><p>final 修饰静态成员变量可以在哪些地方赋值：</p><ol><li><p>定义的时候赋值一次</p></li><li><p>可以在静态代码块中赋值一次</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line"><span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span></span><br><span class="line">        SCHOOL_NAME1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p><p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p><ol><li>定义的时候赋值一次</li><li>可以在实例代码块中赋值一次</li><li>可以在每个构造器中赋值一次</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在实例代码块中赋值一次。</span></span><br><span class="line">        name1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造器赋值一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalDemo</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalDemo</span>();</span><br><span class="line">        <span class="comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p></blockquote><p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p><p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p><p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;🐕跑&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p><ul><li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li><li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li></ul><blockquote><p>抽象在学术上本身意味着不能实例化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！</span></span><br><span class="line">        <span class="comment">//a.run(); // 抽象方法不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、static 与 abstract 能同时使用吗？</p><p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p><p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作文模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoMa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaoMa.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeText</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;\t内容&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.写一个模板类：代表了作文模板。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;\t\t\t\t\t标题&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;\t开头&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;\t结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(title+<span class="string">&quot;\n&quot;</span>+start);</span><br><span class="line">        System.out.println(writeText());</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正文部分定义成抽象方法，交给子类重写！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">writeText</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p><p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 修饰符 interface 接口名称&#123;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p></li><li><p>静态方法：静态方法必须有方法体</p></li><li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//默认补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p><ul><li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li><li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li><li>接口与接口继承关系：<strong>多继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">修饰符 interface 接口名 extend 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多个接口的使用注意事项：</p><ol><li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p></li><li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p></li><li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p></li><li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.run();</span><br><span class="line">        s.rule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Food</span>, Person&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以直接 interface Person extend Food,</span></span><br><span class="line"><span class="comment">//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p><ul><li>默认方法（就是普通实例方法）<ul><li>必须用 default 修饰，默认会 public 修饰</li><li>必须用接口的实现类的对象来调用</li><li>必须有默认实现</li></ul></li><li>静态方法<ul><li>默认会 public 修饰</li><li>接口的静态方法必须用接口的类名本身来调用</li><li>调用格式：ClassName.method()</li><li>必须有默认实现</li></ul></li><li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        m.run();</span><br><span class="line">        m.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span></span><br><span class="line">        InterfaceJDK8.inAddr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法！！</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// a.默认方法（就是之前写的普通实例方法）</span></span><br><span class="line">    <span class="comment">// 必须用接口的实现类的对象来调用。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始跑步🏃‍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.静态方法</span></span><br><span class="line">    <span class="comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们在武汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span></span><br><span class="line">    <span class="comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>默认的方法实现</td><td>可以有默认的方法实现</td><td>接口完全是抽象的，jdk8 以后有默认的实现</td></tr><tr><td>实现</td><td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常Java类的区别</td><td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td><td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td></tr><tr><td>main方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口可以继承一个或多个其它接口，接口不可继承类</td></tr><tr><td>速度</td><td>比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td></tr><tr><td>添加新方法</td><td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td><td>如果往接口中添加方法，那么必须改变实现该接口的类</td></tr></tbody></table><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p><p>多态的格式：</p><ul><li>父类类型范围 &gt; 子类类型范围</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p>多态的执行：</p><ul><li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li><li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li></ul><p>多态的使用规则：</p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>存在方法重写</li></ul><p>多态的优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li><li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li></ul><p>多态的劣势： </p><ul><li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.run();</span><br><span class="line">        <span class="comment">//c.eat();//报错  编译看左边 需要强转</span></span><br><span class="line">        go(c);</span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Dog</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal d)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote><p>基本数据类型的转换：</p><ol><li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li><li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li></ol></blockquote><p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p><p><strong>父类引用指向子类对象</strong></p><ul><li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li><li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;<span class="comment">// 向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p><ul><li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li><li>强制类型转换的格式：<strong>类型 变量名称 &#x3D; (类型)(对象或者变量)</strong></li><li>有继承&#x2F;实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Dog d = (Dog)a;</span></span><br><span class="line">        <span class="comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p><p>概念：定义在一个类里面的类就是内部类</p><p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p><p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p><p>静态内部类中的成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>特点与外部类是完全一样的，只是位置在别人里面</li><li>可以定义静态成员</li></ul><p>静态内部类的访问格式：外部类名称.内部类名称</p><p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称.内部类构造器</p><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?可以，外部类的静态成员只有一份，可以被共享<br>   静态内部类中是否可以直接访问外部类的实例成员?不可以，外部类的成员必须用外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量</span></span><br><span class="line">         System.out.println(age);</span><br><span class="line">         <span class="comment">//System.out.println(salary);报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p><p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p><p>实例内部类的访问格式：外部类名称.内部类名称</p><p>创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类构造器.new 内部构造器</p><ul><li><code>Outter.Inner in = new Outter().new Inner()</code></li></ul><p><strong>实例内部类可以访问外部类的全部成员</strong></p><ul><li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li><li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p><p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        class&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;</span><br><span class="line"><span class="comment">//方法重写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类不能定义静态成员</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li><li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);</span><br><span class="line">                <span class="comment">//System.out.println(n);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.run();</span><br><span class="line">        a.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始go~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p><table><thead><tr><th>四种修饰符访问权限</th><th align="center">private</th><th align="center">缺省</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下的子类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下其他类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的子类中</td><td align="center">X</td><td align="center">X</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的其他类中</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">√</td></tr></tbody></table><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见</li><li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代码块特点： <ul><li>必须有 static 修饰，只能访问静态资源</li><li>会与类一起优先加载，且自动触发执行一次</li></ul></li><li>静态代码块作用：<ul><li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li><li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块,属于类，与类一起加载一次!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">// 在静态代码块中进行静态资源的初始化操作</span></span><br><span class="line">        schoolName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法被执行&quot;</span>);</span><br><span class="line">        System.out.println(schoolName);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块被触发执行~~~~~~~</span></span><br><span class="line"><span class="comment">main方法被执行</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">[3, 4, 5] */</span></span><br></pre></td></tr></table></figure><h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例代码块的特点：</p><ul><li>无 static 修饰，属于对象</li><li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li></ul></li><li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;代码块&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">()</span>&#123; &#125;<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeDemo</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">        System.out.println(c.name);</span><br><span class="line">        System.out.println(c.lists);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeDemo02</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p><p>Object 类常用方法：</p><ul><li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul><li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li><li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li></ul></li><li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li><li><code>protected Object clone()</code>：创建并返回此对象的副本</li></ul><p>只要两个对象的内容一样，就认为是相等的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">           sex == student.sex &amp;&amp;</span><br><span class="line">           Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：&#x3D;&#x3D; 和 equals 的区别</p><ul><li>&#x3D;&#x3D; 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li><li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li></ul><p>hashCode 的作用：</p><ul><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li><li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li></ul><h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p><p>深浅拷贝（克隆）的概念：</p><ul><li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p><p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p></li><li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p></li></ul><p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p><ul><li><p>Clone &amp; Copy：<code>Student s = new Student</code></p><p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p><p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p></li><li><p>Shallow Clone &amp; Deep Clone：</p><p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p><ul><li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li><li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p><p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        s.date = (Date) date.clone();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>SDP → 创建型 → 原型模式</p><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p><p>Objects 的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line"><span class="comment">// 进行非空判断，从而可以避免空指针异常</span></span><br><span class="line"><span class="keyword">return</span> a == b || a != <span class="literal">null</span> &amp;&amp; a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* `public static boolean isNull(Object obj)`：判断变量是否为 null ，为 null 返回 true</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象)`：返回参数中对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象, 默认字符串)`：返回对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class ObjectsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = null;</span><br><span class="line">        Student s2 = new Student();</span><br><span class="line">        System.out.println(Objects.equals(s1 , s2));//推荐使用</span><br><span class="line">        // System.out.println(s1.equals(s2)); // 空指针异常</span><br><span class="line"> </span><br><span class="line">        System.out.println(Objects.isNull(s1));</span><br><span class="line">        System.out.println(s1 == null);//直接判断比较好</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p><p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p><ul><li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p></li><li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p></li><li><p><code>public int length()</code>：返回此字符串的长度</p></li><li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p></li><li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p></li><li><p><code>public char charAt(int index)</code>：取索引处的值</p></li><li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p></li><li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p></li><li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p></li><li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p></li><li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p></li><li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p></li><li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p></li><li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>-<span class="number">78</span>;</span><br><span class="line">s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p><ul><li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li><li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li><li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li></ul><p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p><ul><li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li><li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li></ul><p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p><ul><li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li><li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;"></li></ul><p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p><ul><li><p>对象 1：new StringBuilder()</p></li><li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p></li><li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;"></li><li><p>StringBuilder 的 toString()：</p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 6：new String(“ab”)</li><li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li></ul><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool &#x2F; StringTable &#x2F; 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p><ul><li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li><li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li><li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li><li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li></ul><h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p><ul><li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li><li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li></ul><p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 串池</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">// 返回的是堆内地址</span></span><br><span class="line">        <span class="comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        <span class="comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值</li><li>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</li></ul><p>结论：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 仅放入串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">// 仅放入堆</span></span><br><span class="line"><span class="comment">// 上面两条指令的结果和下面的 效果 相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2 == str2.intern());<span class="comment">//false，字符串池中存在，直接返回已经存在的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">launcher_name</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_name</span> <span class="operator">=</span> <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_profile_name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221-b11&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p><p>演示 StringTable 位置：</p><ul><li><p><code>-Xmx10m</code> 设置堆内存 10m</p></li><li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p></li><li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(j).intern());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p><h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p><ul><li><p>调整 -XX:StringTableSize&#x3D;桶个数，数量越少，性能越差</p></li><li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//很多数据</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul><li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li><li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li><li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li><li>防止子类继承，破坏 String 的 API 的使用</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p><ul><li>String : <strong>不可变</strong>的字符序列，线程安全</li><li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li><li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li></ul><p>相同点：底层使用 char[] 存储</p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li><li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li></ul><p>常用API : </p><ul><li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li><li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li><li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li></ul><p>存储原理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//new byte[16] </span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure><p>append 源码：扩容为二倍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span></span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到目标字符数组中</span></span><br><span class="line"><span class="comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p><p>常用API：</p><ul><li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li><li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li><li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//按照数字顺序排列指定的数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//1,数组必须有序</span></span><br><span class="line">        <span class="comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span></span><br><span class="line">        <span class="comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span></span><br><span class="line">            <span class="comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p><p>使用步骤：</p><ol><li><p>导入包：<code>import java.util.Random</code></p></li><li><p>创建对象：<code>Random r = new Random()</code></p></li><li><p>随机整数：<code>int num = r.nextInt(10)</code></p><ul><li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li><li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li></ul></li><li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p></li></ol><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p><p>静态方法：</p><ul><li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p></li><li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p></li><li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p><ul><li>参数一：原数组</li><li>参数二：从原数组的哪个位置开始赋值</li><li>参数三：目标数组</li><li>参数四：从目标数组的哪个位置开始赋值</li><li>参数五：赋值几个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.exit(0); // 0代表正常终止!!</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//定义sdf 按照格式输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">System.out.println( (endTime - startTime)/<span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);<span class="comment">//程序用时</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> ,<span class="number">60</span> ,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span></span><br><span class="line">        <span class="comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">2</span>, arr2, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p><ul><li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li></ul><p>方法：</p><ul><li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li></ul><p>时间记录的两种方式：</p><ol><li>Date 日期对象</li><li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s &#x3D; 1000ms</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + <span class="number">121</span>*<span class="number">1000</span>;<span class="comment">//过121s是什么时间</span></span><br><span class="line">        System.out.println(time);<span class="comment">//1602856875485</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d1);<span class="comment">//Fri Oct 16 22:01:15 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="comment">//运行一万次输出需要多长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p><ol><li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li><li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li></ol><p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p><p>SimpleDateFormat  简单日期格式化类：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li><li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li><li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li><li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li></ul><blockquote><p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);</span></span><br><span class="line"><span class="string">    String time = sdf.format(date);</span></span><br><span class="line"><span class="string">    System.out.println(time);//2020-10-18 19:58:34</span></span><br><span class="line"><span class="string">    //过121s后是什么时间</span></span><br><span class="line"><span class="string">    long time = date.getTime();</span></span><br><span class="line"><span class="string">    time+=121;</span></span><br><span class="line"><span class="string">    System.out.println(sdf.formate(time));</span></span><br><span class="line"><span class="string">    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致</span></span><br><span class="line"><span class="string">    Date newDate = sdf.parse(d);</span></span><br><span class="line"><span class="string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p><p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p><p>Calendar 的方法：</p><ul><li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li><li><code>public int get(int field)</code>：取日期中的某个字段信息</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li><li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li><li><code>public final Date getTime()</code>：拿到此刻日期对象</li><li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInsance(); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> rightNow.get(Calendar.YEAR);<span class="comment">//获取年</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> rightNow.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月要+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    rightNow.set(Calendar.YEAR , <span class="number">2099</span>);<span class="comment">//修改某个字段</span></span><br><span class="line">    rightNow.add(Calendar.HOUR , <span class="number">15</span>);<span class="comment">//加15小时  -15就是减去15小时</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> rightNow.getTime();<span class="comment">//日历对象</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rightNow.getTimeInMillis();<span class="comment">//时间毫秒值</span></span><br><span class="line">    <span class="comment">//700天后是什么日子</span></span><br><span class="line">    rightNow.add(Calendar.DAY_OF_YEAR , <span class="number">701</span>);</span><br><span class="line">    Date <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(sdf.format(d));<span class="comment">//输出700天后的日期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p><ul><li>LocalDate       表示日期（年月日）  </li><li>LocalTime       表示时间（时分秒）</li><li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li></ul><p>构造方法：</p><ul><li>public static LocalDateTime now()：获取当前系统时间 </li><li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li></ul><p>常用API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中的第几天（1-31）</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中的第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr><tr><td>public LocalDate  toLocalDate()</td><td>转换成为一个 LocalDate 对象（年月日）</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成为一个 LocalTime 对象（时分秒）</td></tr><tr><td>public String format(指定格式)</td><td>把一个 LocalDateTime 格式化成为一个字符串</td></tr><tr><td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td><td>把一个日期字符串解析成为一个 LocalDateTime 对象</td></tr><tr><td>public static DateTimeFormatter ofPattern(String pattern)</td><td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> localDateTime.format(pattern);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(s, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears (long years)</td><td>添加或者减去年</td></tr><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年</td></tr></tbody></table><p><strong>时间间隔</strong> Duration 类API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public int getYears()</td><td>获得这段时间的年数</td></tr><tr><td>public int getMonths()</td><td>获得此期间的总月数</td></tr><tr><td>public int getDays()</td><td>获得此期间的天数</td></tr><tr><td>public long toTotalMonths()</td><td>获取此期间的总月数</td></tr><tr><td>public static Durationbetween(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public long toSeconds()</td><td>获得此时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获得此时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获得此时间间隔的纳秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate2);</span><br><span class="line">        System.out.println(period);<span class="comment">//P28Y11M11D</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime2);</span><br><span class="line">        System.out.println(duration);<span class="comment">//PT21H57M58S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p><p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取 a 的 b 次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td>public static int max(int a,int b)</td><td>返回较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回较小值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数。</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">4.00000001</span>));<span class="comment">//4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">4.99999999</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">    <span class="comment">//取一位整数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//取一位整数和两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">    <span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">    <span class="comment">//取所有整数部分</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">    <span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));<span class="comment">//2.99792E8</span></span><br><span class="line">    <span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));<span class="comment">//29.9792E7</span></span><br><span class="line">    <span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));<span class="comment">//299,792,458</span></span><br><span class="line">    <span class="comment">//将格式嵌入文本</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p><p>构造方法：</p><ul><li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li><li><code>public BigDecimal(double val)</code></li><li><code>public BigDecimal(String val)</code></li></ul><p>常用API：</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li><li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li><li><code>public int intValue()</code>：转为 int 其他类型相同</li><li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span></span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b ;</span><br><span class="line">        System.out.println(c);<span class="comment">//0.30000000000000004</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把浮点数转换成大数据对象运算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//a1.divide(b1);也可以</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>BigDecimal 是用来进行精确计算的</li><li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li><li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line"><span class="comment">//参数1：表示参与运算的BigDecimal 对象。</span></span><br><span class="line"><span class="comment">//参数2：表示小数点后面精确到多少位</span></span><br><span class="line"><span class="comment">//参数3：舍入模式  </span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_UP  进一法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_FLOOR 去尾法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p><p>比如检验 qq 号：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQRegex</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq!=<span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数</span></span><br><span class="line">&#125;<span class="comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 \ 本身</td></tr><tr><td>()</td><td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td></tr></tbody></table><h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td></tr><tr><td>\d</td><td>数字字符，0~9 中的任意一个，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于  [ ^0-9]</td></tr><tr><td>\w</td><td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td></tr><tr><td>\W</td><td>对\w取非，等价于[ ^\w]</td></tr><tr><td>\s</td><td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p><h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td></tr><tr><td>[a-d[m-p]]</td><td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td></tr><tr><td>[a-z&amp;&amp;[m-p]]</td><td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td></tr><tr><td>[^]</td><td>取反</td></tr></tbody></table><ul><li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p></li><li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p></li></ul><h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li><li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li></ul><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>X?</td><td>X 一次或一次也没，有相当于 {0,1}</td></tr><tr><td>X*</td><td>X 不出现或出现任意次，相当于 {0,}</td></tr><tr><td>X+</td><td>X 至少一次，相当于 {1,}</td></tr><tr><td>X{n}</td><td>X 恰好 n 次</td></tr><tr><td>{n,}</td><td>X 至少 n 次</td></tr><tr><td>{n,m}</td><td>X 至少 n 次，但是不超过 m 次</td></tr></tbody></table><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr></tbody></table><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p><ul><li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li><li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li></ul><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|  (分支结构)</td><td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td></tr><tr><td>()  (捕获组)</td><td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression)   非捕获组</td><td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td></tr></tbody></table><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p><ul><li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p></li><li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p></li><li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p></li><li><p>应用 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li><li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li><li>实例：43438n44</li></ul></li><li><p>应用 2：爬虫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//不匹配</span><br></pre></td></tr></table></figure></li></ul><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p><ul><li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p></li><li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p></li><li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>(?&#x3D;exp)</td><td>断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td>(?&lt;&#x3D;exp)</td><td>断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td>(?!exp)</td><td>断言此位置的后面不能匹配表达式exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言此位置的前面不能匹配表达式exp</td></tr></tbody></table></li></ul><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p><ul><li>IGNORECASE 忽略大小写模式<ul><li>匹配时忽略大小写。</li><li>默认情况下，正则表达式是要区分大小写的。</li></ul></li><li>SINGLELINE 单行模式<ul><li>整个文本看作一个字符串，只有一个开头，一个结尾。</li><li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li></ul></li><li>MULTILINE 多行模式<ul><li>每行都是一个字符串，都有开头和结尾。</li><li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li></ul></li></ul><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p><ul><li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li><li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li><li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li></ul><p>Matcher 类：</p><ul><li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li><li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li><li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li><li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);</span><br><span class="line"><span class="comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span></span><br><span class="line"><span class="comment">//System.out.println(b);//false</span></span><br><span class="line"><span class="comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line"><span class="comment">//System.out.println(b2);//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//asfsdf2</span></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//3323</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//group(),group(0)匹配整个表达式的子字符串</span></span><br><span class="line">System.out.println(m.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="comment">//不需要加多余的括号</span></span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aa232**ssd445&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">1</span>));<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">2</span>));<span class="comment">//aa     ssd</span></span><br><span class="line">            System.out.println(m.group(<span class="number">3</span>));<span class="comment">//232    445 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li><li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false 判断a是否在abc之外的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false 是否a是整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true 是否是字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));<span class="comment">//false 只能检验单个字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 验证。必须是数字和字符  必须是4位</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dsd22&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;A3dy&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机号码格式正确！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;.......&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1111@qq.com  zhy@pic.com.cn</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱格式正确！&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// .是任意字符 \\.就是点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li><li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 1.split的基础用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line"><span class="comment">// 以“，”分割成字符串数组</span></span><br><span class="line">    String[] nameArrs = names.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.split集合正则表达式做分割</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> <span class="string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;</span><br><span class="line">    <span class="comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span></span><br><span class="line">String[] nameArrs1 = names1.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用正则表达式定位出内容，替换成/</span></span><br><span class="line">System.out.println(names1.replaceAll(<span class="string">&quot;\\w+&quot;</span>,<span class="string">&quot;/&quot;</span>));<span class="comment">//风清扬/张无忌/周芷若</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">System.out.println(names3.replaceAll(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;-&quot;</span>));<span class="comment">//风清扬-张无忌-周芷若</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2023/03/04/Java/java-high/" target="_blank">了解更多java高级内容</a></p><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门</title>
      <link href="/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h1><h2 id="什么是Java语言"><a href="#什么是Java语言" class="headerlink" title="什么是Java语言"></a>什么是Java语言</h2><p>Java语言是美国Sun公司，在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h2 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h2><ul><li>1995年Sun公司发布java1.0版本</li><li>1997年发布java1.1版本</li><li>1998年发布java1.2版本</li><li>2000年发布java1.4版本</li><li>2002年发布java 5 版本</li><li>2006年发布java 6 版本</li><li>2009年oracle甲骨文公司收购sun公司，并于2011年发布java7版本</li><li>2014年发布java8版本</li><li>2017年9月发布java9版本</li><li>2018年3月发布java10版本</li></ul><h1 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制表示，它只包含0，,两个数，逢二进一，1+1&#x3D;10。每一个0或者每一个1，叫做一个bit(比特，位)。</p><ol><li>十进制数据转成二进制数据：使用除以2获取余数的方式(辗转相除法)<br> <img src="/../../images/JavaSE/2022-05-12-21-20-43.png" alt="123"></li><li>二进制数据转成十进制数据<br> 示例：<table><thead><tr><th>二进制数</th><th>十进制</th></tr></thead><tbody><tr><td>1001011</td><td>2^0+ 2^1+ 2^3+ 2^6</td></tr></tbody></table></li></ol><h1 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h1><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>位(bit):一个数字0或者一个数字1，代表一位。<br>字节(Byte):每逢8位是一个字节，这是数据存储的最小单位。<br>1 Byte &#x3D; 8 bit<br>1 KB &#x3D; 1024 Byte<br>1 MB &#x3D; 1024 KB<br>1 GB &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB<br>1 PB &#x3D; 1024 TB<br>1 EB &#x3D; 1024 PB<br>1 ZB &#x3D; 1024 EB<br>1 Mbps(宽带，Mbit&#x2F;s) &#x3D; 1024 KMps &#x3D; 1024&#x2F;8KBps &#x3D; 128KB&#x2F;s</p><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p>以前：MS -DOS(Microsoft Disk Operating System)<br>Windows:命令提示符(cmd)<br>启动：Win+R<br>输入:cmd</p><h2 id="cmd里常用命令"><a href="#cmd里常用命令" class="headerlink" title="cmd里常用命令"></a>cmd里常用命令</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>转换盘符</td><td>盘符名：</td></tr><tr><td>进入文件夹</td><td>cd 文件夹名称</td></tr><tr><td>进入多级文件夹</td><td>cd 文件夹1\文件夹2\文件夹3</td></tr><tr><td>返回上一级</td><td>cd ..</td></tr><tr><td>直接回根路径</td><td>cd \</td></tr><tr><td>查看当前内容</td><td>dir</td></tr><tr><td>清屏</td><td>cls(clear screen)</td></tr><tr><td>退出</td><td>exit</td></tr></tbody></table><h1 id="Java语言开发环境搭建"><a href="#Java语言开发环境搭建" class="headerlink" title="Java语言开发环境搭建"></a>Java语言开发环境搭建</h1><h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><p>java虚拟机，简称jvm,是运行所有java程序的假想计算机，是java程序的运行环境，是java最具有吸引力的特性之一。<br>跨平台：任何软件的运行，都必须运行在操作系统之上。<br><img src="/../../images/JavaSE/2022-05-12-22-09-00.png" alt="1"></p><h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><p>jre(java runtime environment):java程序时环境，包含jvm和运行时所需要的核心类库。<br>JDK(java development kit):java程序开发工具包，包含jre和开发人员使用的工具。<br>运行，只需要jre.开发，需要jdk.<br><img src="/../../images/JavaSE/2022-05-12-22-10-50.png" alt="2"><br>jdk下载地址： <a href="https://www.oracle.com/java/technologies/downloads/archive/">下载</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>此电脑-&gt;右键-&gt;属性</li><li>高级系统设置</li><li>环境变量</li><li>在系统变量新建</li><li>填写变量名：JAVA_HOME</li><li>变量值为java安装路径，结束为jdk….,点击确定</li><li>点击PATH</li><li>点击新建</li><li>填写%JAVA_HOME%\bin,完成</li></ol><h2 id="Hello-World入门程序"><a href="#Hello-World入门程序" class="headerlink" title="Hello World入门程序"></a>Hello World入门程序</h2><h3 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h3><p>java开发三步骤：<strong>编写、编译、运行</strong><br><img src="/../../images/JavaSE/2022-05-17-14-39-56.png" alt="167"></p><h3 id="编写Java源程序"><a href="#编写Java源程序" class="headerlink" title="编写Java源程序"></a>编写Java源程序</h3><ol><li>在d:\day01目录下新建文本文件，完整的文件名修改为HelloWorld.java,其中文件名为HelloWorld,后缀名必须为.java。</li><li>用记事本打开<blockquote><p>  使用notepad++记事本软件。</p></blockquote></li><li>写程序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWord</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="编译与运行Java源程序"><a href="#编译与运行Java源程序" class="headerlink" title="编译与运行Java源程序"></a>编译与运行Java源程序</h3><p>编译命令：</p><blockquote><p>javac + 源程序(文件名).java</p></blockquote><p>运行命令：</p><blockquote><p>java +源程序(文件名)</p></blockquote><ol><li>打开cmd(win+r,输入cmd)</li><li>cd 源程序路径（java文件所在的文件夹)</li><li>输入命令进行编译：javac +源程序(文件名).java,会发现在存放java文件的文件夹下多一个同名的.class文件</li><li>运行源程序：java +源程序(文件名)</li></ol><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><ul><li>单行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  这是一行注释信息</span></span><br></pre></td></tr></table></figure></li><li>多行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>说明  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多说明内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>说明：在java中有特殊含义的、被保留的、不能随意使用的字符称为关键字。<br>特点：</p><ul><li>完全小写的字母。</li><li>在增强版的记事本当中(例如Notepad++)有特殊颜色。</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p></li><li><p>命名规则(硬件要求)</p><ul><li>标识符可以包含<font color="red">英文字母26个(区分大小写)、0-9数字、$(美元符号)和_(下划线)。</font></li><li>标识符不能以数字开头。</li><li>标识符不能是关键字。</li></ul></li><li><p>命名规范(软件建议)</p><ul><li>类名规范：首字母大写，后面每个单词首字母大写(大驼峰式)</li><li>变量名规范：首字母小写，后面每个单词首字母大写(小驼峰式)</li><li>方法名规范：同变量名。</li></ul></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量：在程序运行期间，固定不变的量。</p><p>常量的分类：</p><ol><li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”abc”、”Hello”、”123”</li><li>整数常量：直接写上的数字，没有小数点。例如：100、200、0、-250</li><li>浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0</li><li>字符常量：凡是用单引号引起来的单个字符，叫做字符常量。例如：’a’,’B’,’9’,’中’</li><li>布尔常量：只有两种取值。true、false</li><li>空常量：null。代表没有任何数据。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>基本数据类型</p><ul><li>整数型 byte short int long</li><li>浮点型 float double</li><li>字符型 char</li><li>布尔型 boolean</li></ul></li><li><p>引用数据类型</p><ul><li>字符串</li><li>数组</li><li>类</li><li>接口</li><li>Lambda</li></ul></li></ol><p><img src="/../../images/JavaSE/2022-06-05-22-18-52.png" alt="16"><br><font color="red">注意事项：</font></p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li>数据范围与字节不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</li><li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母作为后缀。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量：程序运行期间，内容可以发生改变的量。</p><p>创建一个变量并且使用的格式：<br>①变量类型 变量名称；&#x2F;&#x2F;创建了一个变量<br>变量名称 &#x3D; 数据值;&#x2F;&#x2F;赋值，将右边的数据值赋值交给左边的变量<br>②一步到位格式：<br>数据类型 变量名称 &#x3D; 数据值；</p><p>注意：<br>创建多个变量，那么变量的名称不能重复。<br>对于float和long类型来说，字母后缀F和L不用丢掉<br>如果使用byte或者short类型的变量，右侧的数据值不能超过左侧类型的范围。<br>没有进行赋值的变量，不能直接使用；一定要赋值之后才能使用。<br>变量使用不能超过作用域的范围。<br>可以通过一个语句来创建多个变量，不推荐这样写。</p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>当数据类型不一样时，将会发生数据类型转换<br>基本数据类型的数据范围从小到大如下：<br>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>char-&gt;int-&gt;long-&gt;float-&gt;double</p><ul><li><p>自动类型转换(隐式)</p><ol><li>特点：代码不需要进行特殊处理，自动完成。</li><li>规则：数据范围从小到大。</li></ol></li><li><p>强制类型转换(显式)</p><ol><li>特点：代码需要进行特殊的格式处理，不能自动完成。</li><li>格式：范围小的类型 范围小的变量名 &#x3D; (范围小的类型)原本范围大的数据<br>  如：int num1 &#x3D; (int) 100L;—&gt;long类型范围比int大，不能自动转换，则需要强制类型转换。</li></ol></li></ul><p>自动类型转换例子：</p><blockquote><p>&#x2F;&#x2F;左边是long类型，右边是默认的int类型，左右不一样。自动类型转换<br>&#x2F;&#x2F;int–&gt;long,符合数据范围从小到大的要求<br>long num1 &#x3D; 100</p></blockquote><blockquote><p>左边double类型，右边float类型，符合数据范围从小到大，自动类型转换<br>double num2 &#x3D; 2.7F；</p></blockquote><blockquote><p>左边float类型，右边long类型，且long–&gt;float，float数据范围更大，符合自动类型转换。<br>float num3 &#x3D; 30L;</p></blockquote><p><font color="red">注意事项(强制类型转换)：</font></p><ol><li>强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出(大数据转换为小数据)。</li><li>byte&#x2F;short&#x2F;char这三种类型都可以发生数学运算，例如加法“+”.    ‘A’+1&#x3D;66</li><li>byte&#x2F;short&#x2F;char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</li><li>boolean类型不能发生数据类型转换。</li></ol><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><p>数字和字符的对照关系表(编码表)：<br>    ASCII码表：American Standard Code for Information Interchange,美国信息交换标准代码。<br>    Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含跟多字符。</p><p>48 –&gt; ‘0’<br>65 –&gt; ‘A’<br>97 –&gt; ‘a’</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-21-46.png" alt="3"><br><img src="/../../images/JavaSE/2022-06-07-16-27-50.png" alt="4"><br><img src="/../../images/JavaSE/2022-06-07-16-32-45.png" alt="5"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-36-53.png" alt="6"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-40-18.png" alt="7"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-45-38.png" alt="8"></p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-48-58.png" alt="9"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li><p>判断语句</p></li><li><p>选择语句</p><ul><li><p>if</p></li><li><p>if else</p></li><li><p>if … else if()</p></li><li><p>switch…case<br> 注意：<img src="/../../images/JavaSE/2022-06-08-10-19-17.png" alt="10"></p></li></ul></li><li><p>循环语句</p><ul><li>for(){}</li></ul><p> <img src="/../../images/JavaSE/2022-06-08-10-23-06.png" alt="11"></p><ul><li>while</li><li>do…while</li></ul></li></ol><p>3种循环的区别<br><img src="/../../images/JavaSE/2022-06-08-10-36-33.png" alt="12"></p><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>IDE：Integrated Development Environment,集成开发环境–是一种专门用来提高java开发效率的软件。<br>免费eclipse与收费Intellij IDEA</p><p>Intellij IDEA的下载与安装：</p><p><a href="https://www.jetbrains.com/idea/download/other.html">官网下载</a></p><p>IDEA常用快捷键<br><img src="/../../images/JavaSE/2022-06-08-11-16-36.png" alt="13"><br><img src="/../../images/JavaSE/2022-07-12-17-00-19.png" alt="14"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识jvm内存模型</title>
      <link href="/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h1><p><img src="/../../images/jvm/jvm-memory/jvm_classloader.png" alt="jvm_classloader"></p><p>​    区别于Java内存模型，<strong>JVM内存模型是指JVM虚拟机在运行Java程序时，所使用的内存结构和管理方式。</strong>JVM内存模型包括以下几个部分：</p><ol><li><p>程序计数器(Program Counter Register)</p><p>​    Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>总的来说：<font color="red">每个线程都有一个程序计数器，用于记录当前执行的指令地址。</font></p></li><li><p>虚拟机栈(Java Virtual Machine Stacks)<br>每个线程都有一个虚拟机栈，用于存储<font color="red">局部变量、方法参数、方法返回值以及操作数栈。</font>每个方法在执行时都会创建一个栈帧，用于存储该方法的局部变量、操作数栈等信息。当该方法运行完后便出栈。当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError,如果虚拟机栈可以动态扩展，若无法申请到足够的内存，抛出OutOfMemoryError异常。<br><img src="/../../images/jvm/jvm-memory/2022-12-03-11-13-42.png" alt="2022-12-03-11-13-42"></p></li><li><p>本地方法栈(Native Method Stack)<br> JVM 为 Native 方法执行而开辟的一块栈空间，<font color="red">用于存储本地方法的参数和局部变量等信息。</font>本地方法栈与虚拟机栈类似，都是栈结构，但两者是不同的概念和实现方式。（本地方法栈不受 JVM 内存管理机制的控制）</p></li><li><p>堆(Heap)<br>又称为GC堆，垃圾收集器管理的主要区域，是所有线程共享的内存区域，<font color="red">用于存储Java对象实例和数组。</font>现在的收集器基本都采用分代收集算法，即java堆又可以细分为：新生代和老年代。其中新生代又分为 Eden 区、Survivor 区 1 和 Survivor 区 2。堆内存的大小可以通过JVM启动参数进行调整。JVM 会通过垃圾回收机制来自动管理堆内存，包括垃圾收集和内存分配等操作。 </p></li><li><p>方法区(Method Area)<br>方法区也是所有线程共享的内存区域，<font color="red">用于存储类信息、常量池、静态变量、即时编译器编译后的代码等。</font>该区 是 JVM 内存模型中唯一没有规定垃圾回收方式的区域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm内存布局/内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载</title>
      <link href="/2023/03/03/jvm/jvm-classloader/"/>
      <url>/2023/03/03/jvm/jvm-classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h2><p><img src="/../../images/jvm/jvm-classloader/jvm_classloader.png" alt="01_2"></p><p>完整：</p><p><img src="/../../images/jvm/jvm-classloader/1677831036747.png" alt="1677831036747"></p><h2 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h2><p><img src="/../../images/jvm/jvm-classloader/1677831559346.png" alt="1677831519784"></p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>​    Java类加载是指将类的字节码文件加载到 JVM 中，使得这些类在程序运行时可以被使用。Java类加载的过程主要包括三个阶段：加载、链接（连接）和初始化。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><strong>加载阶段</strong></h4><p>​    在加载阶段，JVM会查找并加载类的字节码文件。首先，JVM会通过类的全限定名查找类文件，如果找不到，则会抛出ClassNotFoundException异常；如果找到了，就会将字节码文件加载到内存中，并在方法区中生成一个代表这个类的Class对象，这个过程也被称为类的装载,如 <a href="#classloader">类加载器ClassLoader</a> 的第一个图片。</p><p>​    Java类的加载是通过类加载器（ClassLoader）来完成的。类加载器负责查找和加载类的字节码文件，并生成表示这个类的Class对象。在加载阶段，JVM需要完成以下工作：</p><ul><li>通过类的全限定名查找字节码文件，并将其读入内存。</li><li>解析字节码文件，并生成表示这个类的Class对象。</li><li>在方法区中为这个类分配内存，并存储类的相关信息。<br>这工作在《深入理解Java虚拟机》第三版中的解释为：</li><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据<br>的访问入口。</li></ul><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><strong>链接阶段</strong></h4><p>​    在链接阶段，JVM会对类进行<strong>验证</strong>、<strong>准备</strong>和<strong>解析</strong>三个步骤：</p><p><font color="red">验证</font>：验证字节码文件是否符合Java语言规范以及JVM规范，包括语法检查、语义检查、字节码验证、符号引用验证等。如果验证不通过，则会抛出VerifyError异常。</p><p><font color="red">准备</font>：为类的静态变量分配内存，并设置初始值。这些变量在类加载时会被设置为默认值（0或null）。<strong>变量所使用的内存在方法区</strong></p><p><font color="red">解析</font>：将类中的符号引用（如类、方法、字段等）转换为直接引用。符号引用是一种符号形式的引用，需要通过解析才能转换为直接引用，以便JVM能够定位到对应的类、方法或字段。注意，该阶段可以在初始化后进行，如运行时需要动态绑定，则该阶段在初始完成后再进行。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h4><p>​    在初始化阶段，JVM会对类进行初始化，主要是执行类构造器方法（<clinit>()），静态变量的赋值和静态代码块的执行等。该构造器方法区别于类的构造函数或者说实例构造器（<init>()）方法，类构造器方法是类中的一个静态块，用于初始化静态变量或执行其他的类初始化操作。如果类没有静态变量或静态代码块，则初始化阶段会被跳过。</init></clinit></p><p>​    需要注意的是，类加载过程是按需加载的，即只有在需要使用类时才会进行加载。此外，JVM还提供了双亲委派机制，即先让父类加载器尝试加载类，如果父类加载器无法加载，则由当前类加载器进行加载。这种机制可以保证类的唯一性和安全性，避免重复加载和不同类加载器之间的类名冲突。</p><h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title=" 类加载器ClassLoader"></a><div id="classloader"> 类加载器ClassLoader</div></h2><p>​    <strong>.java</strong>文件通过编译后形成**.class**文件，在程序运行时使用该class文件，需要通过类加载器从内存加载进来处理。</p><p><img src="/../../images/jvm/jvm-classloader/1677832219825.png" alt="1677832219825"></p><p>​    在 JVM 中，类加载器用于查找、加载和链接Java类。Java虚拟机支持三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和系统类加载器（System Class Loader）。 </p><h3 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h3><p>​    启动类加载器是Java虚拟机内置的类加载器，负责加载Java核心类库，如java.lang和java.util等。启动类加载器是Java虚拟机内部实现的，不是Java类，因此无法用Java代码来实现和引用启动类加载器。该类加载器是用 C++ 实现，其他都是Java实现。</p><h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><p>​    扩展类加载器是Java虚拟机的内置类加载器之一，负责加载Java扩展库。Java扩展库包括Java虚拟机扩展机制所需的所有类，例如JNDI、JDBC和JavaMail等。扩展类加载器的父类加载器是启动类加载器。</p><h3 id="系统-x2F-应用程序类加载器（System-Class-Loader）"><a href="#系统-x2F-应用程序类加载器（System-Class-Loader）" class="headerlink" title="系统&#x2F;应用程序类加载器（System Class Loader）"></a>系统&#x2F;应用程序类加载器（System Class Loader）</h3><p>​    系统类加载器也称为应用类加载器，是Java虚拟机默认的类加载器，负责加载应用程序的类。系统类加载器通常从环境变量classpath或者Java命令的-cp选项指定的路径中查找类，它的父类加载器是扩展类加载器。</p><p>​    除了这三种内置类加载器之外，Java虚拟机还支持自定义类加载器。自定义类加载器可以实现特定的加载策略，例如从网络中动态加载类、从数据库中加载类或者从加密文件中加载类等。自定义类加载器必须继承 ClassLoader类，并重写findClass()方法，实现自己的类查找和加载策略。</p><p>​    <strong>需要注意的是，Java虚拟机中每个类加载器都有一个特定的命名空间，它只能加载它自己命名空间中的类。如果同一个类被不同的类加载器加载，那么它们在Java虚拟机中是不同的类，即使它们的字节码文件内容是相同的。这种机制可以保证类的唯一性和安全性，避免不同类加载器之间的类名冲突和安全隐患。</strong></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>​    由于类加载器存在层级关系，这种关系称为双亲委派模型。</p><p><img src="/../../images/jvm/jvm-classloader/1677850958450.png" alt="1677850958450"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>​    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器（Bootstrap ClassLoader）中，只有当父加载器反馈 自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 </p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>​    双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在某些特定情况下，可能需要打破双亲委派模型。具体方法如下：</p><ol><li>自定义类加载器</li></ol><p>​    自定义类加载器可以通过继承ClassLoader类并实现findClass()方法来打破双亲委派模型。如果一个类加载器自己能够完成类的加载任务，就不必委派给父类加载器，这种情况下可以打破双亲委派模型。</p><ol start="2"><li>线程上下文类加载器</li></ol><p>​    线程上下文类加载器可以通过Thread类的setContextClassLoader()方法来设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。在某些复杂的场景中，可能需要在不同的线程中使用不同的类加载器来加载类，这种情况下就需要使用线程上下文类加载器来打破双亲委派模型。</p><ol start="3"><li>OSGi和J2EE容器</li></ol><p>​    OSGi和J2EE容器等平台提供了自己的类加载器实现，可以在不同的模块中加载不同的类。这种情况下，打破双亲委派模型是必要的，否则会出现类加载失败或者类冲突等问题。</p><p><strong>需要注意的是，打破双亲委派模型可能会导致类的重复加载或者不同类加载器之间的类名冲突，从而导致程序运行出现问题。因此，在打破双亲委派模型时，需要谨慎考虑，确保程序的安全性和稳定性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初识类加载过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jwt</title>
      <link href="/2023/01/16/jwt/jwt/"/>
      <url>/2023/01/16/jwt/jwt/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h1><p><a href="https://jwt.io/introduction">官网jwt介绍</a></p><p>​JSON Web Token (JWT) is an open standard (<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the <strong>HMAC</strong> algorithm) or a public&#x2F;private key pair using <strong>RSA</strong> or <strong>ECDSA</strong>. </p><p>​翻译：JSON Web Token (JWT)是一个开放标准(rfc7519),它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥／私钥对进行签名 。</p><p>​通俗来说，JWT简称JSON Web Token，也就是通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p><h1 id="JWT能做什么"><a href="#JWT能做什么" class="headerlink" title="JWT能做什么"></a>JWT能做什么</h1><ol><li><p>授权</p><p>​这是使用JWT的最常见方案，一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。</p></li><li><p>信息交换</p><p>​JSON Web Token是在各方之间安全地<strong>传输信息</strong>的好方法。因为可以对JWT进行签名（例如，使用公钥／私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以<strong>验证内容是否遭到篡改</strong>。</p></li></ol><h1 id="为什么是JWT"><a href="#为什么是JWT" class="headerlink" title="为什么是JWT"></a>为什么是JWT</h1><h2 id="基于传统的Session认证"><a href="#基于传统的Session认证" class="headerlink" title="基于传统的Session认证"></a>基于传统的Session认证</h2><ol><li><p>认证方式<br>我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。 </p></li><li><p>认证流程<br><img src="/../images/jwt/1673842472937.png" alt="1673842472937"></p></li><li><p>暴露问题</p><ol><li><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p></li><li><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li><li><p>在前后端分离系统中就更加痛苦：如下图所示<br><img src="/../images/jwt/1673843150954.png" alt="1673843150954"></p><p>​也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是</p><p>sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</p></li></ol></li></ol><h2 id="基于JWT认证"><a href="#基于JWT认证" class="headerlink" title="基于JWT认证"></a>基于JWT认证</h2><p><img src="/../images/jwt/1673843325267.png" alt="1673843325267"></p><ol><li><p>认证流程</p><p>​首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p><p>​后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同111．zzz．xxx的字符串。</p><p>​后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</p><p>​前端在每次请求时将JWT放入HTTP Header中的Authorization位。（解决XSS和XSRF问题??????）</p><p>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p><p>​验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p></li><li><p>jwt优势</p><ul><li><p>简洁（Compact）：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p></li><li><p>自包含（Self—contained）：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li><li><p>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p></li><li><p>不需要在服务端保存会话信息，特别适用于分布式微服务。</p></li></ul></li></ol><h1 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h1><p>JWT通常为：xxxx.yyyyy.zzzzzHeader.Payload.Signature</p><ol><li>令牌组成<ol><li>标头(Header)<ul><li>标头通常由两部分组成：令牌的类型(即JWT)和所使用的签名算法，例如HMAC SHA256或RSA。它会使用Base64编码组成JWT结构的第一部分。<br>注意：<strong>Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span></span><br><span class="line"> <span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>有效载荷(Payload)<ul><li>令牌的第二部分是有效负载，其中包含声明。声明式有关实体(通常是用户)和其他数据的声明。同样的，它会使用Base64编码组成JWT结构的第二部分。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span></span><br><span class="line">  <span class="string">&quot;admin&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意：<strong>有效负载中不放用户敏感信息，如用户密码等</strong></li></ul></li><li>签名(Signature)<br>   前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过。（HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload) , secret)）<br>   签名的目的：最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</li></ol></li></ol><h1 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h1><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置90秒的对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.SECOND,<span class="number">90</span>);</span><br><span class="line"><span class="comment">//生成令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">    .withClaim(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;张三&quot;</span>)<span class="comment">//设置自定义用户名</span></span><br><span class="line">    .withExpiresAt(instance.getTime())<span class="comment">//设置过期时间</span></span><br><span class="line">    .sign(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>))；<span class="comment">//设置签名  保密  复杂</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出令牌</span></span><br><span class="line">System.out.println(token);</span><br></pre></td></tr></table></figure></li><li><p>根据令牌和签名解析数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>)).build;</span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名&quot;</span>+decodedJWT.getClaim(<span class="string">&quot;username&quot;</span>).asString());</span><br><span class="line">System.out.println(<span class="string">&quot;过期时间：&quot;</span>+decodedJWT.getExpiresAt());</span><br></pre></td></tr></table></figure></li><li><p>常见异常信息</p></li></ol><ul><li>SignatureVerificationException: 签名不一致异常</li><li>TokenExpiredException： 令牌过期异常</li><li>AlgorithmMismatchException:  算法不匹配异常</li><li>InvalidClaimException:  失效的payload异常</li></ul><ol start="5"><li><p>封装工具类<br>方式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtils</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SING</span> <span class="operator">=</span> <span class="string">&quot;hnalhjg&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    生成token   header.payload.sing</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getToken</span><span class="params">(Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.DATE,<span class="number">7</span>);<span class="comment">//默认7天过期</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建jwt builder</span></span><br><span class="line">        JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            builder.withClaim(k,v);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> builder.withExpiresAt(instance.getTime()) <span class="comment">//指定令牌过期时间</span></span><br><span class="line">            .sign(Algorithm.HMAC256(SING));<span class="comment">//sign</span></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    验证token 合法性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SING)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expire;</span><br><span class="line">    <span class="keyword">private</span> String header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(date)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime() + <span class="number">1000</span> * expire))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, key)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">parserToken</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                    .setSigningKey(key)</span><br><span class="line">                    .parseClaimsJws(jwt)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//token是否过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpire</span><span class="params">(Claims claims)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt的基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx基础入门</title>
      <link href="/2023/01/07/nginx/nginx/"/>
      <url>/2023/01/07/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h1><p>说明：<a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=1&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址来源</a> </p><p>​Nginx（＂engine x＂）是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好</p><p>​Nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50，000个并发连接数。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><div id="res">反向代理</div></h2><p>​反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择(转发)目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。  </p><p><img src="/../images/nginx/1672465996506.png" alt="1672465996506"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​正向代理：如果把局域网外的Intemet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。  在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问。</p><p><img src="/../images/nginx/1672465637077.png" alt="1672465637077"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>​客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p><p>​这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？</p><p>​* **单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡  ***</p><p><img src="/../images/nginx/1672466554613.png" alt="1672466554613"></p><h2 id="动态分离"><a href="#动态分离" class="headerlink" title="动态分离"></a>动态分离</h2><p>​为了加快网站的解析速度，可以把动态页面和静态页面有不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><img src="/../images/nginx/1672466852524.png" alt="1672466852524"></p><h1 id="nginx的安装与启动"><a href="#nginx的安装与启动" class="headerlink" title="nginx的安装与启动"></a>nginx的安装与启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p><a href="http://nginx.org/en/download.html">官网下载</a> nginx压缩包，本次为Linux下安装，选择如下：<br><img src="/../images/nginx/1672583906360.png" alt="1672583906360"></p></li><li><p>登录linux，并上传该文件到Linux下，用Winscp上传文件</p><p><img src="/../images/nginx/1672584047837.png" alt="1672584047837"></p><p>附：可用sftp命令上传。。。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接linux</span></span><br><span class="line">sftp [root@192.168...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录成功后，所有的l开头都是代表操作本机，不带l的是操作linux</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在确定好要将本机的文件上传到linux的位置后</span></span><br><span class="line">put 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用命令</span></span><br><span class="line">help  # 看支持哪些命令</span><br><span class="line">pwd &amp; lpwd  # linux当前目录与本机当前工作目录</span><br><span class="line">ls &amp; lls # linux当前目录下的文件，本机当前目录的文件</span><br><span class="line">put a.txt # 将本机a.txt文件上传到linux</span><br><span class="line">get b.txt # 从linux中下载文件到本机</span><br><span class="line">exit &amp; quit # 退出</span><br></pre></td></tr></table></figure></li><li><p>一键安装nginx相关依赖库</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc openssl openssl-devel pcre pcre-devel zlib zlib-devel -y</span><br></pre></td></tr></table></figure><p>   说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- gcc : 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境 </span><br><span class="line">- pcre pcre-devel : pcre(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库,nginx也需要此库。</span><br><span class="line">- zlib : zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</span><br><span class="line">- openssl openssl-devel : OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 </span><br></pre></td></tr></table></figure><ol><li><p>开始安装nginx</p></li><li><p>创建一个nginx文件夹,并进行nginx压缩包的解压</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件夹</span></span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将压缩包解压到当前文件夹中</span></span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz -C /usr/local/nginx# tar -zxvf 压缩包名 -C 指定目录</span><br></pre></td></tr></table></figure></li><li><p>编译并安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx目录</span></span><br><span class="line">cd /usr/local/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd nginx-1.18.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make命令进行编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make install命令进行安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装完后会有conf文件夹，进入nginx.conf文件中配置端口号与ip(与虚拟机ip一致)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开nginx.conf配置文件</span></span><br><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改端口号与ip</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586130429.png" alt="1672586130429"></p></li></ol><h2 id="测试、启动与关闭"><a href="#测试、启动与关闭" class="headerlink" title="测试、启动与关闭"></a>测试、启动与关闭</h2><ol><li><p>查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -v</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -v</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure></li><li><p>查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginxz</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586390937.png" alt="1672586390937"></p></li><li><p>配置过nginx.conf文件，进行刷新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s reload</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s stop</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开放的端口号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式：firewall-cmd --add-service=http --permanent</span></span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>本机浏览器输入虚拟机ip</p><p><img src="/../images/nginx/1672586743935.png" alt="1672586743935"></p><h1 id="nginx配置文件说明"><a href="#nginx配置文件说明" class="headerlink" title="nginx配置文件说明"></a>nginx配置文件说明</h1><p>配置文件位置：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p><p>nginx配置文件由三大部分组成，分为全局块、events块、http块</p><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>​从配置文件开始到 events块之间的内容，主要会设置一些影响 <strong>nginx服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的worker process 数，进程 PID存放路径、日志存放路径和类型以及配置文件的引入等</strong>。 如：</p><p><img src="/../images/nginx/1672627362232.png" alt="1672627362232"></p><p>​这是Nginx 服务器并发处理服务的关键配置，worker＿processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约</p><h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><p>​events 块涉及的指令主要影响 <strong>Nginx 服务器与用户的网络连接</strong>，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。</p><p><img src="/../images/nginx/1672627668523.png" alt="1672627668523"></p><p>​上述例子就表示每个 work process 支持的最大连接数为1024．</p><p>​这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。</p><h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>http块也包括http全局块(http的全局配置)以及server块。</p><ol><li><p>http全局块<br>http 全局块配置的指令包括文件引入、MIME—TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>  <img src="/../images/nginx/1672627926561.png" alt="1672627926561"></p></li><li><p>http块<br>整个大的http包裹的就是http块，可以嵌套多个server</p></li><li><p>server块</p><p>​这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p><p>​每个 http块可以包括多个 server块，而每个server块就相当于一个虚拟主机。而每个 server块也分为全局server块，以及可以同时包含多个locaton块。</p><ol><li><p>全局server块<br>最常见的本虚拟机主机的监听配置和本虚拟机的名称或ip配置</p></li><li><p>location块</p><p>​一个server块可以配置多个location块。</p><p>​这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server-name&#x2F;uri-string），对虚以主机名称（也可以是IP别名）之外的字符串（例如前面的&#x2F;uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。即：<strong>配置请求的路由，以及各种页面 的处理情况</strong>。</p></li></ol></li></ol><h1 id="nginx配置实例-反向代理1"><a href="#nginx配置实例-反向代理1" class="headerlink" title="nginx配置实例-反向代理1"></a>nginx配置实例-反向代理1</h1><p>反向代理原理请参考<a href="#res">1.1反向代理</a></p><p>要实现的效果：</p><p>​打开浏览器，输入网址，跳转到linux系统的tomcat主页</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在linux系统下安装tomcat，使用默认端口8080,并在本地测试是否成功。</p><ol><li><p><a href="https://tomcat.apache.org/download-90.cgi">官网下载 </a> tomcat压缩包<br><img src="/../images/nginx/1672632380038.png" alt="1672632380038"></p></li><li><p>将压缩包上传到linux系统中</p></li><li><p>解压到&#x2F;usr&#x2F;src下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>centos默认安装了jdk，直接进入bin目录启动tomcat|</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/apache-tomcat-9.0.70/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动tomcat</span></span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙或开放8080端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放8080端口</span></span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问linux<br><img src="/../images/nginx/1672632912754.png" alt="1672632912754"></p></li></ol></li></ol><h2 id="访问过程分析"><a href="#访问过程分析" class="headerlink" title="访问过程分析"></a>访问过程分析</h2><p><img src="/../images/nginx/1672633212388.png" alt="1672633212388"></p><h2 id="配置本地host文件"><a href="#配置本地host文件" class="headerlink" title="配置本地host文件"></a>配置本地host文件</h2><ol><li>在C:\Windows\System32\drivers\etc下，修改hosts文件。添加一个本机域名地址：</li></ol><p><img src="/../images/nginx/1672646981434.png" alt="1672646981434"></p><ol><li>在启动了tomcat的情况下，输入地址<a href="http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。">http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。</a><br><img src="/../images/nginx/1672647258790.png" alt="1672647258790"></li><li>配置nginx的配置文件，并启动nginx<br><img src="/../images/nginx/1672647451217.png" alt="1672647451217"></li><li>测试<br>浏览器输入<a href="http://www.123.com,通过nginx的配置,将该请求转发到http//127.0.0.1:8080%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84127.0.0.1%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%AC%E6%9C%BAip%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">www.123.com，通过nginx的配置，将该请求转发到http://127.0.0.1:8080，此时的127.0.0.1代表的是虚拟机本机ip，结果如下：</a><br><img src="/../images/nginx/1672647631481.png" alt="1672647631481"></li></ol><h1 id="nginx配置实例-反向代理2"><a href="#nginx配置实例-反向代理2" class="headerlink" title="nginx配置实例-反向代理2"></a>nginx配置实例-反向代理2</h1><p>想要实现的效果：</p><p>​使用nginx反向代理，根据访问的路径跳转到不同端口的服务中，nginx监听的端口为9001。如：</p><ol><li>访问<a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> ,直接跳转到127.0.0.1:8081</li><li>访问<a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> ,直接跳转到127.0.0.1:8082</li></ol><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>准备两个tomcat服务器，一个8080端口，一个8081端口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/usr/src下创建2个文件夹</span></span><br><span class="line">cd /usr/src</span><br><span class="line">mkdir tomcat8080</span><br><span class="line">mkdir tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/usr/src下的tomcat压缩包分别拷贝到这2个文件夹中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：<span class="built_in">cp</span> 要拷贝的文件名 指定拷贝到的目录</span></span><br><span class="line">cd /usr/src</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8080</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别解压这两个压缩包</span></span><br><span class="line">cd tomcat8080</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line">cd tomcat8081</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改tomcat8081文件夹下的tomcat端口，改为8081</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/conf</span><br><span class="line">vi server.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672657513308.png" alt="1672657513308"></p><p><img src="/../images/nginx/1672657571433.png" alt="1672657571433"></p></li></ol><p><img src="/../images/nginx/1672657600381.png" alt="1672657600381"></p><ol><li><p>分别启动这两个tomcat</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8080端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8081端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>创建一些访问的页面(windows上传过来a.html也行)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/webapps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个文件</span></span><br><span class="line">mkdir edu/a.html</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658101588.png" alt="1672658101588"></p><p>同样方法创建一个vod&#x2F;a.html在端口为8081的tomcat中。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>配置nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在http块中添加如下内容</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658389765.png" alt="1672658389765"></p></li><li><p>开放8080、8081、9001端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8081/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=9001/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658662276.png" alt="1672658662276"></p></li><li><p>测试<br>通过访问不同的文件，nginx转发到不同的端口</p><p>访问<a href="http://192.168.52.128:9001/edu/a.html">192.168.52.128:9001&#x2F;edu&#x2F;a.html</a>  ：</p><p><img src="/../images/nginx/1672658799404.png" alt="1672658799404"></p><p>访问<a href="http://192.168.52.128:9001/vod/a.html">192.168.52.128:9001&#x2F;vod&#x2F;a.html</a> ：</p><p><img src="/../images/nginx/1672658827810.png" alt="1672658827810"></p></li></ol><p>但是现在依然能够不通过nginx，直接进行tomcat的访问，如直接访问8081：</p><p><img src="/../images/nginx/1672658906294.png" alt="1672658906294"></p><p>可以把8080端口与8081端口关闭，达到只能通过9001端口进行访问8080端口的tomcat资源或8081端口的tomcat资源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭8080端口</span></span><br><span class="line">firewall-cmd --remove-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="关于nginx配置文件的location的配置说明"><a href="#关于nginx配置文件的location的配置说明" class="headerlink" title="关于nginx配置文件的location的配置说明"></a>关于nginx配置文件的location的配置说明</h3><p>该指令用于匹配URL。语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~] uri &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>&#x3D; : 用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</li><li>~ ： 用于表示uri包含正则表达式，并且区分大小写。</li><li>~* ：用于表示uri包含正则表达式，并且不区别大小写。</li><li>^~ : 用于不含正在表达式的uri前，要求nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。<br><em><em>注意：如果uri包含正则表达式，则必须要有 ~ 或者 ~</em> 标识</em>*</li></ol><h1 id="nginx配置实例-负载均衡"><a href="#nginx配置实例-负载均衡" class="headerlink" title="nginx配置实例-负载均衡"></a>nginx配置实例-负载均衡</h1><p>想要实现的效果：</p><ol><li>浏览器地址栏输入地址 <a href="http://192.168.52.128/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%B9%B3%E5%9D%87%E8%BD%AC%E5%8F%91%E7%BB%998080%E5%92%8C8081%E7%AB%AF%E5%8F%A3%E3%80%82">http://192.168.52.128/edu/a.html，负载均衡效果：请求平均转发给8080和8081端口。</a></li></ol><h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备两台tomcat服务器，一台8080端口，一台8081<br>根据前面的配置的方向代理实例已经配置好了两台tomcat服务器。</li><li>在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建页面a.html，用于测试|<br><img src="/../images/nginx/1673003516724.png" alt="1673003516724"></li></ol><h2 id="在nginx的配置文件中进行负载均衡的配置"><a href="#在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="在nginx的配置文件中进行负载均衡的配置"></a>在nginx的配置文件中进行负载均衡的配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>   <img src="/../images/nginx/1673003654331.png" alt="1673003654331"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>​在浏览器中输入 <a href="http://192.168.52.128/edu/a.html">http://192.168.52.128/edu/a.html</a> 进行测试，访问一次便刷新一次，效果就是不断依次访问到两个服务器的资源。</p><h2 id="关于nginx分配服务器（负载均衡）的几种策略"><a href="#关于nginx分配服务器（负载均衡）的几种策略" class="headerlink" title="关于nginx分配服务器（负载均衡）的几种策略"></a>关于nginx分配服务器（负载均衡）的几种策略</h2><ol><li><font color="red">轮询(默认)</font><br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉（宕机），能自动剔除。</li><li>weight<br>weight代表权重，默认为1，权重越高被分配的客户端越多。<br><img src="/../images/nginx/1673004386609.png" alt="1673004386609"></li><li>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器，可以解决session的问题。<br><img src="/../images/nginx/1673004591334.png" alt="1673004591334"></li><li>fair(第三方，此配置需要装插件)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><img src="/../images/nginx/1673004829929.png" alt="1673004829929"></li></ol><h1 id="nginx配置实例-动静分离"><a href="#nginx配置实例-动静分离" class="headerlink" title="nginx配置实例-动静分离"></a>nginx配置实例-动静分离</h1><p>​Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过nginx 来分开。</p><p>​通过location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p><p>​具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires 来缓存），我这里设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><img src="/../images/nginx/1673056715488.png" alt="1673056715488"></p><h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>​在linux系统中准备静态资源，用于进行访问。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir data</span><br><span class="line">cd data</span><br><span class="line">mkdir www</span><br><span class="line">mkdir image</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673058624024.png" alt="1673058624024"></p><p>​在image中添加静态资源a.png,在www下添加a.html</p><p><img src="/../images/nginx/1673058664898.png" alt="1673058664898"></p><p><img src="/../images/nginx/1673058781285.png" alt="1673058781285"></p><h2 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>在nginx的配置文件中进行配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673059330164.png" alt="1673059330164"></p></li><li><p>启动nginx后进行测试</p><p>访问静态资源：</p><p><img src="/../images/nginx/1673059651262.png" alt="1673059651262"><br>配置了autoindex on;  ：表示是否将所有资源以列表的形式列举出来。</p><p><img src="/../images/nginx/1673060605982.png" alt="1673060605982"></p></li></ol><h1 id="nginx配置实例-高可用"><a href="#nginx配置实例-高可用" class="headerlink" title="nginx配置实例-高可用"></a>nginx配置实例-高可用</h1><p><img src="/../images/nginx/1673061314633.png" alt="1673061314633"></p><p>nginx宕机则会出现无法访问到tomcat，使用高可用解决该问题，如下图：</p><p><img src="/../images/nginx/1673061394135.png" alt="1673061394135"></p><p>如果nginx主服务器宕机，则通过nginx的备用服务器访问tomcat。</p><p><a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=14&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址：14-nginx配置实例（高可用准备工作）_哔哩哔哩_bilibili</a> </p><p><a href="https://www.cnblogs.com/SimpleWu/p/11004902.html">参考：生产环境之Nginx高可用方案 - 日落西风又在吹 - 博客园 </a> </p><p><a href="https://besterwin.gitee.io/blogs/knowledge/middle/Nginx.html">脑图参考：Nginx.mmap (gitee.io)</a> </p><h1 id="nginx的原理解析"><a href="#nginx的原理解析" class="headerlink" title="nginx的原理解析"></a>nginx的原理解析</h1><p>进程模型：</p><p><img src="/../images/nginx/nginx.webp" alt="img"> </p><ol><li>在nginx启动后，会有一个master进程和多个worker进程，master进程主要用来管理worker进程，包括：接受信号，将信号分发给worker进程，监听worker进程工作状态，当worker进程退出时(非正常)，启动新的worker进程。基本的网络事件会交给worker进程处理。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 。</li><li>当master接收到重新加载的信号会怎么处理(.&#x2F;nginx -s reload)?，master会重新加载配置文件，然后启动新的进程，使用的新的worker进程来接受请求，并告诉老的worker进程他们可以退休了，老的worker进程将不会接受新的，老的worker进程处理完手中正在处理的请求就会退出。</li><li>worker进程是如何处理用户的请求呢？首先master会根据配置文件生成一个监听相应端口的socket，然后再faster出多个worker进程，这样每个worker就可以接受从socket过来的消息（其实这个时候应该是每一个worker都有一个socket，只是这些socket监听的地址是一样的）。当一个连接过来的时候，每一个worker都能接收到通知，但是只有一个worker能和这个连接建立关系，其他的worker都会连接失败，这就是所谓的惊群现在，为了解决这个问题，nginx提供一个共享锁accept_mutex，有了这个共享锁后，就会只有一个worker去接收这个连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。</li></ol><p><a href="https://blog.csdn.net/wangbiao007/article/details/82910709">nginx原理参考</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础常见问题</title>
      <link href="/2022/12/20/Java/JavaSE/"/>
      <url>/2022/12/20/Java/JavaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h1><h2 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1. JDK和JRE有什么区别？"></a>1. JDK和JRE有什么区别？</h2><p>JDK：Java Development Kit的简称，java开发工具包，提供了java的开发环境和运行环境。<br>JRE: Java Runtime Environment的简称，java运行环境，为java的运行提供了所需环境。<br>具体来说JDK其实包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具。简单来说：如果你需要运行java程序，只需要安装JRE就可以了，如果你需要编写java程序，需要安装JDK。</p><h2 id="2-x3D-x3D-和-equals的区别是什么？"><a href="#2-x3D-x3D-和-equals的区别是什么？" class="headerlink" title="2. &#x3D;&#x3D; 和 equals的区别是什么？"></a>2. &#x3D;&#x3D; 和 equals的区别是什么？</h2><ol><li>却别： equals是方法，而 &#x3D;&#x3D; 是操作符；</li><li>对于基本数据类型（short、int、long、float、double）来说，只能使用 &#x3D;&#x3D; 比较值</li><li>对于引用数据类型来说，需要分情况<ul><li>没有重写Object类的equals方法，则用 &#x3D;&#x3D; 比较的是存放的地址。</li><li>重写了Object类的equals方法，如String类，看源码是用 &#x3D;&#x3D; 先进行引用(存放地址)的比较，如果不等，再进行值的比较</li></ul></li></ol><p>总结：<br><font color="red">&#x3D;&#x3D;对于基本数据类型来说是值比较；对于引用数据类型来说，比较的是引用；而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String（先比较引用，再比较值）、Integer（值比较）等把它变成了值比较，所以一般情况下equals比较的是值是否相等</font></p><h2 id="3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？"><a href="#3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？" class="headerlink" title="3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？"></a>3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？</h2><p><font color="red">不对，两个对象的hashCode()相同，equals()不一定为true。</font></p><p>如字符串“通话”、“重地”,这两个字符串的hash相同（用固定公式计算hash），但a.equals(b)是不一样的。</p><h2 id="4-final在java中有什么作用？"><a href="#4-final在java中有什么作用？" class="headerlink" title="4. final在java中有什么作用？"></a>4. final在java中有什么作用？</h2><ul><li>final修饰的类叫最终类，该类不能被继承。</li><li>final修饰的方法不能被重写。</li><li>final修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="5-java中的Math-round-1-5-等于多少？"><a href="#5-java中的Math-round-1-5-等于多少？" class="headerlink" title="5. java中的Math.round(-1.5)等于多少？"></a>5. java中的Math.round(-1.5)等于多少？</h2><p>等于-1，因为在数轴上取值是，中间值(0.5)向右取整，所以整0.5是往上取整，负0.5是直接舍弃。</p><h2 id="6-String属于基础的数据类型吗？"><a href="#6-String属于基础的数据类型吗？" class="headerlink" title="6. String属于基础的数据类型吗？"></a>6. String属于基础的数据类型吗？</h2><p>String不属于基础类型，基础类型有8中，byte(1)、boolean、char(2)、short(2)、int(4)、float(4)、long(8)、double(8)，而String属于对象（引用数据类型）</p><h2 id="7-java中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java中操作字符串都有哪些类？它们之间有什么区别？"></a>7. java中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会⽣成新的String 对象，然后将指针指向新的 String 对象；⽽ StringBuffer、StringBuilder 可以在原有对象的基础上进⾏操作，所以在经常改变字符串内容的情况下最好不要使⽤ String。</p><p>StringBuffer 和 StringBuilder 最⼤的区别在于，StringBuffer 是线程安全的，⽽ StringBuilder 是⾮线程安全的，但 StringBuilder 的性能却⾼于StringBuffer，所以在单线程环境下推荐使⽤ StringBuilder，多线程环境下推荐使⽤ StringBuffer。</p><h2 id="8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？"><a href="#8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？" class="headerlink" title="8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？"></a>8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str &#x3D; “i”的方式，java虚拟机会将其分配到常量池中；而String str &#x3D; new String（”i”）则会被分到堆内存中。</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><p>使用StringBuilder或者StringBuffer的reverse()方法。</p><h2 id="10-String类的常用方法都有哪些？"><a href="#10-String类的常用方法都有哪些？" class="headerlink" title="10. String类的常用方法都有哪些？"></a>10. String类的常用方法都有哪些？</h2><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白（空格）</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的byte类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字母。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li><li>compareTo()：按字典顺序比较大小。</li></ul><h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。（有抽象方法的类必定是抽象类）</p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h2 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13. 抽象类能使用final修饰吗？"></a>13. 抽象类能使用final修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以使任意访问修饰符。</li></ul><h2 id="15-java中IO流分为几种？"><a href="#15-java中IO流分为几种？" class="headerlink" title="15. java中IO流分为几种？"></a>15. java中IO流分为几种？</h2><ol><li>按功能分<ul><li>输入流（input）</li><li>输出流（output）</li></ul></li><li>按类型分<ul><li>字节流</li><li>字符流<br>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字节流按16位传输以字符为单位输入输出数据。</li></ul></li></ol><h2 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16. BIO、NIO、AIO有什么区别？"></a>16. BIO、NIO、AIO有什么区别？</h2><ul><li>BIO：Block IO同步阻塞IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO (或Non Blocking IO) 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel(通道)通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制。</li></ul><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h2><ul><li>Files.exists()：检测⽂件路径是否存在。</li><li>Files.createFile()：创建⽂件。</li><li>Files.createDirectory()：创建⽂件夹。</li><li>Files.delete()：删除⼀个⽂件或⽬录。</li><li>Files.copy()：复制⽂件。</li><li>Files.move()：移动⽂件。</li><li>Files.size()：查看⽂件个数。</li><li>Files.read()：读取⽂件。</li><li>Files.write()：写⼊⽂件。</li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示："><a href="#1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示：" class="headerlink" title="1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示："></a>1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示：</h2><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector<ul><li>Stack</li></ul></li></ul></li><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeSet</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol><li>Collection 是⼀个集合接⼝，它提供了对集合对象进⾏基本操作的通⽤接⼝⽅法，所有集合都是它的⼦类，比如 List、Set 等。</li><li>Collections 是⼀个包装类，包含了很多静态⽅法，不能被实例化，就像⼀个⼯具类，⽐如提供的排序⽅法： Collections.sort(list)。</li></ol><h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个⽅⾯：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br><img src="/../images/JavaSE/2022-12-02-13-46-08.png"></p><h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：HashMap 允许 key 和 value 为 null，⽽ Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，⽽ HashMap 是⾮线程安全的。</li><li>推荐使⽤：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使⽤，推荐在单线程环境下使⽤ HashMap 替代，如果需要多线程使⽤则⽤ ConcurrentHashMap 替代。</li></ul><h2 id="5-如何决定使⽤-HashMap-还是-TreeMap？"><a href="#5-如何决定使⽤-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使⽤ HashMap 还是 TreeMap？"></a>5. 如何决定使⽤ HashMap 还是 TreeMap？</h2><p>   对于在 Map 中插⼊、删除、定位⼀个元素这类操作，HashMap 是最好的选择，因为相对⽽⾔ HashMap的插⼊会更快，但如果你要对⼀个 key 集合进⾏有序的遍历，那 TreeMap 是更好的选择。</p><h2 id="6-说⼀下-HashMap-的实现原理？"><a href="#6-说⼀下-HashMap-的实现原理？" class="headerlink" title="6. 说⼀下 HashMap 的实现原理？"></a>6. 说⼀下 HashMap 的实现原理？</h2><p>   HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传⼊ key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket ⾥。当计算出的hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是⽤链表和红⿊树存储相同 hash 值的 value。<br>当 hash 冲突的个数⽐较少时，使⽤链表否则使⽤红⿊树。</p><h2 id="7-说⼀下-HashSet-的实现原理？"><a href="#7-说⼀下-HashSet-的实现原理？" class="headerlink" title="7. 说⼀下 HashSet 的实现原理？"></a>7. 说⼀下 HashSet 的实现原理？</h2><p>   HashSet 是基于 HashMap 实现的，HashSet 底层使⽤ HashMap 来保存所有元素，因此 HashSet 的实现⽐较简单，相关 HashSet 的操作，基本上都是直接调⽤底层 HashMap 的相关⽅法来完成，HashSet 不允许重复的值。</p><h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，⽽ LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList ⽐ LinkedList 在随机访问的时候效率要⾼，因为 LinkedList 是线性的数据存储⽅式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在⾮⾸尾的增加和删除操作，LinkedList 要⽐ ArrayList 效率要⾼，因为 ArrayList增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使⽤ ArrayList，⽽在插⼊和删除操作较多时，更推荐<br>使⽤ LinkedList。</p><h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使⽤ Arrays.asList(array) 进⾏转换。</li><li>List 转数组：使⽤ List ⾃带的 toArray() ⽅法。</li></ul><h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul><li>线程安全：Vector 使⽤了 Synchronized 来实现线程同步，是线程安全的，⽽ ArrayList 是⾮线程安全的。</li><li>性能：ArrayList 在性能⽅⾯要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1倍，⽽ ArrayList 只会增加 50%。</li></ul><h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定⼤⼩的，⽽ ArrayList ⼤⼩是⾃动扩展的。</li><li>Array 内置⽅法没有 ArrayList 多，⽐如 addAll、removeAll、iteration 等⽅法只有 ArrayList 有。</li></ul><h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul><li>相同点：都是返回第⼀个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，⽽ remove()会直接抛出 NoSuchElementException 异常。</li></ul><h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，⽽像 HashMap 则是⾮线程安全的，不过在 jdk 1.5 之后随着java.util.concurrent 并发包的出现，它们也有了⾃⼰对应的线程安全类，⽐如 HashMap 对应的线程安全类就是ConcurrentHashMap。</p><h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><p>Iterator 接⼝提供遍历任何 Collection 的接⼝。我们可以从⼀个 Collection 中使⽤迭代器⽅法来获取迭代器实例。迭代器取代了 java 集合框架中的Enumeration，迭代器允许调⽤者在迭代过程中移除元素。</p><h2 id="15-Iterator-怎么使⽤？有什么特点？"><a href="#15-Iterator-怎么使⽤？有什么特点？" class="headerlink" title="15. Iterator 怎么使⽤？有什么特点？"></a>15. Iterator 怎么使⽤？有什么特点？</h2><p>使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p><h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator 可以遍历 Set 和 List 集合，⽽ ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，⽽ ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接⼝继承，然后添加了⼀些额外的功能，⽐如添加⼀个元素、替换⼀个元素、获取前⾯或后⾯元素的索引位置。</li></ul><h2 id="17-怎么确保⼀个集合不能被修改？"><a href="#17-怎么确保⼀个集合不能被修改？" class="headerlink" title="17. 怎么确保⼀个集合不能被修改？"></a>17. 怎么确保⼀个集合不能被修改？</h2><p>可以使⽤ Collections.unmodifiableCollection(Collection c) ⽅法来创建⼀个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运⾏时此⾏报错</span></span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
