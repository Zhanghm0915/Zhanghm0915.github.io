<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql那些事</title>
      <link href="/2023/03/30/mysql/mysql/"/>
      <url>/2023/03/30/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库：DataBase，简称 DB，存储和管理数据的仓库</p><p>数据库的优势：</p><ul><li>可以持久化存储数据</li><li>方便存储和管理数据</li><li>使用了统一的方式操作数据库 SQL</li></ul><p>数据库、数据表、数据的关系介绍：</p><ul><li><p>数据库</p><ul><li>用于存储和管理数据的仓库</li><li>一个库中可以包含多个数据表</li></ul></li><li><p>数据表</p><ul><li>数据库最重要的组成部分之一</li><li>由纵向的列和横向的行组成（类似 excel 表格）</li><li>可以指定列名、数据类型、约束等</li><li>一个表中可以存储多条数据</li></ul></li><li><p>数据：想要永久化存储的数据</p></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1zJ411M7TB">https://www.bilibili.com/video/BV1zJ411M7TB</a></p><hr><h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 数据库是一个最流行的关系型数据库管理系统之一，关系型数据库是将数据保存在不同的数据表中，而且表与表之间可以有关联关系，提高了灵活性</p><p>缺点：数据存储在磁盘中，导致读写性能差，而且数据关系复杂，扩展性差</p><p>MySQL 所使用的 SQL 语句是用于访问数据库最常用的标准化语言</p><p>MySQL 配置：</p><ul><li><p>MySQL 安装：<a href="https://www.jianshu.com/p/ba48f1e386f0">https://www.jianshu.com/p/ba48f1e386f0</a></p></li><li><p>MySQL 配置：</p><ul><li><p>修改 MySQL 默认字符集：安装 MySQL 之后第一件事就是修改字符集编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">添加如下内容：</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></li><li><p>启动 MySQL 服务： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start/restart mysql</span><br></pre></td></tr></table></figure></li><li><p>登录 MySQL：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p  敲回车，输入密码</span><br><span class="line">初始密码查看：cat /var/log/mysqld.log</span><br><span class="line">在root@localhost:   后面的就是初始密码</span><br></pre></td></tr></table></figure></li><li><p>查看默认字符集命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;char%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>修改MySQL登录密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line">  </span><br><span class="line">set password=password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>授予远程连接权限（MySQL 内输入）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;密码&#x27;;</span><br><span class="line">-- 刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改 MySQL 绑定 IP：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/mysql/mysql.conf.d</span><br><span class="line">sudo chmod 666 mysqld.cnf </span><br><span class="line">vim mysqld.cnf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bind-address = 127.0.0.1注释该行</span></span><br></pre></td></tr></table></figure></li><li><p>关闭 Linux 防火墙</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行3306端口</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>体系结构详解：</p><ul><li>第一层：网络连接层<ul><li>一些客户端和链接服务，包含本地 Socket 通信和大多数基于客户端&#x2F;服务端工具实现的 TCP&#x2F;IP 通信，主要完成一些类似于连接处理、授权认证、及相关的安全方案</li><li>在该层上引入了<strong>连接池</strong> Connection Pool 的概念，管理缓冲用户连接，线程处理等需要缓存的需求</li><li>在该层上实现基于 SSL 的安全链接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</li></ul></li></ul><ul><li>第二层：核心服务层<ul><li>查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，所有的内置函数（日期、数学、加密函数等）<ul><li>Management Serveices &amp; Utilities：系统管理和控制工具，备份、安全、复制、集群等</li><li>SQL Interface：接受用户的 SQL 命令，并且返回用户需要查询的结果</li><li>Parser：SQL 语句分析器</li><li>Optimizer：查询优化器</li><li>Caches &amp; Buffers：查询缓存，服务器会查询内部的缓存，如果缓存空间足够大，可以在大量读操作的环境中提升系统性能</li></ul></li><li>所有<strong>跨存储引擎的功能</strong>在这一层实现，如存储过程、触发器、视图等</li><li>在该层服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询顺序，是否利用索引等， 最后生成相应的执行操作</li><li>MySQL 中服务器层不管理事务，<strong>事务是由存储引擎实现的</strong></li></ul></li><li>第三层：存储引擎层<ul><li>Pluggable Storage Engines：存储引擎接口，MySQL 区别于其他数据库的重要特点就是其存储引擎的架构模式是插件式的（存储引擎是基于表的，而不是数据库）</li><li>存储引擎<strong>真正的负责了 MySQL 中数据的存储和提取</strong>，服务器通过 API 和存储引擎进行通信</li><li>不同的存储引擎具有不同的功能，共用一个 Server 层，可以根据开发的需要，来选取合适的存储引擎</li></ul></li><li>第四层：系统文件层<ul><li>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互</li><li>File System：文件系统，保存配置文件、数据文件、日志文件、错误文件、二进制文件等</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p><hr><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>池化技术：对于访问数据库来说，建立连接的代价是比较昂贵的，因为每个连接对应一个用来交互的线程，频繁的创建关闭连接比较耗费资源，有必要建立数据库连接池，以提高访问的性能</p><p>连接建立 TCP 以后需要做<strong>权限验证</strong>，验证成功后可以进行执行 SQL。如果这时管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限，只有再新建的连接才会使用新的权限设置</p><p>MySQL 服务器可以同时和多个客户端进行交互，所以要保证每个连接会话的隔离性（事务机制部分详解）</p><p>整体的执行流程：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL的执行流程.png" style="zoom: 33%;"><hr><h4 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h4><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据</p><p>flush privileges 语句本身会用数据表（磁盘）的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下使用，这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以尽量不要使用这类语句</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4.png"></p><hr><h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><p>客户端如果长时间没有操作，连接器就会自动断开，时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端<strong>再次发送请求</strong>的话，就会收到一个错误提醒：<code>Lost connection to MySQL server during query</code></p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p><p>为了减少连接的创建，推荐使用长连接，但是<strong>过多的长连接会造成 OOM</strong>，解决方案：</p><ul><li><p>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure></li><li><p>MySQL 5.7 版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</p></li></ul><p>SHOW PROCESSLIST：查看当前 MySQL 在进行的线程，可以实时地查看 SQL 的执行情况，其中的 Command 列显示为 Sleep 的这一行，就表示现在系统里面有一个空闲连接</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>ID</td><td>用户登录 mysql 时系统分配的 connection_id，可以使用函数 connection_id() 查看</td></tr><tr><td>User</td><td>显示当前用户，如果不是 root，这个命令就只显示用户权限范围的 sql 语句</td></tr><tr><td>Host</td><td>显示这个语句是从哪个 ip 的哪个端口上发的，可以用来跟踪出现问题语句的用户</td></tr><tr><td>db</td><td>显示这个进程目前连接的是哪个数据库</td></tr><tr><td>Command</td><td>显示当前连接的执行的命令，一般取值为休眠 Sleep、查询 Query、连接 Connect 等</td></tr><tr><td>Time</td><td>显示这个状态持续的时间，单位是秒</td></tr><tr><td>State</td><td>显示使用当前连接的 sql 语句的状态，以查询为例，需要经过 copying to tmp table、sorting result、sending data等状态才可以完成</td></tr><tr><td>Info</td><td>显示执行的 sql 语句，是判断问题语句的一个重要依据</td></tr></tbody></table><p><strong>Sending data 状态</strong>表示 MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅只是返回给客户端，是处于执行器过程中的任意阶段。由于在 Sending data 状态下，MySQL 线程需要做大量磁盘读取操作，所以是整个查询中耗时最长的状态</p><hr><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>当执行完全相同的 SQL 语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存</p><p>查询过程：</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果（一般是 K-V 键值对），否则进入下一阶段</li><li>分析器进行 SQL 分析，再由优化器生成对应的执行计划</li><li>执行器根据优化器生成的执行计划，调用存储引擎的 API 来执行查询</li><li>将结果返回给客户端</li></ol><p>大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利</p><ul><li>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费力地把结果存起来，还没使用就被一个更新全清空了，对于更新压力大的数据库来说，查询缓存的命中率会非常低</li><li>除非业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存</li></ul><hr><h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><ol><li><p>查看当前 MySQL 数据库是否支持查询缓存：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;have_query_cache&#x27;;-- YES</span><br></pre></td></tr></table></figure></li><li><p>查看当前 MySQL 是否开启了查询缓存：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_type&#x27;;-- OFF</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>OFF 或 0：查询缓存功能关闭</p></li><li><p>ON 或 1：查询缓存功能打开，查询结果符合缓存条件即会缓存，否则不予缓存；可以显式指定 SQL_NO_CACHE 不予缓存</p></li><li><p>DEMAND 或 2：查询缓存功能按需进行，显式指定 SQL_CACHE 的 SELECT 语句才缓存，其它不予缓存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer; -- SQL_CACHE:查询结果可缓存</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;-- SQL_NO_CACHE:不使用查询缓存</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看查询缓存的占用大小：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_size&#x27;;-- 单位是字节 1048576 / 1024 = 1024 = 1KB</span><br></pre></td></tr></table></figure></li><li><p>查看查询缓存的状态变量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Qcache%&#x27;;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询缓存的状态变量.png" style="zoom:67%;"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table></li><li><p>配置 my.cnf：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 666 /etc/mysql/my.cnf</span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="comment"># mysqld中配置缓存</span></span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><p>重启服务既可生效，执行 SQL 语句进行验证 ，执行一条比较耗时的 SQL 语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存</p></li></ol><hr><h5 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h5><p>查询缓存失效的情况：</p><ul><li><p>SQL 语句不一致，要想命中查询缓存，查询的 SQL 语句必须一致，因为<strong>缓存中 key 是查询的语句</strong>，value 是查询结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from tb_item;</span><br><span class="line">Select count(*) from tb_item;-- 不走缓存，首字母不一致</span><br></pre></td></tr></table></figure></li><li><p>当查询语句中有一些不确定查询时，则不会缓存，比如：now()、current_date()、curdate()、curtime()、rand()、uuid()、user()、database() </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE updatetime &lt; NOW() LIMIT 1;</span><br><span class="line">SELECT USER();</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure></li><li><p>不使用任何表查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;A&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>查询 mysql、information_schema、performance_schema 等系统表时，不走查询缓存：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.engines;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>跨存储引擎</strong>的存储过程、触发器或存储函数的主体内执行的查询，缓存失效</p></li><li><p>如果表更改，则使用该表的<strong>所有高速缓存查询都将变为无效</strong>并从高速缓存中删除，包括使用 MERGE 映射到已更改表的表的查询，比如：INSERT、UPDATE、DELETE、ALTER TABLE、DROP TABLE、DROP DATABASE</p></li></ul><hr><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>没有命中查询缓存，就开始了 SQL 的真正执行，分析器会对 SQL 语句做解析</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>解析器：处理语法和解析查询，生成一课对应的解析树</p><ul><li>先做<strong>词法分析</strong>，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么代表什么。从输入的 select 这个关键字识别出来这是一个查询语句；把字符串 t 识别成 表名 t，把字符串 id 识别成列 id</li><li>然后做<strong>语法分析</strong>，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果语句不对，就会收到 <code>You have an error in your SQL syntax</code> 的错误提醒</li></ul><p>预处理器：进一步检查解析树的合法性，比如数据表和数据列是否存在、别名是否有歧义等</p><hr><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><h5 id="成本分析"><a href="#成本分析" class="headerlink" title="成本分析"></a>成本分析</h5><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p><ul><li>根据搜索条件找出所有可能的使用的索引</li><li>成本分析，执行成本由 I&#x2F;O 成本和 CPU 成本组成，计算全表扫描和使用不同索引执行 SQL 的代价</li><li>找到一个最优的执行方案，用最小的代价去执行语句</li></ul><p>在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少意味着访问磁盘的次数越少，消耗的 CPU 资源越少，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p><hr><h5 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h5><p>MySQL 中保存着两种统计数据：</p><ul><li>innodb_table_stats 存储了表的统计数据，每一条记录对应着一个表的统计数据</li><li>innodb_index_stats 存储了索引的统计数据，每一条记录对应着一个索引的一个统计项的数据</li></ul><p>MySQL 在真正执行语句之前，并不能精确地知道满足条件的记录有多少条，只能根据统计信息来估算记录，统计信息就是索引的区分度，一个索引上不同的值的个数（比如性别只能是男女，就是 2 ），称之为基数（cardinality），<strong>基数越大说明区分度越好</strong></p><p>通过<strong>采样统计</strong>来获取基数，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p><p>在 MySQL 中，有两种存储统计数据的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p><ul><li>ON：表示统计信息会持久化存储（默认），采样页数 N 默认为 20，可以通过 <code>innodb_stats_persistent_sample_pages</code> 指定，页数越多统计的数据越准确，但消耗的资源更大</li><li>OFF：表示统计信息只存储在内存，采样页数 N 默认为 8，也可以通过系统变量设置（不推荐，每次重新计算浪费资源）</li></ul><p>数据表是会持续更新的，两种统计信息的更新方式：</p><ul><li>设置 <code>innodb_stats_auto_recalc</code> 为 1，当发生变动的记录数量超过表大小的 10% 时，自动触发重新计算，不过是<strong>异步进行</strong></li><li>调用 <code>ANALYZE TABLE t</code> 手动更新统计信息，只对信息做<strong>重新统计</strong>（不是重建表），没有修改数据，这个过程中加了 MDL 读锁并且是同步进行，所以会暂时阻塞系统</li></ul><p><strong>EXPLAIN 执行计划在优化器阶段生成</strong>，如果 explain 的结果预估的 rows 值跟实际情况差距比较大，可以执行 analyze 命令重新修正信息</p><hr><h5 id="错选索引"><a href="#错选索引" class="headerlink" title="错选索引"></a>错选索引</h5><p>采样统计本身是估算数据，或者 SQL 语句中的字段选择有问题时，可能导致 MySQL 没有选择正确的执行索引</p><p>解决方法：</p><ul><li><p>采用 force index 强行选择一个索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> FORCE INDEX(name) <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;seazean&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>可以考虑修改 SQL 语句，引导 MySQL 使用期望的索引</p></li><li><p>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p></li></ul><hr><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>开始执行的时候，要先判断一下当前连接对表有没有<strong>执行查询的权限</strong>，如果没有就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。如果有权限，就打开表继续执行，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p><hr><h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>Server 层和存储引擎层的交互是<strong>以记录为单位的</strong>，存储引擎会将单条记录返回给 Server 层做进一步处理，并不是直接返回所有的记录</p><p>工作流程：</p><ul><li>首先根据二级索引选择扫描范围，获取第一条符合二级索引条件的记录，进行回表查询，将聚簇索引的记录返回 Server 层，由 Server 判断记录是否符合要求</li><li>然后在二级索引上继续扫描下一个符合条件的记录</li></ul><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA">https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA</a></p><hr><h3 id="终止流程"><a href="#终止流程" class="headerlink" title="终止流程"></a>终止流程</h3><h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止线程中正在执行的语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL QUERY thread_id</span><br></pre></td></tr></table></figure><p>KILL 不是马上终止的意思，而是告诉执行线程这条语句已经不需要继续执行，可以开始执行停止的逻辑（类似于打断）。因为对表做增删改查操作，会在表上加 MDL 读锁，如果线程被 KILL 时就直接终止，那这个 MDL 读锁就没机会被释放了</p><p>命令 <code>KILL QUERYthread_id_A</code> 的执行流程：</p><ul><li>把 session A 的运行状态改成 THD::KILL_QUERY（将变量 killed 赋值为 THD::KILL_QUERY）</li><li>给 session A 的执行线程发一个信号，让 session A 来处理这个 THD::KILL_QUERY 状态</li></ul><p>会话处于等待状态（锁阻塞），必须满足是一个可以被唤醒的等待，必须有机会去<strong>判断线程的状态</strong>，如果不满足就会造成 KILL 失败</p><p>典型场景：innodb_thread_concurrency 为 2，代表并发线程上限数设置为 2</p><ul><li>session A 执行事务，session B 执行事务，达到线程上限；此时 session C 执行事务会阻塞等待，session D 执行 kill query C 无效</li><li>C 的逻辑是每 10 毫秒判断是否可以进入 InnoDB 执行，如果不行就调用 nanosleep 函数进入 sleep 状态，没有去判断线程状态</li></ul><p>补充：执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 KILL QUERY 命令</p><hr><h4 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h4><p>断开线程的连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure><p>断开连接后执行 SHOW PROCESSLIST 命令，如果这条语句的 Command 列显示 Killed，代表线程的状态是 KILL_CONNECTION，说明这个线程有语句正在执行，当前状态是停止语句执行中，终止逻辑耗时较长</p><ul><li>超大事务执行期间被 KILL，这时回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长</li><li>大查询回滚，如果查询过程中生成了比较大的临时文件，删除临时文件可能需要等待 IO 资源，导致耗时较长</li><li>DDL 命令执行到最后阶段被 KILL，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久</li></ul><p>总结：KILL CONNECTION 本质上只是把客户端的 SQL 连接断开，后面的终止流程还是要走 KILL QUERY</p><p>一个事务被 KILL 之后，持续处于回滚状态，不应该强行重启整个 MySQL 进程，应该等待事务自己执行完成，因为重启后依然继续做回滚操作的逻辑</p><hr><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>mysql 不是指 mysql 服务，而是指 mysql 的客户端工具</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure><ul><li>-u  –user&#x3D;name：指定用户名</li><li>-p  –password[&#x3D;name]：指定密码</li><li>-h  –host&#x3D;name：指定服务器IP或域名</li><li>-P  –port&#x3D;#：指定连接端口</li><li>-e  –execute&#x3D;name：执行SQL语句并退出，在控制台执行SQL语句，而不用连接到数据库执行</li></ul><p>示例：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line">mysql -uroot -p2143 db01 -e <span class="string">&quot;select * from tb_book&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h4><p>mysqladmin 是一个执行管理操作的客户端程序，用来检查服务器的配置和当前状态、创建并删除数据库等</p><p>通过 <code>mysqladmin --help</code> 指令查看帮助文档</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p2143 create <span class="string">&#x27;test01&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>服务器生成的日志文件以二进制格式保存，如果需要检查这些文本，就要使用 mysqlbinlog 日志管理工具</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [options]  log-files1 log-files2 ...</span><br></pre></td></tr></table></figure><ul><li><p>-d  –database&#x3D;name：指定数据库名称，只列出指定的数据库相关操作</p></li><li><p>-o  –offset&#x3D;#：忽略掉日志中的前 n 行命令。</p></li><li><p>-r  –result-file&#x3D;name：将输出的文本格式日志输出到指定文件。</p></li><li><p>-s  –short-form：显示简单格式，省略掉一些信息。</p></li><li><p>–start-datatime&#x3D;date1  –stop-datetime&#x3D;date2：指定日期间隔内的所有日志</p></li><li><p>–start-position&#x3D;pos1 –stop-position&#x3D;pos2：指定位置间隔内的所有日志</p></li></ul><hr><h4 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h4><h5 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h5><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移，备份内容包含创建表，及插入表的 SQL 语句</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br></pre></td></tr></table></figure><p>连接选项：</p><ul><li>-u  –user&#x3D;name：指定用户名</li><li>-p  –password[&#x3D;name]：指定密码</li><li>-h  –host&#x3D;name：指定服务器 IP 或域名</li><li>-P  –port&#x3D;#：指定连接端口</li></ul><p>输出内容选项：</p><ul><li>–add-drop-database：在每个数据库创建语句前加上 Drop database 语句</li><li>–add-drop-table：在每个表创建语句前加上 Drop table 语句 , 默认开启，不开启 (–skip-add-drop-table)</li><li>-n  –no-create-db：不包含数据库的创建语句</li><li>-t  –no-create-info：不包含数据表的创建语句</li><li>-d –no-data：不包含数据</li><li>-T, –tab&#x3D;name：自动生成两个文件：一个 .sql 文件，创建表结构的语句；一个 .txt 文件，数据文件，相当于 select into outfile</li></ul><p>示例：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a</span><br><span class="line">mysqldump -uroot -p2143 -T /tmp <span class="built_in">test</span> city</span><br></pre></td></tr></table></figure><hr><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><p>命令行方式：</p><ul><li>备份命令：mysqldump -u root -p 数据库名称 &gt; 文件保存路径</li><li>恢复<ol><li>登录MySQL数据库：<code>mysql -u root p</code></li><li>删除已经备份的数据库</li><li>重新创建与备份数据库名称相同的数据库</li><li>使用该数据库</li><li>导入文件执行：<code>source 备份文件全路径</code></li></ol></li></ul><p>更多方式参考：<a href="https://time.geekbang.org/column/article/81925">https://time.geekbang.org/column/article/81925</a></p><p>图形化界面：</p><ul><li><p>备份</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E5%A4%87%E4%BB%BD.png" alt="图形化界面备份"></p></li><li><p>恢复</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%81%A2%E5%A4%8D.png" alt="图形化界面恢复"></p></li></ul><hr><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 <span class="built_in">test</span> /tmp/city.txt</span><br></pre></td></tr></table></figure><p>导入 sql 文件，可以使用 MySQL 中的 source 指令 : </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source 文件全路径</span><br></pre></td></tr></table></figure><hr><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure><ul><li><p>–count：显示数据库及表的统计信息（数据库，表 均可以不指定）</p></li><li><p>-i：显示指定数据库或者指定表的状态信息</p></li></ul><p>示例：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询每个数据库的表的数量及表中记录的数量</span></span><br><span class="line">mysqlshow -uroot -p1234 --count</span><br><span class="line"><span class="comment">#查询test库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> --count</span><br><span class="line"><span class="comment">#查询test库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> book --count</span><br></pre></td></tr></table></figure><hr><h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>SQL</p><ul><li>Structured Query Language：结构化查询语言</li><li>定义了操作所有关系型数据库的规则，每种数据库操作的方式可能会存在不一样的地方，称为“方言”</li></ul></li><li><p>SQL 通用语法</p><ul><li>SQL 语句可以单行或多行书写，以<strong>分号结尾</strong>。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，<strong>关键字建议使用大写</strong>。</li><li>数据库的注释：<ul><li>单行注释：– 注释内容       #注释内容（MySQL 特有）</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul></li><li><p>SQL 分类</p><ul><li><p>DDL（Data Definition Language）数据定义语言</p><ul><li>用来定义数据库对象：数据库，表，列等。关键字：create、drop,、alter 等</li></ul></li><li><p>DML（Data Manipulation Language）数据操作语言</p><ul><li>用来对数据库中表的数据进行增删改。关键字：insert、delete、update 等</li></ul></li><li><p>DQL（Data Query Language）数据查询语言</p><ul><li>用来查询数据库中表的记录(数据)。关键字：select、where 等</li></ul></li><li><p>DCL（Data Control Language）数据控制语言</p><ul><li>用来定义数据库的访问权限和安全级别，及创建用户。关键字：grant， revoke等</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E5%88%86%E7%B1%BB.png"></p></li></ul></li></ul><hr><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><ul><li><p>R(Retrieve)：查询</p><ul><li><p>查询所有数据库：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>查询某个数据库的创建语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名称;  <span class="comment">-- 标准语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mysql;     <span class="comment">-- 查看mysql数据库的创建格式</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>C(Create)：创建</p><ul><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称;-- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE DATABASE db1;     -- 创建db1数据库</span><br></pre></td></tr></table></figure></li><li><p>创建数据库（判断，如果不存在则创建）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库，并指定字符集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure></li><li><p>例如：创建db4数据库、如果不存在则创建，指定字符集为gbk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库、如果不存在则创建，指定字符集为gbk</span><br><span class="line">CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">-- 查看db4数据库的字符集</span><br><span class="line">SHOW CREATE DATABASE db4;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>U(Update)：修改</p><ul><li><p>修改数据库的字符集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure></li><li><p>常用字符集：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--查询所有支持的字符集</span><br><span class="line">SHOW CHARSET;</span><br><span class="line">--查看所有支持的校对规则</span><br><span class="line">SHOW COLLATION;</span><br><span class="line"></span><br><span class="line">-- 字符集: utf8,latinI,GBK,,GBK是utf8的子集</span><br><span class="line">-- 校对规则: ci 大小定不敏感，cs或bin大小写敏感</span><br></pre></td></tr></table></figure></li></ul></li><li><p>D(Delete)：删除</p><ul><li><p>删除数据库：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库(判断，如果存在则删除)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名称;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用数据库：</p><ul><li><p>查询当前正在使用的数据库名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure></li><li><p>使用数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名称； -- 标准语法</span><br><span class="line">USE db4;   -- 使用db4数据库</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h4><ul><li><p>R(Retrieve)：查询</p><ul><li><p>查询数据库中所有的数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;-- 使用mysql数据库</span><br><span class="line"></span><br><span class="line">SHOW TABLES;-- 查询库中所有的表</span><br></pre></td></tr></table></figure></li><li><p>查询表结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure></li><li><p>查询表字符集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 库名 LIKE &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>C(Create)：创建</p><ul><li><p>创建数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名1 数据类型1,</span><br><span class="line">    列名2 数据类型2,</span><br><span class="line">    ....</span><br><span class="line">    列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">-- 注意：最后一列，不需要加逗号</span><br></pre></td></tr></table></figure></li><li><p>复制表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 被复制的表名;  -- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE TABLE product2 LIKE product; -- 复制product表到product2表</span><br></pre></td></tr></table></figure></li><li><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整数类型</td></tr><tr><td>DOUBLE</td><td>小数类型</td></tr><tr><td>DATE</td><td>日期，只包含年月日：yyyy-MM-dd</td></tr><tr><td>DATETIME</td><td>日期，包含年月日时分秒：yyyy-MM-dd HH:mm:ss</td></tr><tr><td>TIMESTAMP</td><td>时间戳类型，包含年月日时分秒：yyyy-MM-dd HH:mm:ss<br>如果不给这个字段赋值或赋值为 NULL，则默认使用当前的系统时间</td></tr><tr><td>CHAR</td><td>字符串，定长类型</td></tr><tr><td>VARCHAR</td><td>字符串，<strong>变长类型</strong><br>name varchar(20) 代表姓名最大 20 个字符：zhangsan 8 个字符，张三 2 个字符</td></tr></tbody></table><p><code>INT(n)</code>：n 代表位数</p><ul><li>3：int（9）显示结果为 000000010</li><li>3：int（3）显示结果为 010</li></ul><p><code>varchar(n)</code>：n 表示的是字符数</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用db3数据库</span><br><span class="line">USE db3;</span><br><span class="line"></span><br><span class="line">-- 创建一个product商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">id INT,-- 商品编号</span><br><span class="line">NAME VARCHAR(30),-- 商品名称</span><br><span class="line">price DOUBLE,-- 商品价格</span><br><span class="line">stock INT,-- 商品库存</span><br><span class="line">insert_time DATE    -- 上架时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​    </p><ul><li><p>U(Update)：修改</p><ul><li><p>修改表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新的表名;</span><br></pre></td></tr></table></figure></li><li><p>修改表的字符集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure></li><li><p>添加一列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li><p>修改列数据类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li><p>修改列名称和数据类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 列名;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>D(Delete)：删除</p><ul><li><p>删除数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure></li><li><p>删除数据表(判断，如果存在则删除)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><ul><li><p>新增表数据</p><ul><li><p>新增格式 1：给指定列添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2...) VALUES (值1,值2...);</span><br></pre></td></tr></table></figure></li><li><p>新增格式 2：默认给全部列添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure></li><li><p>新增格式 3：批量添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给指定列批量添加数据</span><br><span class="line">INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...)...;</span><br><span class="line"></span><br><span class="line">-- 默认给所有列批量添加数据 </span><br><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...)...;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串拼接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONCAT(string1,string2,&#x27;&#x27;,...)</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>列名和值的数量以及数据类型要对应</li><li>除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引)</li></ul></li></ul><hr><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><ul><li><p>修改表数据语法</p><ul><li><p>标准语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];</span><br></pre></td></tr></table></figure></li><li><p>修改电视的价格为1800、库存为36</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE product SET price=1800,stock=36 WHERE NAME=&#x27;电视&#x27;;</span><br><span class="line">SELECT * FROM product;-- 查看所有商品信息</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意事项</p><ul><li>修改语句中必须加条件</li><li>如果不加条件，则将所有数据都修改</li></ul></li></ul><hr><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul><li><p>删除表数据语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>删除语句中必须加条件</li><li>如果不加条件，则将所有数据删除</li></ul></li></ul><p>​    </p><hr><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><p>数据库查询遵循条件在前的原则</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">&lt;select list&gt;</span><br><span class="line">FROM</span><br><span class="line">&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">JOIN</span><br><span class="line">&lt;right_table&gt; ON &lt;join_condition&gt;-- 连接查询在多表查询部分详解</span><br><span class="line">WHERE</span><br><span class="line">&lt;where_condition&gt;</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;group_by_list&gt;</span><br><span class="line">HAVING</span><br><span class="line">&lt;having_condition&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;order_by_condition&gt;</span><br><span class="line">LIMIT</span><br><span class="line">&lt;limit_params&gt;</span><br></pre></td></tr></table></figure><p>执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM&lt;left_table&gt;</span><br><span class="line"></span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class="line"></span><br><span class="line">WHERE&lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line">HAVING&lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT&lt;select list&gt;</span><br><span class="line"></span><br><span class="line">ORDER BY&lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line">LIMIT&lt;limit_params&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h4><ul><li><p>查询全部的表数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 标准语法</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line">-- 查询product表所有数据(常用)</span><br><span class="line">SELECT * FROM product;</span><br></pre></td></tr></table></figure></li><li><p>查询指定字段的表数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure></li><li><p><strong>去除重复查询</strong>：只有值全部重复的才可以去除，需要创建临时表辅助查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure></li><li><p>计算列的值（四则运算）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;</span><br><span class="line"></span><br><span class="line">/*如果某一列值为null，可以进行替换</span><br><span class="line">ifnull(表达式1,表达式2)</span><br><span class="line">表达式1：想替换的列</span><br><span class="line">表达式2：想替换的值*/</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10</span><br><span class="line">SELECT NAME,stock+10 FROM product;</span><br><span class="line"></span><br><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 FROM product;</span><br></pre></td></tr></table></figure></li><li><p><strong>起别名</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... AS 别名 FROM 表名;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断，起别名为getSum,AS可以省略。</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 getsum FROM product;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li><p>条件查询语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure></li><li><p>条件分类</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围之内(都包含)</td></tr><tr><td>IN(…)</td><td>多选一</td></tr><tr><td>LIKE</td><td><strong>模糊查询</strong>：_单个任意字符、%任意个字符、[] 匹配集合内的字符<br><code>LIKE &#39;[^AB]%&#39; </code>：不以 A 和 B 开头的任意文本</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr><tr><td>IS NOT NULL</td><td>不是NULL</td></tr><tr><td>AND 或 &amp;&amp;</td><td>并且</td></tr><tr><td>OR 或 ||</td><td>或者</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr><tr><td>UNION</td><td>对两个结果集进行<strong>并集操作并进行去重，同时进行默认规则的排序</strong></td></tr><tr><td>UNION ALL</td><td>对两个结果集进行并集操作不进行去重，不进行排序</td></tr></tbody></table></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询库存大于20的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock &gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询品牌为华为的商品信息</span><br><span class="line">SELECT * FROM product WHERE brand=&#x27;华为&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询金额在4000 ~ 6000之间的商品信息</span><br><span class="line">SELECT * FROM product WHERE price &gt;= 4000 AND price &lt;= 6000;</span><br><span class="line">SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;</span><br><span class="line"></span><br><span class="line">-- 查询库存为14、30、23的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;</span><br><span class="line">SELECT * FROM product WHERE stock IN(14,30,23);</span><br><span class="line"></span><br><span class="line">-- 查询库存为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NULL;</span><br><span class="line">-- 查询库存不为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询名称以&#x27;小米&#x27;为开头的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;小米%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称第二个字是&#x27;为&#x27;的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;_为%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称为四个字符的商品信息 4个下划线</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;____&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含电脑的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%电脑%&#x27;;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL数据准备.png" style="zoom: 80%;"></li></ul><hr><h4 id="函数查询"><a href="#函数查询" class="headerlink" title="函数查询"></a>函数查询</h4><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>聚合函数：将一列数据作为一个整体，进行纵向的计算</p><ul><li><p>聚合函数语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(列名) FROM 表名 [WHERE 条件]</span><br></pre></td></tr></table></figure></li><li><p>聚合函数分类</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>COUNT(列名)</td><td>统计数量（一般选用不为 null 的列）</td></tr><tr><td>MAX(列名)</td><td>最大值</td></tr><tr><td>MIN(列名)</td><td>最小值</td></tr><tr><td>SUM(列名)</td><td>求和</td></tr><tr><td>AVG(列名)</td><td>平均值（会忽略 null 行）</td></tr></tbody></table></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算product表中总记录条数 7</span><br><span class="line">SELECT COUNT(*) FROM product;</span><br><span class="line"></span><br><span class="line">-- 获取最高价格</span><br><span class="line">SELECT MAX(price) FROM product;</span><br><span class="line">-- 获取最高价格的商品名称</span><br><span class="line">SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取最低库存</span><br><span class="line">SELECT MIN(stock) FROM product;</span><br><span class="line">-- 获取最低库存的商品名称</span><br><span class="line">SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取总库存数量</span><br><span class="line">SELECT SUM(stock) FROM product;</span><br><span class="line">-- 获取品牌为小米的平均商品价格</span><br><span class="line">SELECT AVG(price) FROM product WHERE brand=&#x27;小米&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h5><p>CONCAT()：用于连接两个字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="comment">-- 许多数据库会使用空格把一个值填充为列宽，连接的结果出现一些不必要的空格，使用TRIM()可以去除首尾空格</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><hr><h5 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h5><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><hr><h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和  SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><hr><h4 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;^T&#x27;;-- 匹配以T开头的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;2$&#x27;;-- 匹配以2结尾的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;[uvw]&#x27;;-- 匹配包含 uvw 的name值</span><br></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><hr><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul><li><p>排序查询语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC:升序</span><br><span class="line">DESC:降序</span><br></pre></td></tr></table></figure><p>注意：多个排序条件，当前边的条件值一样时，才会判断第二条件</p></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照库存升序排序</span><br><span class="line">SELECT * FROM product ORDER BY stock ASC;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含手机的商品信息。按照金额降序排序</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%手机%&#x27; ORDER BY price DESC;</span><br><span class="line"></span><br><span class="line">-- 按照金额升序排序，如果金额相同，按照库存降序排列</span><br><span class="line">SELECT * FROM product ORDER BY price ASC,stock DESC;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>分组查询会进行去重</p><ul><li><p>分组查询语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];</span><br></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤</p><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前</li><li>NULL 的行会单独分为一组</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li></ul></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照品牌分组，获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product WHERE price &gt; 4000 GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000 ORDER BY getSum DESC;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p>分页查询语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;</span><br></pre></td></tr></table></figure></li><li><p>公式：开始索引 &#x3D; (当前页码-1) * 每页显示的条数</p></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product LIMIT 0,2;  -- 第一页 开始索引=(1-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 2,2;  -- 第二页 开始索引=(2-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 4,2;  -- 第三页 开始索引=(3-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 6,2;  -- 第四页 开始索引=(4-1) * 2</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"></p></li></ul><hr><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><h4 id="约束介绍"><a href="#约束介绍" class="headerlink" title="约束介绍"></a>约束介绍</h4><p>约束：对表中的数据进行限定，保证数据的正确性、有效性、完整性</p><p>约束的分类：</p><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>PRIMARY KEY</td><td>主键约束</td></tr><tr><td>PRIMARY KEY AUTO_INCREMENT</td><td>主键、自动增长</td></tr><tr><td>UNIQUE</td><td>唯一约束</td></tr><tr><td>NOT NULL</td><td>非空约束</td></tr><tr><td>FOREIGN KEY</td><td>外键约束</td></tr><tr><td>FOREIGN KEY ON UPDATE CASCADE</td><td>外键级联更新</td></tr><tr><td>FOREIGN KEY ON DELETE CASCADE</td><td>外键级联删除</td></tr></tbody></table><hr><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul><li><p>主键约束特点：</p><ul><li>主键约束默认包含<strong>非空和唯一</strong>两个功能</li><li>一张表只能有一个主键</li><li>主键一般用于表中数据的唯一标识</li></ul></li><li><p>建表时添加主键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 PRIMARY KEY,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除主键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure></li><li><p>建表后单独添加主键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;</span><br></pre></td></tr></table></figure></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT PRIMARY KEY  -- 给id添加主键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (1),(2);</span><br><span class="line">-- 主键默认唯一，添加重复数据，会报错</span><br><span class="line">INSERT INTO student VALUES (2);</span><br><span class="line">-- 主键默认非空，不能添加null的数据</span><br><span class="line">INSERT INTO student VALUES (NULL);</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><p>主键自增约束可以为空，并自动增长。删除某条数据不影响自增的下一个数值，依然按照前一个值自增</p><ul><li><p>建表时添加主键自增约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除主键自增约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li><p>建表后单独添加主键自增约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;</span><br></pre></td></tr></table></figure></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student2表</span><br><span class="line">CREATE TABLE student2(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT    -- 给id添加主键自增约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student2 VALUES (1),(2);</span><br><span class="line">-- 添加null值，会自动增长</span><br><span class="line">INSERT INTO student2 VALUES (NULL),(NULL);-- 3，4</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>唯一约束：约束不能有重复的数据</p><ul><li><p>建表时添加唯一约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 UNIQUE,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除唯一约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 列名;</span><br></pre></td></tr></table></figure></li><li><p>建表后单独添加唯一约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul><li><p>建表时添加非空约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 NOT NULL,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除非空约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li><p>建表后单独添加非空约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>  外键约束：让表和表之间产生关系，从而保证数据的准确性</p><ul><li><p>建表时添加外键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 约束,</span><br><span class="line">    ...</span><br><span class="line">    CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除外键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure></li><li><p>建表后单独添加外键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名);</span><br></pre></td></tr></table></figure></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user用户表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">name VARCHAR(20) NOT NULL             -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加用户数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;),(NULL,&#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">number VARCHAR(20) NOT NULL,          -- 订单编号</span><br><span class="line">uid INT,                              -- 订单所属用户</span><br><span class="line">CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加订单数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),</span><br><span class="line">(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2),</span><br><span class="line">(NULL,&#x27;hm005&#x27;,3),(NULL,&#x27;hm006&#x27;,3);</span><br><span class="line"></span><br><span class="line">-- 添加一个订单，但是没有所属用户。无法添加</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm007&#x27;,8);</span><br><span class="line">-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除</span><br><span class="line">DELETE FROM USER WHERE NAME=&#x27;王五&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="外键级联"><a href="#外键级联" class="headerlink" title="外键级联"></a>外键级联</h4><p>级联操作：当把主表中的数据进行删除或更新时，从表中有关联的数据的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION</p><ul><li><p>RESTRICT 和 NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新</p></li><li><p>CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录</p></li><li><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL</p></li></ul><p>级联操作：</p><ul><li><p>添加级联更新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE [CASCADE | RESTRICT | SET NULL];</span><br></pre></td></tr></table></figure></li><li><p>添加级联删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure></li><li><p>同时添加级联更新和级联删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>多表：有多张数据表，而表与表之间有一定的关联关系，通过外键约束实现，分为一对一、一对多、多对多三类</p><p>举例：人和身份证</p><p>实现原则：在任意一个表建立外键，去关联另外一个表的主键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建person表</span><br><span class="line">CREATE TABLE person(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO person VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建card表</span><br><span class="line">CREATE TABLE card(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">number VARCHAR(20) UNIQUE NOT NULL,-- 身份证号</span><br><span class="line">pid INT UNIQUE,                         -- 外键列</span><br><span class="line">CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;56789&#x27;,2);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E4%B8%80.png"></p><hr><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>举例：用户和订单、商品分类和商品</p><p>实现原则：在多的一方，建立外键约束，来关联一的一方主键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">number VARCHAR(20),                     -- 订单编号</span><br><span class="line">uid INT,-- 外键列</span><br><span class="line">CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="多表设计一对多"></p><hr><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>举例：学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择</p><p>实现原则：借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">NAME VARCHAR(20)-- 学生姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建course表</span><br><span class="line">CREATE TABLE course(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">NAME VARCHAR(10)-- 课程名称</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建中间表</span><br><span class="line">CREATE TABLE stu_course(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 主键id</span><br><span class="line">sid INT,  -- 用于和student表中的id进行外键关联</span><br><span class="line">cid INT,  -- 用于和course表中的id进行外键关联</span><br><span class="line">CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束</span><br><span class="line">CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%A4%9A%E5%AF%B9%E5%A4%9A.png"></p><hr><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内外连接"><a href="#内外连接" class="headerlink" title="内外连接"></a>内外连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>连接查询的是两张表有交集的部分数据，两张表分为<strong>驱动表和被驱动表</strong>，如果结果集中的每条记录都是两个表相互匹配的组合，则称这样的结果集为笛卡尔积</p><p>内连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录不会加到最后的结果集</p><ul><li><p>显式内连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure></li><li><p>隐式内连接：内连接中 WHERE 子句和 ON 子句是等价的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1,表名2 WHERE 条件;</span><br></pre></td></tr></table></figure></li></ul><p>STRAIGHT_JOIN与 JOIN 类似，只不过左表始终在右表之前读取，只适用于内连接</p><hr><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录也会加到最后的结果集，只是对于被驱动表中<strong>不匹配过滤条件</strong>的记录，各个字段使用 NULL 填充</p><p>应用实例：查学生成绩，也想展示出缺考的人的成绩</p><ul><li><p>左外连接：选择左侧的表为驱动表，查询左表的全部数据，和左右两张表有交集部分的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure></li><li><p>右外连接：选择右侧的表为驱动表，查询右表的全部数据，和左右两张表有交集部分的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-JOIN%E6%9F%A5%E8%AF%A2%E5%9B%BE.png"></p><hr><h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>自关联查询：同一张表中有数据关联，可以多次查询这同一个表</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建员工表</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 员工编号</span><br><span class="line">NAME VARCHAR(20),-- 员工姓名</span><br><span class="line">mgr INT,-- 上级编号</span><br><span class="line">salary DOUBLE-- 员工工资</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO employee VALUES (1001,&#x27;孙悟空&#x27;,1005,9000.00),..,(1009,&#x27;宋江&#x27;,NULL,16000.00);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87.png"></p></li><li><p>数据查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询</span><br><span class="line">/*</span><br><span class="line">分析</span><br><span class="line">员工信息 employee表</span><br><span class="line">条件：employee.mgr = employee.id</span><br><span class="line">查询左表的全部数据，和左右两张表有交集部分数据，左外连接</span><br><span class="line">*/</span><br><span class="line">SELECT</span><br><span class="line">e1.id,</span><br><span class="line">e1.name,</span><br><span class="line">e1.mgr,</span><br><span class="line">e2.id,</span><br><span class="line">e2.name</span><br><span class="line">FROM</span><br><span class="line">employee e1</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">employee e2</span><br><span class="line">ON</span><br><span class="line">e1.mgr = e2.id;</span><br></pre></td></tr></table></figure></li><li><p>查询结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idnamemgr   id  name</span><br><span class="line">1001孙悟空  10051005唐僧</span><br><span class="line">1002猪八戒  10051005唐僧</span><br><span class="line">1003沙和尚  10051005唐僧</span><br><span class="line">1004小白龙  10051005唐僧</span><br><span class="line">1005唐僧   NULL NULL NULL</span><br><span class="line">1006武松   1009 1009 宋江</span><br><span class="line">1007李逵   1009 1009 宋江</span><br><span class="line">1008林冲   1009 1009 宋江</span><br><span class="line">1009宋江   NULL NULL NULL</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h4><p>Index Nested-Loop Join 算法：查询驱动表得到<strong>数据集</strong>，然后根据数据集中的每一条记录的<strong>关联字段再分别</strong>到被驱动表中查找匹配（<strong>走索引</strong>），所以驱动表只需要访问一次，被驱动表要访问多次</p><p>MySQL 将查询驱动表后得到的记录成为驱动表的扇出，连接查询的成本：单次访问驱动表的成本 + 扇出值 * 单次访问被驱动表的成本，优化器会选择成本最小的表连接顺序（确定谁是驱动表，谁是被驱动表）生成执行计划，进行连接查询，优化方式：</p><ul><li>减少驱动表的扇出（让数据量小的表来做驱动表）</li><li>降低访问被驱动表的成本</li></ul><p>说明：STRAIGHT_JOIN 是查一条驱动表，然后根据关联字段去查被驱动表，要访问多次驱动表，所以需要优化为 INL 算法</p><p>Block Nested-Loop Join 算法：一种<strong>空间换时间</strong>的优化方式，基于块的循环连接，执行连接查询前申请一块固定大小的内存作为连接缓冲区 Join Buffer，先把若干条驱动表中的扇出暂存在缓冲区，每一条被驱动表中的记录一次性的与 Buffer 中多条记录进行匹配（扫描全部数据，一条一条的匹配），因为是在内存中完成，所以速度快，并且降低了 I&#x2F;O 成本</p><p>Join Buffer 可以通过参数 <code>join_buffer_size</code> 进行配置，默认大小是 256 KB</p><p>在成本分析时，对于很多张表的连接查询，连接顺序有非常多，MySQL 如果挨着进行遍历计算成本，会消耗很多资源</p><ul><li><p>提前结束某种连接顺序的成本评估：维护一个全局变量记录当前成本最小的连接方式，如果一种顺序只计算了一部分就已经超过了最小成本，可以提前结束计算</p></li><li><p>系统变量 optimizer_search_depth：如果连接表的个数小于该变量，就继续穷举分析每一种连接数量，反之只对数量与 depth 值相同的表进行分析，该值越大成本分析的越精确</p></li><li><p>系统变量 optimizer_prune_level：控制启发式规则的启用，这些规则就是根据以往经验指定的，不满足规则的连接顺序不分析成本</p></li></ul><hr><h4 id="连接优化"><a href="#连接优化" class="headerlink" title="连接优化"></a>连接优化</h4><h5 id="BKA"><a href="#BKA" class="headerlink" title="BKA"></a>BKA</h5><p>Batched Key Access 算法是对 NLJ 算法的优化，在读取被驱动表的记录时使用顺序 IO，Extra 信息中会有 Batched Key Access 信息</p><p>使用 BKA 的表的 JOIN 过程如下：</p><ul><li>连接驱动表将满足条件的记录放入 Join Buffer，并将两表连接的字段放入一个 DYNAMIC_ARRAY ranges 中</li><li>在进行表的过接过程中，会将 ranges 相关的信息传入 Buffer 中，进行被驱动表主建的查找及排序操作</li><li>调用步骤 2 中产生的有序主建，<strong>顺序读取被驱动表的数据</strong></li><li>当缓冲区的数据被读完后，会重复进行步骤 2、3，直到记录被读取完</li></ul><p>使用 BKA 优化需要设进行设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;</span><br></pre></td></tr></table></figure><p>说明：前两个参数的作用是启用 MRR，因为 BKA 算法的优化要依赖于 MRR（系统优化 → 内存优化 → Read 详解）</p><hr><h5 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h5><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>BNL 即 Block Nested-Loop Join 算法，由于要访问多次被驱动表，会产生两个问题：</p><ul><li><p>Join 语句多次扫描一个冷表，并且语句执行时间小于 1 秒，就会在再次扫描冷表时，把冷表的数据页移到 LRU 链表头部，导致热数据被淘汰，影响业务的正常运行</p><p>这种情况冷表的数据量要小于整个 Buffer Pool 的 old 区域，能够完全放入 old 区，才会再次被读时加到 young，否则读取下一段时就已经把上一段淘汰</p></li><li><p>Join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页很可能在 1 秒之内就被淘汰，就会导致 MySQL 实例的 Buffer Pool 在这段时间内 young 区域的数据页没有被合理地淘汰</p></li></ul><p>大表 Join 操作虽然对 IO 有影响，但是在语句执行结束后对 IO 的影响随之结束。但是对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率</p><h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>将 BNL 算法转成 BKA 算法，优化方向：</p><ul><li>在被驱动表上建索引，这样就可以根据索引进行顺序 IO</li><li>使用临时表，<strong>在临时表上建立索引</strong>，将被驱动表和临时表进行连接查询</li></ul><p>驱动表 t1，被驱动表 t2，使用临时表的工作流程：</p><ul><li>把表 t1 中满足条件的数据放在临时表 tmp_t 中</li><li>给临时表 tmp_t 的关联字段加上索引，使用 BKA 算法</li><li>让表 t2 和 tmp_t 做 Join 操作（临时表是被驱动表）</li></ul><p>补充：MySQL 8.0 支持 hash join，join_buffer 维护的不再是一个无序数组，而是一个哈希表，查询效率更高，执行效率比临时表更高</p><hr><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><h4 id="查询分类"><a href="#查询分类" class="headerlink" title="查询分类"></a>查询分类</h4><p>查询语句中嵌套了查询语句，<strong>将嵌套查询称为子查询</strong>，FROM 子句后面的子查询的结果集称为派生表</p><p>根据结果分类：</p><ul><li><p>结果是单行单列：可以将查询的结果作为另一条语句的查询条件，使用运算符判断</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名/聚合函数(列名) FROM 表名 [WHERE 条件]);</span><br></pre></td></tr></table></figure></li><li><p>结果是多行单列：可以作为条件，使用运算符 IN 或 NOT IN 进行判断</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); </span><br></pre></td></tr></table></figure></li><li><p>结果是多行多列：查询的结果可以作为一张虚拟表参与查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];</span><br><span class="line"></span><br><span class="line">-- 查询订单表orderlist中id大于4的订单信息和所属用户USER信息</span><br><span class="line">SELECT </span><br><span class="line">* </span><br><span class="line">FROM </span><br><span class="line">USER u,</span><br><span class="line">(SELECT * FROM orderlist WHERE id&gt;4) o </span><br><span class="line">WHERE </span><br><span class="line">u.id=o.uid;</span><br></pre></td></tr></table></figure></li></ul><p>相关性分类：</p><ul><li>不相关子查询：子查询不依赖外层查询的值，可以单独运行出结果</li><li>相关子查询：子查询的执行需要依赖外层查询的值</li></ul><hr><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>不相关子查询的结果集会被写入一个临时表，并且在写入时<strong>去重</strong>，该过程称为<strong>物化</strong>，存储结果集的临时表称为物化表</p><p>系统变量 tmp_table_size 或者 max_heap_table_size 为表的最值</p><ul><li>小于系统变量时，内存中可以保存，会为建立<strong>基于内存</strong>的 MEMORY 存储引擎的临时表，并建立哈希索引</li><li>大于任意一个系统变量时，物化表会使用<strong>基于磁盘</strong>的 InnoDB 存储引擎来保存结果集中的记录，索引类型为 B+ 树</li></ul><p>物化后，嵌套查询就相当于外层查询的表和物化表进行内连接查询，然后经过优化器选择成本最小的表连接顺序执行查询</p><p>子查询物化会产生建立临时表的成本，但是将子查询转化为连接查询可以充分发挥优化器的作用，所以引入：半连接</p><ul><li>t1 和 t2 表进行半连接，对于 t1 表中的某条记录，只需要关心在 t2 表中是否存在，而不需要关心有多少条记录与之匹配，最终结果集只保留 t1 的记录</li><li>半连接只是执行子查询的一种方式，MySQL 并没有提供面向用户的半连接语法</li></ul><p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p><hr><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>UNION 是取这两个子查询结果的并集，并进行去重，同时进行默认规则的排序（union 是行加起来，join 是列加起来）</p><p>UNION ALL 是对两个结果集进行并集操作不进行去重，不进行排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select 1000 as f) union (select id from t1 order by id desc limit 2); #t1表中包含id 为 1-1000 的数据</span><br></pre></td></tr></table></figure><p>语句的执行流程：</p><ul><li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段</li><li>执行第一个子查询，得到 1000 这个值，并存入临时表中</li><li>执行第二个子查询，拿到第一行 id&#x3D;1000，试图插入临时表中，但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行</li><li>取到第二行 id&#x3D;999，插入临时表成功</li><li>从临时表中按行取出数据，返回结果并删除临时表，结果中包含两行数据分别是 1000 和 999</li></ul><hr><h3 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h3><p>数据准备：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库</span><br><span class="line">CREATE DATABASE db4;</span><br><span class="line">-- 使用db4数据库</span><br><span class="line">USE db4;</span><br><span class="line"></span><br><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 用户id</span><br><span class="line">NAME VARCHAR(20),-- 用户姓名</span><br><span class="line">age INT                             -- 用户年龄</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 订单id</span><br><span class="line">number VARCHAR(30),-- 订单编号</span><br><span class="line">uid INT,   -- 外键字段</span><br><span class="line">CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品分类表</span><br><span class="line">CREATE TABLE category(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id</span><br><span class="line">NAME VARCHAR(10)                    -- 商品分类名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id</span><br><span class="line">NAME VARCHAR(30),                    -- 商品名称</span><br><span class="line">cid INT, -- 外键字段</span><br><span class="line">CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 中间表</span><br><span class="line">CREATE TABLE us_pro(</span><br><span class="line">upid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id</span><br><span class="line">uid INT,   -- 外键字段。需要和用户表的主键产生关联</span><br><span class="line">pid INT,  -- 外键字段。需要和商品表的主键产生关联</span><br><span class="line">CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),</span><br><span class="line">CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E7%BB%83%E4%B9%A0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="多表练习架构设计"></p><p><strong>数据查询：</strong></p><ol><li><p>查询用户的编号、姓名、年龄、订单编号</p><p>数据：用户的编号、姓名、年龄在 user 表，订单编号在 orderlist 表</p><p>条件：user.id &#x3D; orderlist.uid</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.*,</span><br><span class="line">o.number</span><br><span class="line">FROM</span><br><span class="line">USER u,</span><br><span class="line">orderlist o</span><br><span class="line">WHERE</span><br><span class="line">u.id = o.uid;</span><br></pre></td></tr></table></figure></li><li><p>查询所有的用户，显示用户的编号、姓名、年龄、订单编号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.*,</span><br><span class="line">o.number</span><br><span class="line">FROM</span><br><span class="line">USER u</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">orderlist o</span><br><span class="line">ON</span><br><span class="line">u.id = o.uid;</span><br></pre></td></tr></table></figure></li><li><p>查询用户年龄大于 23 岁的信息，显示用户的编号、姓名、年龄、订单编号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.*,</span><br><span class="line">o.number</span><br><span class="line">FROM</span><br><span class="line">USER u,</span><br><span class="line">orderlist o</span><br><span class="line">WHERE</span><br><span class="line">u.id = o.uid</span><br><span class="line">AND</span><br><span class="line">u.age &gt; 23;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.*,</span><br><span class="line">o.number</span><br><span class="line">FROM</span><br><span class="line">(SELECT * FROM USER WHERE age &gt; 23) u,-- 嵌套查询</span><br><span class="line">orderlist o</span><br><span class="line">WHERE</span><br><span class="line">u.id = o.uid;</span><br></pre></td></tr></table></figure></li><li><p>查询张三和李四用户的信息，显示用户的编号、姓名、年龄、订单编号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.*,</span><br><span class="line">o.number</span><br><span class="line">FROM</span><br><span class="line">USER u,</span><br><span class="line">orderlist o</span><br><span class="line">WHERE</span><br><span class="line">u.id=o.uid</span><br><span class="line">AND</span><br><span class="line">u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>查询所有的用户和该用户能查看的所有的商品，显示用户的编号、姓名、年龄、商品名称</p><p>数据：用户的编号、姓名、年龄在 user 表，商品名称在 product 表，中间表 us_pro</p><p>条件：us_pro.uid &#x3D; user.id AND us_pro.pid &#x3D; product.id</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.id,</span><br><span class="line">u.name,</span><br><span class="line">u.age,</span><br><span class="line">p.name</span><br><span class="line">FROM</span><br><span class="line">USER u,</span><br><span class="line">product p,</span><br><span class="line">us_pro up</span><br><span class="line">WHERE</span><br><span class="line">up.uid = u.id</span><br><span class="line">AND</span><br><span class="line">up.pid=p.id;</span><br></pre></td></tr></table></figure></li><li><p>查询张三和李四这两个用户可以看到的商品，显示用户的编号、姓名、年龄、商品名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">u.id,</span><br><span class="line">u.name,</span><br><span class="line">u.age,</span><br><span class="line">p.name</span><br><span class="line">FROM</span><br><span class="line">USER u,</span><br><span class="line">product p,</span><br><span class="line">us_pro up</span><br><span class="line">WHERE</span><br><span class="line">up.uid=u.id</span><br><span class="line">AND</span><br><span class="line">up.pid=p.id</span><br><span class="line">AND</span><br><span class="line">u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>视图概念：视图是一种虚拟存在的数据表，这个虚拟的表并不在数据库中实际存在</p><p>本质：将一条 SELECT 查询语句的结果封装到了一个虚拟表中，所以在创建视图的时候，工作重心要放在这条 SELECT 查询语句上</p><p>作用：将一些比较复杂的查询语句的结果，封装到一个虚拟表中，再有相同查询需求时，直接查询该虚拟表</p><p>优点：</p><ul><li><p>简单：使用视图的用户不需要关心表的结构、关联条件和筛选条件，因为虚拟表中已经是过滤好的结果集</p></li><li><p>安全：使用视图的用户只能访问查询的结果集，对表的权限管理并不能限制到某个行某个列</p></li><li><p>数据独立，一旦视图的结构确定，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</p></li></ul><hr><h4 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h4><ul><li><p>创建视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION];</span><br></pre></td></tr></table></figure><p><code>WITH [CASCADED | LOCAL] CHECK OPTION</code> 决定了是否允许更新数据使记录不再满足视图的条件：</p><ul><li>LOCAL：只要满足本视图的条件就可以更新</li><li>CASCADED：必须满足所有针对该视图的所有视图的条件才可以更新， 默认值</li></ul></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据准备 city</span><br><span class="line">idNAMEcid</span><br><span class="line">1深圳 1</span><br><span class="line">2上海1</span><br><span class="line">3纽约2</span><br><span class="line">4莫斯科    3</span><br><span class="line"></span><br><span class="line">-- 数据准备 country</span><br><span class="line">idNAME</span><br><span class="line">1中国</span><br><span class="line">2美国</span><br><span class="line">3俄罗斯</span><br><span class="line"></span><br><span class="line">-- 创建city_country视图，保存城市和国家的信息(使用指定列名)</span><br><span class="line">CREATE </span><br><span class="line">VIEW </span><br><span class="line">city_country (city_id,city_name,country_name)</span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h4><ul><li><p>查询所有数据表，视图也会查询出来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">SHOW TABLE STATUS [\G];</span><br></pre></td></tr></table></figure></li><li><p>查询视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 视图名称;</span><br></pre></td></tr></table></figure></li><li><p>查询某个视图创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="视图修改"><a href="#视图修改" class="headerlink" title="视图修改"></a>视图修改</h4><p>视图表数据修改，会<strong>自动修改源表中的数据</strong>，因为更新的是视图中的基表中的数据</p><ul><li><p>修改视图表中的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 视图名称 SET 列名 = 值 WHERE 条件;</span><br></pre></td></tr></table></figure></li><li><p>修改视图的结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br><span class="line"></span><br><span class="line">-- 将视图中的country_name修改为name</span><br><span class="line">ALTER </span><br><span class="line">VIEW </span><br><span class="line">city_country (city_id,city_name,name) </span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="视图删除"><a href="#视图删除" class="headerlink" title="视图删除"></a>视图删除</h4><ul><li><p>删除视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW 视图名称;</span><br></pre></td></tr></table></figure></li><li><p>如果存在则删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>存储过程和函数：存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合</p><p>存储过程和函数的好处：</p><ul><li>提高代码的复用性</li><li>减少数据在数据库和应用服务器之间的传输，提高传输效率</li><li>减少代码层面的业务处理</li><li><strong>一次编译永久有效</strong></li></ul><p>存储过程和函数的区别：</p><ul><li>存储函数必须有返回值</li><li>存储过程可以没有返回值</li></ul><hr><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>DELIMITER：</p><ul><li><p>DELIMITER 关键字用来声明 sql 语句的分隔符，告诉 MySQL 该段命令已经结束</p></li><li><p>MySQL 语句默认的分隔符是分号，但是有时需要一条功能 sql 语句中包含分号，但是并不作为结束标识，这时使用 DELIMITER 来指定分隔符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 分隔符</span><br></pre></td></tr></table></figure></li></ul><p>存储过程的创建调用查看和删除：</p><ul><li><p>创建存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改分隔符为$</span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称(参数...)</span><br><span class="line">BEGIN</span><br><span class="line">sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">-- 修改分隔符为分号</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p>调用存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名称(实际参数);</span><br></pre></td></tr></table></figure></li><li><p>查看存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mysql.proc WHERE db=&#x27;数据库名称&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>删除存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure></li></ul><p>练习：</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idNAMEagegenderscore</span><br><span class="line">1张三23男95</span><br><span class="line">2李四24男98</span><br><span class="line">3王五25女100</span><br><span class="line">4赵六26女90</span><br></pre></td></tr></table></figure></li><li><p>创建 stu_group() 存储过程，封装分组查询总成绩，并按照总成绩升序排序的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE stu_group()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; </span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL stu_group();</span><br><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS stu_group;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="存储语法"><a href="#存储语法" class="headerlink" title="存储语法"></a>存储语法</h4><h5 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h5><p>存储过程是可以进行编程的，意味着可以使用变量、表达式、条件控制语句等，来完成比较复杂的功能</p><ul><li><p>定义变量：DECLARE 定义的是局部变量，只能用在 BEGIN END 范围之内</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 数据类型 [DEFAULT 默认值];</span><br></pre></td></tr></table></figure></li><li><p>变量的赋值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名 = 变量值;</span><br><span class="line">SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure></li><li><p>数据准备：表 student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idNAMEagegenderscore</span><br><span class="line">1张三23男95</span><br><span class="line">2李四24男98</span><br><span class="line">3王五25女100</span><br><span class="line">4赵六26女90</span><br></pre></td></tr></table></figure></li><li><p>定义两个 int 变量，用于存储男女同学的总分数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test3()</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义两个变量</span><br><span class="line">DECLARE men,women INT;</span><br><span class="line">-- 查询男同学的总分数，为men赋值</span><br><span class="line">SELECT SUM(score) INTO men FROM student WHERE gender=&#x27;男&#x27;;</span><br><span class="line">-- 查询女同学的总分数，为women赋值</span><br><span class="line">SELECT SUM(score) INTO women FROM student WHERE gender=&#x27;女&#x27;;</span><br><span class="line">-- 使用变量</span><br><span class="line">SELECT men,women;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL pro_test3();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h5><ul><li><p>if 语句标准语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 判断条件1 THEN 执行的sql语句1;</span><br><span class="line">[ELSEIF 判断条件2 THEN 执行的sql语句2;]</span><br><span class="line">...</span><br><span class="line">[ELSE 执行的sql语句n;]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure></li><li><p>数据准备：表 student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idNAMEagegenderscore</span><br><span class="line">1张三23男95</span><br><span class="line">2李四24男98</span><br><span class="line">3王五25女100</span><br><span class="line">4赵六26女90</span><br></pre></td></tr></table></figure></li><li><p>根据总成绩判断：全班 380 分及以上学习优秀、320 ~ 380 学习良好、320 以下学习一般</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test4()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE total INT;-- 定义总分数变量</span><br><span class="line">DECLARE description VARCHAR(10);-- 定义分数描述变量</span><br><span class="line">SELECT SUM(score) INTO total FROM student; -- 为总分数变量赋值</span><br><span class="line">-- 判断总分数</span><br><span class="line">IF total &gt;= 380 THEN</span><br><span class="line">SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">ELSEIF total &gt;=320 AND total &lt; 380 THEN</span><br><span class="line">SET description = &#x27;学习良好&#x27;;</span><br><span class="line">ELSE</span><br><span class="line">SET description = &#x27;学习一般&#x27;;</span><br><span class="line">END IF;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test4存储过程</span><br><span class="line">CALL pro_test4();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul><li><p>参数传递的语法</p><p>IN：代表输入参数，需要由调用者传递实际数据，默认的<br>OUT：代表输出参数，该参数可以作为返回值<br>INOUT：代表既可以作为输入参数，也可以作为输出参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)</span><br><span class="line">BEGIN</span><br><span class="line">执行的sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p>输入总成绩变量，代表学生总成绩，输出分数描述变量，代表学生总成绩的描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test6(IN total INT, OUT description VARCHAR(10))</span><br><span class="line">BEGIN</span><br><span class="line">-- 判断总分数</span><br><span class="line">IF total &gt;= 380 THEN </span><br><span class="line">SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">ELSEIF total &gt;= 320 AND total &lt; 380 THEN </span><br><span class="line">SET description = &#x27;学习不错&#x27;;</span><br><span class="line">ELSE </span><br><span class="line">SET description = &#x27;学习一般&#x27;;</span><br><span class="line">END IF;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6(310,@description);</span><br><span class="line">CALL pro_test6((SELECT SUM(score) FROM student), @description);</span><br><span class="line">-- 查询总成绩描述</span><br><span class="line">SELECT @description;</span><br></pre></td></tr></table></figure></li><li><p>查看参数方法</p><ul><li>@变量名 : <strong>用户会话变量</strong>，代表整个会话过程他都是有作用的，类似于全局变量</li><li>@@变量名 : <strong>系统变量</strong></li></ul></li></ul><hr><h5 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h5><ul><li><p>标准语法 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE 表达式</span><br><span class="line">    WHEN 值1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 值2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure></li><li><p>标准语法 2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sCASE</span><br><span class="line">    WHEN 判断条件1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 判断条件2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure></li><li><p>演示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test7(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义变量</span><br><span class="line">DECLARE description VARCHAR(10);</span><br><span class="line">-- 使用case判断</span><br><span class="line">CASE</span><br><span class="line">WHEN total &gt;= 380 THEN</span><br><span class="line">SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">WHEN total &gt;= 320 AND total &lt; 380 THEN</span><br><span class="line">SET description = &#x27;学习不错&#x27;;</span><br><span class="line">ELSE </span><br><span class="line">SET description = &#x27;学习一般&#x27;;</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line">-- 查询分数描述信息</span><br><span class="line">SELECT description;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test7存储过程</span><br><span class="line">CALL pro_test7(390);</span><br><span class="line">CALL pro_test7((SELECT SUM(score) FROM student));</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h5><ul><li><p>while 循环语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHILE 条件判断语句 DO</span><br><span class="line">循环体语句;</span><br><span class="line">条件控制语句;</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure></li><li><p>计算 1~100 之间的偶数和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test6()</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义求和变量</span><br><span class="line">DECLARE result INT DEFAULT 0;</span><br><span class="line">-- 定义初始化变量</span><br><span class="line">DECLARE num INT DEFAULT 1;</span><br><span class="line">-- while循环</span><br><span class="line">WHILE num &lt;= 100 DO</span><br><span class="line">IF num % 2 = 0 THEN</span><br><span class="line">SET result = result + num;</span><br><span class="line">END IF;</span><br><span class="line">SET num = num + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">-- 查询求和结果</span><br><span class="line">SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h5><ul><li><p>repeat 循环标准语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">REPEAT</span><br><span class="line">循环体语句;</span><br><span class="line">条件控制语句;</span><br><span class="line">UNTIL 条件判断语句</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure></li><li><p>计算 1~10 之间的和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test9()</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义求和变量</span><br><span class="line">DECLARE result INT DEFAULT 0;</span><br><span class="line">-- 定义初始化变量</span><br><span class="line">DECLARE num INT DEFAULT 1;</span><br><span class="line">-- repeat循环</span><br><span class="line">REPEAT</span><br><span class="line">-- 累加</span><br><span class="line">SET result = result + num;</span><br><span class="line">-- 让num+1</span><br><span class="line">SET num = num + 1;</span><br><span class="line">-- 停止循环</span><br><span class="line">UNTIL num &gt; 10</span><br><span class="line">END REPEAT;</span><br><span class="line">-- 查询求和结果</span><br><span class="line">SELECT result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test9存储过程</span><br><span class="line">CALL pro_test9();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，如果不加退出循环的语句，那么就变成了死循环</p><ul><li><p>loop 循环标准语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[循环名称:] LOOP</span><br><span class="line">条件判断语句</span><br><span class="line">[LEAVE 循环名称;]</span><br><span class="line">循环体语句;</span><br><span class="line">条件控制语句;</span><br><span class="line">END LOOP 循环名称;</span><br></pre></td></tr></table></figure></li><li><p>计算 1~10 之间的和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test10()</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义求和变量</span><br><span class="line">DECLARE result INT DEFAULT 0;</span><br><span class="line">-- 定义初始化变量</span><br><span class="line">DECLARE num INT DEFAULT 1;</span><br><span class="line">-- loop循环</span><br><span class="line">l:LOOP</span><br><span class="line">-- 条件成立，停止循环</span><br><span class="line">IF num &gt; 10 THEN</span><br><span class="line">LEAVE l;</span><br><span class="line">END IF;</span><br><span class="line">-- 累加</span><br><span class="line">SET result = result + num;</span><br><span class="line">-- 让num+1</span><br><span class="line">SET num = num + 1;</span><br><span class="line">END LOOP l;</span><br><span class="line">-- 查询求和结果</span><br><span class="line">SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test10存储过程</span><br><span class="line">CALL pro_test10();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h5><p>游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用光标对结果集进行循环的处理</p><ul><li>游标可以遍历返回的多行结果，每次拿到一整行数据</li><li>简单来说游标就类似于集合的迭代器遍历</li><li>MySQL 中的游标只能用在存储过程和函数中</li></ul><p>游标的语法</p><ul><li><p>创建游标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询sql语句;</span><br></pre></td></tr></table></figure></li><li><p>打开游标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br></pre></td></tr></table></figure></li><li><p>使用游标获取数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量名1,变量名2,...;</span><br></pre></td></tr></table></figure></li><li><p>关闭游标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure></li><li><p>Mysql 通过一个 Error handler 声明来判断指针是否到尾部，并且必须和创建游标的 SQL 语句声明在一起：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND (do some action，一般是设置标志变量)</span><br></pre></td></tr></table></figure></li></ul><p>游标的基本使用</p><ul><li><p>数据准备：表 student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idNAMEagegenderscore</span><br><span class="line">1张三23男95</span><br><span class="line">2李四24男98</span><br><span class="line">3王五25女100</span><br><span class="line">4赵六26女90</span><br></pre></td></tr></table></figure></li><li><p>创建 stu_score 表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu_score(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">score INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>将student表中所有的成绩保存到stu_score表中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test12()</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义成绩变量</span><br><span class="line">DECLARE s_score INT;</span><br><span class="line">-- 定义标记变量</span><br><span class="line">DECLARE flag INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">-- 创建游标，查询所有学生成绩数据</span><br><span class="line">DECLARE stu_result CURSOR FOR SELECT score FROM student;</span><br><span class="line">-- 游标结束后，将标记变量改为1  这两个必须声明在一起</span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;</span><br><span class="line"></span><br><span class="line">-- 开启游标</span><br><span class="line">OPEN stu_result;</span><br><span class="line">-- 循环使用游标</span><br><span class="line">REPEAT</span><br><span class="line">-- 使用游标，遍历结果,拿到数据</span><br><span class="line">FETCH stu_result INTO s_score;</span><br><span class="line">-- 将数据保存到stu_score表中</span><br><span class="line">INSERT INTO stu_score VALUES (NULL,s_score);</span><br><span class="line">UNTIL flag=1</span><br><span class="line">END REPEAT;</span><br><span class="line">-- 关闭游标</span><br><span class="line">CLOSE stu_result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test12存储过程</span><br><span class="line">CALL pro_test12();</span><br><span class="line">-- 查询stu_score表</span><br><span class="line">SELECT * FROM stu_score;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>存储函数和存储过程是非常相似的，存储函数可以做的事情，存储过程也可以做到</p><p>存储函数有返回值，存储过程没有返回值（参数的 out 其实也相当于是返回数据了）</p><ul><li><p>创建存储函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE FUNCTION 函数名称(参数 数据类型)</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">BEGIN</span><br><span class="line">执行的sql语句;</span><br><span class="line">RETURN 结果;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p>调用存储函数，因为有返回值，所以使用 SELECT 调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名称(实际参数);</span><br></pre></td></tr></table></figure></li><li><p>删除存储函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION 函数名称;</span><br></pre></td></tr></table></figure></li><li><p>定义存储函数，获取学生表中成绩大于95分的学生数量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION fun_test()</span><br><span class="line">RETURN INT</span><br><span class="line">BEGIN</span><br><span class="line">-- 定义统计变量</span><br><span class="line">DECLARE result INT;</span><br><span class="line">-- 查询成绩大于95分的学生数量，给统计变量赋值</span><br><span class="line">SELECT COUNT(score) INTO result FROM student WHERE score &gt; 95;</span><br><span class="line">-- 返回统计结果</span><br><span class="line">SELECT result;</span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用fun_test存储函数</span><br><span class="line">SELECT fun_test();</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>触发器是与表有关的数据库对象，在 insert&#x2F;update&#x2F;delete 之前或之后触发并执行触发器中定义的 SQL 语句</p><ul><li>触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作</li></ul><ul><li>使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的</li><li>现在触发器还只支持行级触发，不支持语句级触发</li></ul><table><thead><tr><th>触发器类型</th><th>OLD的含义</th><th>NEW的含义</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>无 (因为插入前状态无数据)</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据</td><td>NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td><td>无 (因为删除后状态无数据)</td></tr></tbody></table><hr><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>创建触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">BEFORE|AFTER  INSERT|UPDATE|DELETE</span><br><span class="line">ON 表名</span><br><span class="line">[FOR EACH ROW]  -- 行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">触发器要执行的功能;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p>查看触发器的状态、语法等信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure></li><li><p>删除触发器，如果没有指定 schema_name，默认为当前数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="触发演示"><a href="#触发演示" class="headerlink" title="触发演示"></a>触发演示</h4><p>通过触发器记录账户表的数据变更日志。包含：增加、修改、删除</p><ul><li><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db9数据库</span><br><span class="line">CREATE DATABASE db9;</span><br><span class="line">-- 使用db9数据库</span><br><span class="line">USE db9;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建账户表account</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 账户id</span><br><span class="line">NAME VARCHAR(20),-- 姓名</span><br><span class="line">money DOUBLE-- 余额</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;张三&#x27;,1000),(NULL,&#x27;李四&#x27;,2000);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建日志表account_log</span><br><span class="line">CREATE TABLE account_log(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,-- 日志id</span><br><span class="line">operation VARCHAR(20),-- 操作类型 (insert update delete)</span><br><span class="line">operation_time DATETIME,-- 操作时间</span><br><span class="line">operation_id INT,-- 操作表的id</span><br><span class="line">operation_params VARCHAR(200)       -- 操作参数</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建 INSERT 型触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_insert</span><br><span class="line">AFTER INSERT</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO account_log VALUES (NULL,&#x27;INSERT&#x27;,NOW(),new.id,CONCAT(&#x27;插入后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 向account表添加记录</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;王五&#x27;,3000);</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">idoperationoperation_timeoperation_idoperation_params</span><br><span class="line">1INSERT   2021-01-26 19:51:113     插入后&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>创建 UPDATE 型触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_update</span><br><span class="line">AFTER UPDATE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO account_log VALUES (NULL,&#x27;UPDATE&#x27;,NOW(),new.id,CONCAT(&#x27;修改前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;,&#x27;修改后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改account表</span><br><span class="line">UPDATE account SET money=3500 WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">idoperationoperation_timeoperation_id  operation_params</span><br><span class="line">2UPDATE   2021-01-26 19:58:542 更新前&#123;id=2,name=李四money=1000&#125;</span><br><span class="line"> 更新后&#123;id=2,name=李四money=200&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>创建 DELETE 型触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_delete</span><br><span class="line">AFTER DELETE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO account_log VALUES (NULL,&#x27;DELETE&#x27;,NOW(),old.id,CONCAT(&#x27;删除前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除account表数据</span><br><span class="line">DELETE FROM account WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">idoperationoperation_timeoperation_idoperation_params</span><br><span class="line">3DELETE2021-01-26 20:02:483    删除前&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>对比其他数据库，MySQL 的架构可以在不同场景应用并发挥良好作用，主要体现在存储引擎，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取分离，可以针对不同的存储需求可以选择最优的存储引擎</p><p>存储引擎的介绍：</p><ul><li>MySQL 数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平等不同的功能和能力，在 MySQL 中，将这些不同的技术及配套的功能称为存储引擎</li><li>Oracle、SqlServer 等数据库只有一种存储引擎，MySQL <strong>提供了插件式的存储引擎架构</strong>，所以 MySQL 存在多种存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能</li><li>在关系型数据库中数据的存储是以表的形式存进行，所以存储引擎也称为表类型（存储和操作此表的类型）</li><li>通过选择不同的引擎，能够获取最佳的方案,  也能够获得额外的速度或者功能，提高程序的整体效果。</li></ul><p>MySQL 支持的存储引擎：</p><ul><li>MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等</li><li>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB</li></ul><hr><h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MyISAM 存储引擎：</p><ul><li>特点：不支持事务和外键，读取速度快，节约资源</li><li>应用场景：<strong>适用于读多写少的场景</strong>，对事务的完整性要求不高，比如一些数仓、离线数据、支付宝的年度总结之类的场景，业务进行只读操作，查询起来会更快</li><li>存储方式：<ul><li>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，拓展名不同</li><li>表的定义保存在 .frm 文件，表数据保存在 .MYD (MYData) 文件中，索引保存在 .MYI (MYIndex) 文件中</li></ul></li></ul><p>InnoDB 存储引擎：(MySQL5.5 版本后默认的存储引擎)</p><ul><li>特点：<strong>支持事务</strong>和外键操作，支持并发控制。对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li><li>应用场景：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作</li><li>存储方式：<ul><li>使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm 文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件</li><li>使用多表空间存储，创建的表的表结构存在 .frm 文件中，每个表的数据和索引单独保存在 .ibd 中</li></ul></li></ul><p>MEMORY 存储引擎：</p><ul><li>特点：每个 MEMORY 表实际对应一个磁盘文件 ，该文件中只存储表的结构，表数据保存在内存中，且默认<strong>使用 HASH 索引</strong>，所以数据默认就是无序的，但是在需要快速定位记录可以提供更快的访问，<strong>服务一旦关闭，表中的数据就会丢失</strong>，存储不安全</li><li>应用场景：<strong>缓存型存储引擎</strong>，通常用于更新不太频繁的小表，用以快速得到访问结果</li><li>存储方式：表结构保存在 .frm 中</li></ul><p>MERGE 存储引擎：</p><ul><li><p>特点：</p><ul><li>是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，通过将不同的表分布在多个磁盘上</li><li>MERGE 表本身并没有存储数据，对 MERGE 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 MyISAM 表进行的</li></ul></li><li><p>应用场景：将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用他们，适合做数据仓库</p></li><li><p>操作方式：</p><ul><li>插入操作是通过 INSERT_METHOD 子句定义插入的表，使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上；不定义这个子句或者定义为 NO，表示不能对 MERGE 表执行插入操作</li><li>对 MERGE 表进行 DROP 操作，但是这个操作只是删除 MERGE 表的定义，对内部的表是没有任何影响的</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE order_1(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_2(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_all(</span><br><span class="line">-- 结构与MyISAM表相同</span><br><span class="line">)ENGINE = MERGE UNION = (order_1,order_2) INSERT_METHOD=LAST DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MERGE.png"></p></li></ul><table><thead><tr><th>特性</th><th>MyISAM</th><th>InnoDB</th><th>MEMORY</th></tr></thead><tbody><tr><td>存储限制</td><td>有（平台对文件系统大小的限制）</td><td>64TB</td><td>有（平台的内存限制）</td></tr><tr><td><strong>事务安全</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td><td><strong>不支持</strong></td></tr><tr><td><strong>锁机制</strong></td><td><strong>表锁</strong></td><td><strong>表锁&#x2F;行锁</strong></td><td><strong>表锁</strong></td></tr><tr><td>B+Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>集群索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据索引</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>数据缓存</td><td>不支持</td><td>支持</td><td>N&#x2F;A</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>N&#x2F;A</td></tr><tr><td>数据可压缩</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>空间使用</td><td>低</td><td>高</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>批量插入速度</td><td>高</td><td>低</td><td>高</td></tr><tr><td><strong>外键</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td><td><strong>不支持</strong></td></tr></tbody></table><p>只读场景 MyISAM 比 InnoDB 更快：</p><ul><li>底层存储结构有差别，MyISAM 是非聚簇索引，叶子节点保存的是数据的具体地址，不用回表查询</li><li>InnoDB 每次查询需要维护 MVCC 版本状态，保证并发状态下的读写冲突问题</li></ul><hr><h3 id="引擎操作"><a href="#引擎操作" class="headerlink" title="引擎操作"></a>引擎操作</h3><ul><li><p>查询数据库支持的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%storage_engine%&#x27;; -- 查看Mysql数据库默认的存储引擎 </span><br></pre></td></tr></table></figure></li><li><p>查询某个数据库中所有数据表的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查询某个数据库中某个数据表的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = &#x27;数据表名称&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>创建数据表，指定存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名,数据类型,</span><br><span class="line">    ...</span><br><span class="line">)ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li><li><p>修改数据表的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="索引机制"><a href="#索引机制" class="headerlink" title="索引机制"></a>索引机制</h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，<strong>本质是排好序的快速查找数据结构。</strong>在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p><p><strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p><p>索引使用：一张数据表，用于保存数据；一个索引配置文件，用于保存索引；每个索引都指向了某一个数据<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D.png"></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到相应数据</p><p>索引的优点：</p><ul><li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li></ul><p>索引的缺点：</p><ul><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上</li><li>虽然索引大大提高了查询效率，同时却也降低更新表的速度。对表进行 INSERT、UPDATE、DELETE 操作，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，还会调整因为更新所带来的键值变化后的索引信息，<strong>但是更新数据也需要先从数据库中获取</strong>，索引加快了获取速度，所以可以相互抵消一下。</li><li>索引会影响到 WHERE 的查询条件和排序 ORDER BY 两大功能</li></ul><hr><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>索引一般的分类如下：</p><ul><li><p>功能分类 </p><ul><li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引</li><li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）</li><li>联合索引：顾名思义，就是将单列索引进行组合</li><li>唯一索引：索引列的值必须唯一，<strong>允许有空值</strong>，如果是联合索引，则列值组合必须唯一<ul><li>NULL 值可以出现多次，因为两个 NULL 比较的结果既不相等，也不不等，结果仍然是未知</li><li>可以声明不允许存储 NULL 值的非空唯一索引</li></ul></li><li>外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作</li></ul></li><li><p>结构分类</p><ul><li>BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree</li><li>Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型</li><li>R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型</li><li>Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持</li></ul><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>BTREE</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></li></ul><p>联合索引图示：根据身高年龄建立的组合索引（height、age）</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E5%9B%BE.png"></p><hr><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引在创建表的时候可以同时创建， 也可以随时增加新的索引</p><ul><li><p>创建索引：如果一个表中有一列是主键，那么会<strong>默认为其创建主键索引</strong>（主键列不需要单独创建索引）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);</span><br><span class="line">-- 索引类型默认是 B+TREE</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure></li><li><p>添加索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 单列索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);</span><br><span class="line"></span><br><span class="line">-- 主键索引</span><br><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); </span><br><span class="line"></span><br><span class="line">-- 外键索引(添加外键约束，就是外键索引)</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 全文索引(mysql只支持文本类型)</span><br><span class="line">ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名;</span><br></pre></td></tr></table></figure></li><li><p>案例练习</p><p>数据准备：student</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idNAME agescore</span><br><span class="line">1张三2399</span><br><span class="line">2李四2495</span><br><span class="line">3王五2598</span><br><span class="line">4赵六2697</span><br></pre></td></tr></table></figure><p>索引操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 为student表中姓名列创建一个普通索引</span><br><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br><span class="line"></span><br><span class="line">-- 为student表中年龄列创建一个唯一索引</span><br><span class="line">CREATE UNIQUE INDEX idx_age ON student(age);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h4 id="索引对比"><a href="#索引对比" class="headerlink" title="索引对比"></a>索引对比</h4><p>聚簇索引是一种数据存储方式，并不是一种单独的索引类型</p><ul><li><p>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</p></li><li><p>非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）</p></li></ul><p>在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引</p><hr><h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><h5 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）</p><p>InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页</p><ul><li>这个特性决定了<strong>数据也是索引的一部分</strong>，所以一张表只能有一个聚簇索引</li><li>辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li></ul><p>聚簇索引的优点：</p><ul><li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>聚簇索引的缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键</p></li><li><p>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</p></li></ul><hr><h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等</p><p>辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询</p><p><strong>检索过程</strong>：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行</p><p>补充：无索引走全表查询，查到数据页后和上述步骤一致</p><hr><h5 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h5><p>InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引</p><p>主键索引：</p><ul><li><p>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录</p></li><li><p>InnoDB 的表数据文件<strong>通过主键聚集数据</strong>，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个<strong>隐含字段 row_id</strong> 作为主键，这个字段长度为 6 个字节，类型为长整形</p></li></ul><p>辅助索引：</p><ul><li><p>InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域</p></li><li><p>InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，<strong>过长的主索引会令辅助索引变得过大</strong></p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E8%81%9A%E7%B0%87%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="非聚簇"><a href="#非聚簇" class="headerlink" title="非聚簇"></a>非聚簇</h5><p>MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，<strong>索引文件仅保存数据的地址</strong></p><ul><li>主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别</li><li>由于索引树是独立的，通过辅助索引检索<strong>无需回表查询</strong>访问主键的索引树</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E9%94%81%E6%95%B0%E6%8D%AE%E5%9B%BE.jpg"></p><hr><h5 id="索引实现-1"><a href="#索引实现-1" class="headerlink" title="索引实现"></a>索引实现</h5><p>MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分</p><p>主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</p><p>辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM%E4%B8%BB%E9%94%AE%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><p>参考文章：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p><hr><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>文件系统的最小单元是块（block），一个块的大小是 4K，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p><p>InnoDB 存储引擎中有页（Page）的概念，页是 MySQL 磁盘管理的最小单位</p><ul><li><strong>InnoDB 存储引擎中默认每个页的大小为 16KB，索引中一个节点就是一个数据页</strong>，所以会一次性读取 16KB 的数据到内存</li><li>InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB</li><li>在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率</li></ul><p>超过 16KB 的一条记录，主键索引页只会存储部分数据和指向<strong>溢出页</strong>的指针，剩余数据都会分散存储在溢出页中</p><p>数据页物理结构，从上到下：</p><ul><li>File Header：上一页和下一页的指针、该页的类型（索引页、数据页、日志页等）、<strong>校验和</strong>、LSN（最近一次修改当前页面时的系统 lsn 值，事务持久性部分详解）等信息</li><li>Page Header：记录状态信息</li><li>Infimum + Supremum：当前页的最小记录和最大记录（头尾指针），Infimum 所在分组只有一条记录，Supremum 所在分组可以有 1 ~ 8 条记录，剩余的分组可以有 4 ~ 8 条记录</li><li>User Records：存储数据的记录</li><li>Free Space：尚未使用的存储空间</li><li>Page Directory：分组的目录，可以通过目录快速定位（二分法）数据的分组</li><li>File Trailer：检验和字段，在刷脏过程中，页首和页尾的校验和一致才能说明页面刷新成功，二者不同说明刷新期间发生了错误；LSN 字段，也是用来校验页面的完整性</li></ul><p>数据页中包含数据行，数据的存储是基于数据行的，数据行有 next_record 属性指向下一个行数据，所以是可以遍历的，但是一组数据至多 8 个行，通过 Page Directory 先定位到组，然后遍历获取所需的数据行即可</p><p>数据行中有三个隐藏字段：trx_id、roll_pointer、row_id（在事务章节会详细介绍它们的作用）</p><hr><h4 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h4><p>BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序</p><p>BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：</p><ul><li>树中每个节点最多包含 m 个孩子</li><li>除根节点与叶子节点外，每个节点至少有 [ceil(m&#x2F;2)] 个孩子</li><li>若根节点不是叶子节点，则至少有两个孩子</li><li>所有的叶子节点都在同一层</li><li>每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li></ul><p>5 叉，key 的数量 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1 为 2 &lt;&#x3D; n &lt;&#x3D;4 ，当 n&gt;4 时中间节点分裂到父节点，两边节点分裂</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：</p><ul><li><p>插入前 4 个字母 C N G A </p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p></li><li><p>插入 H，n&gt;4，中间元素 G 字母向上分裂到新的节点</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p></li><li><p>插入 E、K、Q 不需要分裂</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.png"></p></li><li><p>插入 M，中间元素 M 字母向上分裂到父节点 G</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.png"></p></li><li><p>插入 F，W，L，T 不需要分裂</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.png"></p></li><li><p>插入 Z，中间元素 T 向上分裂到父节点中</p></li></ul><p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.png"></p><ul><li><p>插入 D，中间元素 D 向上分裂到父节点中，然后插入 P，R，X，Y 不需要分裂</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.png"></p></li><li><p>最后插入 S，NPQR 节点 n&gt;5，中间节点 Q 向上分裂，但分裂后父节点 DGMT 的 n&gt;5，中间节点 M 向上分裂</p></li></ul><p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.png"></p><p>BTree 树就已经构建完成了，BTree 树和二叉树相比， 查询数据的效率更高， 因为对于相同的数据量来说，<strong>BTree 的层级结构比二叉树少</strong>，所以搜索速度快</p><p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%861.png"></p><p>缺点：当进行范围查找时会出现回旋查找</p><hr><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率，所以引入 B+Tree</p><p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p><ul><li>n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key</li></ul><ul><li>所有<strong>非叶子节点只存储键值 key</strong> 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加</li><li>所有<strong>数据都存储在叶子节点</strong>，所以每次数据查询的次数都一样</li><li><strong>叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表</strong></li><li>所有节点中的 key 在叶子节点中也存在（比如 5)，<strong>key 允许重复</strong>，B 树不同节点不存在重复的 key</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-B加Tree数据结构.png" style="zoom:67%;"><p>B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针</p><hr><h5 id="优化结构"><a href="#优化结构" class="headerlink" title="优化结构"></a>优化结构</h5><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，<strong>提高区间访问的性能，防止回旋查找</strong></p><p>区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历</p><p>B+ 树的<strong>叶子节点是数据页</strong>（page），一个页里面可以存多个数据行</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%862.png"></p><p>通常在 B+Tree 上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：</p><ul><li>有范围：对于主键的范围查找和分页查找</li><li>有顺序：从根节点开始，进行随机查找，顺序查找</li></ul><p>InnoDB 中每个数据页的大小默认是 16KB，</p><ul><li>索引行：一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针大小在 InnoDB 中设置为 6 字节节，也就是说一个页大概存储 16KB&#x2F;(8B+6B)&#x3D;1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录</li><li>数据行：一行数据的大小可能是 1k，一个数据页可以存储 16 行</li></ul><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是<strong>将根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I&#x2F;O 操作</p><p>B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小</p><hr><h5 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h5><p>B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护</p><p>每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：</p><ul><li>如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>，原本放在一个页的数据现在分到两个页中，降低了空间利用率</li><li>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做<strong>页合并</strong>，合并的过程可以认为是分裂过程的逆过程</li><li>这两个情况都是由 B+ 树的结构决定的</li></ul><p>一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p><p>自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong>，页分裂的目的就是保证后一个数据页中的所有行主键值比前一个数据页中主键值大</p><p>参考文章：<a href="https://developer.aliyun.com/article/919861">https://developer.aliyun.com/article/919861</a></p><hr><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率</p><p>创建索引时的原则：</p><ul><li>对查询频次较高，且数据量比较大的表建立索引</li><li>使用唯一索引，区分度越高，使用索引的效率越高</li><li>索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I&#x2F;O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I&#x2F;O 效率</li><li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价</li></ul><ul><li><p>MySQL 建立联合索引时会遵守<strong>最左前缀匹配原则</strong>，即最左优先，在检索数据时从联合索引的最左边开始匹配</p><p>N 个列组合而成的组合索引，相当于创建了 N 个索引，如果查询时 where 句中使用了组成该索引的<strong>前</strong>几个字段，那么这条查询 SQL 可以利用组合索引来提升查询效率</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 对name、address、phone列建一个联合索引</span><br><span class="line">ALTER TABLE user ADD INDEX index_three(name,address,phone);</span><br><span class="line">-- 查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引进行数据匹配。</span><br><span class="line">(name,address,phone)</span><br><span class="line">(name,address)</span><br><span class="line">(name,phone)-- 只有name字段走了索引</span><br><span class="line">(name)</span><br><span class="line"></span><br><span class="line">-- 索引的字段可以是任意顺序的，优化器会帮助我们调整顺序，下面的SQL语句可以命中索引</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27; AND name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果联合索引中最左边的列不包含在条件查询中，SQL语句就不会命中索引，比如：</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27;; </span><br></pre></td></tr></table></figure></li></ul><p>哪些情况不要建立索引：</p><ul><li>记录太少的表</li><li>经常增删改的表</li><li>频繁更新的字段不适合创建索引</li><li>where 条件里用不到的字段不创建索引</li></ul><hr><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件</p><p>回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据</p><p>使用覆盖索引，防止回表查询：</p><ul><li><p>表 user 主键为 id，普通索引为 age，查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure><p>查询过程：先通过普通索引 age&#x3D;30 定位到主键值 id&#x3D;1，再通过聚集索引 id&#x3D;1 定位到行记录数据，需要两次扫描 B+ 树</p></li><li><p>使用覆盖索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age ON user;</span><br><span class="line">CREATE INDEX idx_age_name ON user(age,name);</span><br><span class="line">SELECT id,age FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure><p>在一棵索引树上就能获取查询所需的数据，无需回表速度更快</p></li></ul><p>使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 SELECT *，所有字段一起做索引会导致索引文件过大，查询性能下降</p><hr><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推优化（Index Condition Pushdown，ICP）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><p>索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找</p><ul><li><p>不使用索引下推优化时存储引擎通过索引检索到数据，然后回表查询记录返回给 Server 层，<strong>服务器判断数据是否符合条件</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p></li><li><p>使用索引下推优化时，如果<strong>存在某些被索引的列的判断条件</strong>时，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p></li></ul><p><strong>适用条件</strong>：</p><ul><li>需要存储引擎将索引中的数据与条件进行判断（所以<strong>条件列必须都在同一个索引中</strong>），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM</li><li>存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化</li><li>对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了</li></ul><p>工作过程：用户表 user，(name, age) 是联合索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE name LIKE &#x27;张%&#x27; AND　age = 10;-- 头部模糊匹配会造成索引失效</span><br></pre></td></tr></table></figure><ul><li><p>优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%961.png"></p></li><li><p>优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，<strong>不满足条件的不去读取表中的数据</strong>，满足下推条件的就根据主键值进行回表查询，2 次回表<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%962.png"></p></li></ul><p>当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition</p><p>参考文章：<a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p><p>参考文章：<a href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a></p><hr><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率</p><p>注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了</p><p>优化原则：<strong>降低重复的索引值</strong></p><p>比如地区表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">areagdpcode</span><br><span class="line">chinaShanghai100aaa</span><br><span class="line">chinaDalian200bbb</span><br><span class="line">usaNewYork300ccc</span><br><span class="line">chinaFuxin400ddd</span><br><span class="line">chinaBeijing500eee</span><br></pre></td></tr></table></figure><p>发现 area 字段很多都是以 china 开头的，那么如果以前 1-5 位字符做前缀索引就会出现大量索引值重复的情况，索引值重复性越低，查询效率也就越高，所以需要建立前 6 位字符的索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_area ON table_name(area(7));</span><br></pre></td></tr></table></figure><p>场景：存储身份证</p><ul><li>直接创建完整索引，这样可能比较占用空间</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li></ul><hr><h4 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h4><p>使用多个索引来完成一次查询的执行方法叫做索引合并 index merge</p><ul><li><p>Intersection 索引合并：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>; # key1 和 key3 列都是单列索引、二级索引</span><br></pre></td></tr></table></figure><p>从不同索引中扫描到的记录的 id 值取<strong>交集</strong>（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Union 索引合并：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从不同索引中扫描到的记录的 id 值取<strong>并集</strong>，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Sort-Union 索引合并</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询</p></li></ul><p>索引合并算法的效率并不好，通过将其中的一个索引改成联合索引会优化效率</p><hr><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="表优化"><a href="#表优化" class="headerlink" title="表优化"></a>表优化</h3><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>分区表是将大表的数据按分区字段分成许多小的子集，建立一个以 ftime 年份为分区的表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">    `ftime` datetime NOT NULL,</span><br><span class="line">    `c` int(11) DEFAULT NULL,</span><br><span class="line">    KEY (`ftime`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);</span><br><span class="line">INSERT INTO t VALUES(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);-- 这两行记录分别落在 p_2018 和 p_2019 这两个分区上</span><br></pre></td></tr></table></figure><p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件</p><ul><li>对于引擎层来说，这是 4 个表，针对每个分区表的操作不会相互影响</li><li>对于 Server 层来说，这是 1 个表</li></ul><hr><h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><p>打开表行为：第一次访问一个分区表时，MySQL 需要<strong>把所有的分区都访问一遍</strong>，如果分区表的数量很多，超过了 open_files_limit 参数（默认值 1024），那么就会在访问这个表时打开所有的文件，导致打开表文件的个数超过了上限而报错</p><p>通用分区策略：MyISAM 分区表使用的分区策略，每次访问分区都由 Server 层控制，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题</p><p>本地分区策略：从 MySQL 5.7.9 开始，InnoDB 引擎内部自己管理打开分区的行为，InnoDB 引擎打开文件超过 innodb_open_files 时就会<strong>关掉一些之前打开的文件</strong>，所以即使分区个数大于 open_files_limit，也不会报错</p><p>从 MySQL 8.0 版本开始，就不允许创建 MyISAM 分区表，只允许创建已经实现了本地分区策略的引擎，目前只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略</p><hr><h5 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h5><p>从 Server 层看一个分区表就只是一个表</p><ul><li><p>Session A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE ftime = &#x27;2018-4-1&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>Session B：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t TRUNCATE PARTITION p_2017; -- blocked</span><br></pre></td></tr></table></figure></li></ul><p>现象：Session B 只操作 p_2017 分区，但是由于 Session A 持有整个表 t 的 MDL 读锁，就导致 B 的 ALTER 语句获取 MDL 写锁阻塞</p><p>分区表的特点：</p><ul><li>第一次访问的时候需要访问所有分区</li><li>在 Server 层认为这是同一张表，因此<strong>所有分区共用同一个 MDL 锁</strong></li><li>在引擎层认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问需要的分区</li></ul><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>分区表的优点：</p><ul><li><p>对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁</p></li><li><p>分区表可以很方便的清理历史数据。按照时间分区的分区表，就可以直接通过 <code>alter table t drop partition</code> 这个语法直接删除分区文件，从而删掉过期的历史数据，与使用 drop 语句删除数据相比，优势是速度快、对系统影响小</p></li></ul><p>使用分区表，不建议创建太多的分区，注意事项：</p><ul><li>分区并不是越细越好，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表</li><li>分区不要提前预留太多，在使用之前预先创建即可。比如是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可，并且对于没有数据的历史分区，要及时的 drop 掉</li></ul><p>参考文档：<a href="https://time.geekbang.org/column/article/82560">https://time.geekbang.org/column/article/82560</a></p><hr><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><h5 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>临时表分为内部临时表和用户临时表</p><ul><li><p>内部临时表：系统执行 SQL 语句优化时产生的表，例如 Join 连接查询、去重查询等</p></li><li><p>用户临时表：用户主动创建的临时表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_t like table_1;</span><br></pre></td></tr></table></figure></li></ul><p>临时表可以是内存表，也可以是磁盘表（多表操作 → 嵌套查询章节提及）</p><ul><li>内存表指的是使用 Memory 引擎的表，建立哈希索引，建表语法是 <code>create table … engine=memory</code>，这种表的数据都保存在内存里，系统重启时会被清空，但是表结构还在</li><li>磁盘表是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，建立 B+ 树索引，写数据的时候是写到磁盘上的</li></ul><p>临时表的特点：</p><ul><li>一个临时表只能被创建它的 session 访问，对其他线程不可见，所以不同 session 的临时表是<strong>可以重名</strong>的</li><li>临时表可以与普通表同名，会话内有同名的临时表和普通表时，执行 show create 语句以及增删改查语句访问的都是临时表</li><li>show tables 命令不显示临时表</li><li>数据库发生异常重启不需要担心数据删除问题，临时表会<strong>自动回收</strong></li></ul><hr><h5 id="重名原理"><a href="#重名原理" class="headerlink" title="重名原理"></a>重名原理</h5><p>执行创建临时表的 SQL：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key)engine=innodb;</span><br></pre></td></tr></table></figure><p>MySQL 给 InnoDB 表创建一个 frm 文件保存表结构定义，在 ibd 保存表数据。frm 文件放在临时文件目录下，文件名的后缀是 .frm，<strong>前缀是</strong> <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code>，使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p><p>MySQL 维护数据表，除了物理磁盘上的文件外，内存里也有一套机制区别不同的表，每个表都对应一个 table_def_key</p><ul><li>一个普通表的 table_def_key 的值是由 <code>库名 + 表名</code> 得到的，所以如果在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了</li><li>对于临时表，table_def_key 在 <code>库名 + 表名</code> 基础上，又加入了 <code>server_id + thread_id</code>，所以不同线程之间，临时表可以重名</li></ul><p>实现原理：每个线程都维护了自己的临时表链表，每次 session 内操作表时，先遍历链表，检查是否有这个名字的临时表，如果有就<strong>优先操作临时表</strong>，如果没有再操作普通表；在 session 结束时对链表里的每个临时表，执行 <code>DROP TEMPORARY TABLE + 表名</code> 操作</p><p>执行 rename table 语句无法修改临时表，因为会按照 <code>库名 / 表名.frm</code> 的规则去磁盘找文件，但是临时表文件名的规则是 <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号.frm</code>，因此会报找不到文件名的错误</p><hr><h5 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h5><p>创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出时会自动删除临时表，但备库同步线程是持续在运行的并不会退出，所以这时就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行</p><p>binlog 日志写入规则：</p><ul><li>binlog_format&#x3D;row，跟临时表有关的语句就不会记录到 binlog</li><li>binlog_format&#x3D;statment&#x2F;mixed，binlog 中才会记录临时表的操作，也就会记录 <code>DROP TEMPORARY TABLE</code> 这条命令</li></ul><p>主库上不同的线程创建同名的临时表是不冲突的，但是备库只有一个执行线程，所以 MySQL 在记录 binlog 时会把主库执行这个语句的线程 id 写到 binlog 中，在备库的应用线程就可以获取执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key</p><ul><li>session A 的临时表 t1，在备库的 table_def_key 就是：<code>库名 + t1 +“M 的 serverid&quot; + &quot;session A 的 thread_id”</code></li><li>session B 的临时表 t1，在备库的 table_def_key 就是 ：<code>库名 + t1 +&quot;M 的 serverid&quot; + &quot;session B 的 thread_id&quot;</code></li></ul><p>MySQL 在记录 binlog 的时不论是 create table 还是 alter table 语句都是原样记录，但是如果执行 drop table，系统记录 binlog 就会被服务端改写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE `t_normal` /* generated by server */</span><br></pre></td></tr></table></figure><hr><h5 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h5><p>分库分表系统的跨库查询使用临时表不用担心线程之间的重名冲突，分库分表就是要把一个逻辑上的大表分散到不同的数据库实例上</p><p>比如将一个大表 ht，按照字段 f，拆分成 1024 个分表，分布到 32 个数据库实例上，一般情况下都有一个中间层 proxy 解析 SQL 语句，通过分库规则通过分表规则（比如 N%1024）确定将这条语句路由到哪个分表做查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where f=N;</span><br></pre></td></tr></table></figure><p>如果这个表上还有另外一个索引 k，并且查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure><p>查询条件里面没有用到分区字段 f，只能<strong>到所有的分区</strong>中去查找满足条件的所有行，然后统一做 order by 操作，两种方式：</p><ul><li>在 proxy 层的进程代码中实现排序，拿到分库的数据以后，直接在内存中参与计算，但是对 proxy 端的压力比较大，很容易出现内存不够用和 CPU 瓶颈问题</li><li>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作，执行流程：<ul><li>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified</li><li>在各个分库执行：<code>select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100</code></li><li>把分库执行的结果插入到 temp_ht 表中</li><li>在临时表上执行：<code>select v from temp_ht order by t_modified desc limit 100</code></li></ul></li></ul><hr><h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><h4 id="执行频率"><a href="#执行频率" class="headerlink" title="执行频率"></a>执行频率</h4><p>MySQL 客户端连接成功后，查询服务器状态信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] STATUS LIKE &#x27;&#x27;;</span><br><span class="line">-- SESSION: 显示当前会话连接的统计结果，默认参数</span><br><span class="line">-- GLOBAL: 显示自数据库上次启动至今的统计结果</span><br></pre></td></tr></table></figure><ul><li><p>查看 SQL 执行频率：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Com_____&#x27;;</span><br></pre></td></tr></table></figure><p>Com_xxx 表示每种语句执行的次数</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87.png"></p></li><li><p>查询 SQL 语句影响的行数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E5%BD%B1%E5%93%8D%E7%9A%84%E8%A1%8C%E6%95%B0.png"></p></li></ul><p>Com_xxxx：这些参数对于所有存储引擎的表操作都会进行累计</p><p>Innodb_xxxx：这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同</p><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 SELECT 操作的次数，一次查询只累加 1</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数</td></tr><tr><td align="left">Innodb_rows_read</td><td>执行 SELECT 查询返回的行数</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数</td></tr><tr><td align="left">Connections</td><td>试图连接 MySQL 服务器的次数</td></tr><tr><td align="left">Uptime</td><td>服务器工作时间</td></tr><tr><td align="left">Slow_queries</td><td>慢查询的次数</td></tr></tbody></table><hr><h4 id="定位低效"><a href="#定位低效" class="headerlink" title="定位低效"></a>定位低效</h4><p>SQL 执行慢有两种情况：</p><ul><li>偶尔慢：DB 在刷新脏页（学完事务就懂了）<ul><li>redo log 写满了</li><li>内存不够用，要从 LRU 链表中淘汰</li><li>MySQL 认为系统空闲的时候</li><li>MySQL 关闭时</li></ul></li><li>一直慢的原因：索引没有设计好、SQL 语句没写好、MySQL 选错了索引</li></ul><p>通过以下两种方式定位执行效率较低的 SQL 语句</p><ul><li><p>慢日志查询： 慢查询日志在查询结束以后才记录，执行效率出现问题时查询日志并不能定位问题</p><p>配置文件修改：修改 .cnf 文件 <code>vim /etc/mysql/my.cnf</code>，重启 MySQL 服务器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/usr/local/mysql/var/localhost-slow.log</span><br><span class="line">long_query_time=1<span class="comment">#记录超过long_query_time秒的SQL语句的日志</span></span><br><span class="line">log-queries-not-using-indexes = 1</span><br></pre></td></tr></table></figure><p>使用命令配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET slow_query_log=ON;</span><br><span class="line">mysql&gt; SET GLOBAL slow_query_log=ON;</span><br></pre></td></tr></table></figure><p>查看是否配置成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%query%&#x27;</span><br></pre></td></tr></table></figure></li><li><p>SHOW PROCESSLIST：<strong>实时查看</strong>当前 MySQL 在进行的连接线程，包括线程的状态、是否锁表、SQL 的执行情况，同时对一些锁表操作进行优化</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p></li></ul><hr><h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p>通过 EXPLAIN 命令获取执行 SQL 语句的信息，包括在 SELECT 语句执行过程中如何连接和连接的顺序，执行计划在优化器优化完成后、执行器之前生成，然后执行器会调用存储引擎检索数据</p><p>查询 SQL 语句的执行计划：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_1 WHERE id = 1;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E6%9F%A5%E8%AF%A2SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>SELECT 的序列号</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型</td></tr><tr><td>table</td><td>访问数据库中表名称，有时可能是简称或者临时表名称（<table_name>）</table_name></td></tr><tr><td>type</td><td>表示表的连接类型</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>ref</td><td>表示与索引列进行等值匹配的对象，常数、某个列、函数等，type 必须在（range, const] 之间，左闭右开</td></tr><tr><td>rows</td><td>扫描出的行数，表示 MySQL 根据表统计信息及索引选用情况，<strong>估算</strong>的找到所需的记录扫描的行数</td></tr><tr><td>filtered</td><td>条件过滤的行百分比，单表查询没意义，用于连接查询中对驱动表的扇出进行过滤，查询优化器预测所有扇出值满足剩余查询条件的百分比，相乘以后表示多表查询中还要对被驱动执行查询的次数</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><p>MySQL <strong>执行计划的局限</strong>：</p><ul><li>只是计划，不是执行 SQL 语句，可以随着底层优化器输入的更改而更改</li><li>EXPLAIN 不会告诉显示关于触发器、存储过程的信息对查询的影响情况， 不考虑各种 Cache</li><li>EXPLAIN 不能显示 MySQL 在执行查询时的动态，因为执行计划在执行<strong>查询之前生成</strong></li><li>EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划</li><li>EXPLAIN PLAN 显示的是在解释语句时数据库将如何运行 SQL 语句，由于执行环境和 EXPLAIN PLAN 环境的不同，此计划可能与 SQL 语句<strong>实际的执行计划不同</strong>，部分统计信息是估算的，并非精确值</li></ul><p>SHOW WARINGS：在使用 EXPALIN 命令后执行该语句，可以查询与执行计划相关的拓展信息，展示出 Level、Code、Message 三个字段，当 Code 为 1003 时，Message 字段展示的信息类似于将查询语句重写后的信息，但是不是等价，不能执行复制过来运行</p><p>环境准备：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p><hr><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id 代表 SQL 执行的顺序的标识，每个 SELECT 关键字对应一个唯一 id，所以在同一个 SELECT 关键字中的表的 id 都是相同的。SELECT 后的 FROM 可以跟随多个表，每个表都会对应一条记录，这些记录的 id 都是相同的，</p><ul><li><p>id 相同时，执行顺序由上至下。连接查询的执行计划，记录的 id 值都是相同的，出现在前面的表为驱动表，后面为被驱动表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r, t_user u, user_role ur WHERE r.id = ur.role_id AND u.id = ur.user_id ;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C.png"></p></li><li><p>id 不同时，id 值越大优先级越高，越先被执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;))</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E4%B8%8D%E5%90%8C.png"></p></li><li><p>id 有相同也有不同时，id 相同的可以认为是一组，从上往下顺序执行；在所有的组中，id 的值越大的组，优先级越高，越先执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = &#x27;2&#x27;) a WHERE r.id = a.role_id ; </span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C%E5%92%8C%E4%B8%8D%E5%90%8C.png"></p></li><li><p>id 为 NULL 时代表的是临时表</p></li></ul><hr><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>表示查询中每个 select 子句的类型（简单 OR 复杂）</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 SELECT 查询，查询中不包含子查询或者 UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层（也就是最左侧）查询标记为该标识</td></tr><tr><td>UNION</td><td>对于 UNION 或者 UNION ALL 的复杂查询，除了最左侧的查询，其余的小查询都是 UNION</td></tr><tr><td>UNION RESULT</td><td>UNION 需要使用临时表进行去重，临时表的是 UNION RESULT</td></tr><tr><td>DEPENDENT UNION</td><td>对于 UNION 或者 UNION ALL 的复杂查询，如果各个小查询都依赖外层查询，是相关子查询，除了最左侧的小查询为 DEPENDENT SUBQUERY，其余都是 DEPENDENT UNION</td></tr><tr><td>SUBQUERY</td><td>子查询不是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，会进行物化（该子查询只需要执行一次）</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，不会物化（该子查询需要执行多次）</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询，被标记为 DERIVED（衍生），也就是生成物化派生表的这个子查询</td></tr><tr><td>MATERIALIZED</td><td>将子查询物化后与与外层进行连接查询，生成物化表的子查询</td></tr></tbody></table><p>子查询为 DERIVED：<code>SELECT * FROM (SELECT key1 FROM t1) AS derived_1 WHERE key1 &gt; 10</code></p><p>子查询为 MATERIALIZED：<code>SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2)</code></p><hr><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>对表的访问方式，表示 MySQL 在表中找到所需行的方式，又称访问类型</p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>ALL</td><td>全表扫描，如果是 InnoDB 引擎是扫描聚簇索引</td></tr><tr><td>index</td><td>可以使用覆盖索引，但需要扫描全部索引</td></tr><tr><td>range</td><td>索引范围扫描，常见于 between、&lt;、&gt; 等的查询</td></tr><tr><td>index_subquery</td><td>子查询可以普通索引，则子查询的 type 为 index_subquery</td></tr><tr><td>unique_subquery</td><td>子查询可以使用主键或唯一二级索引，则子查询的 type 为 index_subquery</td></tr><tr><td>index_merge</td><td>索引合并</td></tr><tr><td>ref_or_null</td><td>非唯一性索引（普通二级索引）并且可以存储 NULL，进行等值匹配</td></tr><tr><td>ref</td><td>非唯一性索引与常量等值匹配</td></tr><tr><td>eq_ref</td><td>唯一性索引（主键或不存储 NULL 的唯一二级索引）进行等值匹配，如果二级索引是联合索引，那么所有联合的列都要进行等值匹配</td></tr><tr><td>const</td><td>通过主键或者唯一二级索引与常量进行等值匹配</td></tr><tr><td>system</td><td>system 是 const 类型的特例，当查询的表只有一条记录的情况下，使用 system</td></tr><tr><td>NULL</td><td>MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引</td></tr></tbody></table><p>从上到下，性能从差到好，一般来说需要保证查询至少达到 range 级别， 最好达到 ref </p><hr><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>possible_keys：</p><ul><li>指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li><li>如果该列是 NULL，则没有相关的索引</li></ul><p>key：</p><ul><li>显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL</li><li>查询中若使用了<strong>覆盖索引</strong>，则该索引可能出现在 key 列表，不出现在 possible_keys</li></ul><p>key_len：</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li><li>key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的</li><li>在不损失精确性的前提下，长度越短越好</li></ul><hr><h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>其他的额外的执行计划信息，在该列展示：</p><ul><li>No tables used：查询语句中使用 FROM dual 或者没有 FROM 语句</li><li>Impossible WHERE：查询语句中的 WHERE 子句条件永远为 FALSE，会导致没有符合条件的行</li><li>Using index：该值表示相应的 SELECT 操作中使用了<strong>覆盖索引</strong>（Covering Index）</li><li>Using index condition：第一种情况是搜索条件中虽然出现了索引列，但是部分条件无法形成扫描区间（<strong>索引失效</strong>），会根据可用索引的条件先搜索一遍再匹配无法使用索引的条件，回表查询数据；第二种是使用了<strong>索引条件下推</strong>优化</li><li>Using where：搜索的数据需要在 Server 层判断，无法使用索引下推</li><li>Using join buffer：连接查询被驱动表无法利用索引，需要连接缓冲区来存储中间结果</li><li>Using filesort：无法利用索引完成排序（优化方向），需要对数据使用外部排序算法，将取得的数据在内存或磁盘中进行排序</li><li>Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于<strong>排序、去重（UNION）、分组</strong>等场景</li><li>Select tables optimized away：说明仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li><li>No tables used：Query 语句中使用 from dual 或不含任何 from 子句</li></ul><p>参考文章：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html">https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html</a></p><hr><h4 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h4><p>SHOW PROFILES 能够在做 SQL 优化时分析当前会话中语句执行的<strong>资源消耗</strong>情况</p><ul><li><p>通过 have_profiling 参数，能够看到当前 MySQL 是否支持 profile：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-have_profiling.png"></p></li><li><p>默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-profiling.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET profiling=1; #开启profiling 开关；</span><br></pre></td></tr></table></figure></li><li><p>执行 SHOW PROFILES 指令， 来查看 SQL 语句执行的耗时:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8BSQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6.png"></p></li><li><p>查看到该 SQL 执行过程中每个线程的状态和消耗的时间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILE FOR QUERY query_id;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84%E6%97%B6%E9%97%B4.png"></p></li><li><p>在获取到最消耗时间的线程状态后，MySQL 支持选择 all、cpu、block io 、context switch、page faults 等类型查看 MySQL 在使用什么资源上耗费了过高的时间。例如，选择查看 CPU 的耗费时间：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84CPU.png"></p><ul><li>Status：SQL 语句执行的状态</li><li>Durationsql：执行过程中每一个步骤的耗时</li><li>CPU_user：当前用户占有的 CPU</li><li>CPU_system：系统占有的 CPU</li></ul></li></ul><hr><h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p>MySQL 提供了对 SQL 的跟踪， 通过 trace 文件可以查看优化器<strong>生成执行计划的过程</strong></p><ul><li><p>打开 trace 功能，设置格式为 JSON，并设置 trace 的最大使用内存，避免解析过程中因默认内存过小而不能够完整展示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=ON;-- 会话内有效</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure></li><li><p>执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE id &lt; 4;</span><br></pre></td></tr></table></figure></li><li><p>检查 information_schema.optimizer_trace：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.optimizer_trace \G; -- \G代表竖列展示</span><br></pre></td></tr></table></figure><p>执行信息主要有三个阶段：prepare 阶段、optimize 阶段（成本分析）、execute 阶段（执行）</p></li></ul><hr><h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>索引是数据库优化最重要的手段之一，通过索引通常可以帮助用户解决大多数的 MySQL 的性能优化问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_seller` (</span><br><span class="line">`sellerid` varchar (100),</span><br><span class="line">`name` varchar (100),</span><br><span class="line">`nickname` varchar (50),</span><br><span class="line">`password` varchar (60),</span><br><span class="line">`status` varchar (1),</span><br><span class="line">`address` varchar (100),</span><br><span class="line">`createtime` datetime,</span><br><span class="line">    PRIMARY KEY(`sellerid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values(&#x27;xiaomi&#x27;,&#x27;小米科技&#x27;,&#x27;小米官方旗舰店&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;1&#x27;,&#x27;西安市&#x27;,&#x27;2088-01-01 12:00:00&#x27;);</span><br><span class="line">CREATE INDEX idx_seller_name_sta_addr ON tb_seller(name, status, address); # 联合索引</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p><hr><h4 id="避免失效"><a href="#避免失效" class="headerlink" title="避免失效"></a>避免失效</h4><h5 id="语句错误"><a href="#语句错误" class="headerlink" title="语句错误"></a>语句错误</h5><ul><li><p>全值匹配：对索引中所有列都指定具体值，这种情况索引生效，执行效率高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%951.png"></p></li><li><p><strong>最左前缀法则</strong>：联合索引遵守最左前缀法则</p><p>匹配最左前缀法则，走索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%952.png"></p><p>违法最左前缀法则 ， 索引失效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%953.png"></p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%954.png"></p><p>虽然索引列失效，但是系统会<strong>使用了索引下推进行了优化</strong></p></li><li><p><strong>范围查询</strong>右边的列，不能使用索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status&gt;&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件 address 没有用到索引，使用了索引下推</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%955.png"></p></li><li><p>在索引列上<strong>函数或者运算（+ - 数值）操作</strong>， 索引将失效：会破坏索引值的有序性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE SUBSTRING(name,3,2) = &#x27;科技&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%956.png"></p></li><li><p><strong>字符串不加单引号</strong>，造成索引失效：隐式类型转换，当字符串和数字比较时会<strong>把字符串转化为数字</strong></p><p>没有对字符串加单引号，查询优化器会调用 CAST 函数将 status 转换为 int 进行比较，造成索引失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status = 1;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%957.png"></p><p>如果 status 是 int 类型，SQL 为 <code>SELECT * FROM tb_seller WHERE status = &#39;1&#39; </code> 并不会造成索引失效，因为会将 <code>&#39;1&#39;</code> 转换为 <code>1</code>，并<strong>不会对索引列产生操作</strong></p></li><li><p>多表连接查询时，如果两张表的<strong>字符集不同</strong>，会造成索引失效，因为会进行类型转换</p><p>解决方法：CONVERT 函数是加在输入参数上、修改表的字符集</p></li><li><p><strong>用 OR 分割条件，索引失效</strong>，导致全表查询：</p><p>OR 前的条件中的列有索引而后面的列中没有索引或 OR 前后两个列是同一个复合索引，都造成索引失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; OR createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; OR status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9510.png"></p><p><strong>AND 分割的条件不影响</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; AND createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9511.png"></p></li><li><p><strong>以 % 开头的 LIKE 模糊查询</strong>，索引失效：</p><p>如果是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9512.png"></p><p>解决方案：通过覆盖索引来解决 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT sellerid,name,status FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9513.png"></p><p>原因：在覆盖索引的这棵 B+ 数上只需要进行 like 的匹配，或者是基于覆盖索引查询再进行 WHERE 的判断就可以获得结果</p></li></ul><hr><h5 id="系统优化-1"><a href="#系统优化-1" class="headerlink" title="系统优化"></a>系统优化</h5><p>系统优化为全表扫描：</p><ul><li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引，索引失效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_address ON tb_seller(address);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;西安市&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;北京市&#x27;;</span><br></pre></td></tr></table></figure><p>北京市的键值占 9&#x2F;10（区分度低），所以优化为全表扫描，type &#x3D; ALL</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9514.png"></p></li><li><p>IS  NULL、IS NOT NULL  <strong>有时</strong>索引失效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NULL;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NOT NULL;</span><br></pre></td></tr></table></figure><p>NOT NULL 失效的原因是 name 列全部不是 null，优化为全表扫描，当 NULL 过多时，IS NULL 失效</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9515.png"></p></li><li><p>IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);-- 都走索引</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId NOT IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://time.geekbang.org/column/article/74687">MySQL 实战 45 讲</a>该章节最后提出了一种慢查询场景，获取到数据以后 Server 层还会做判断</p></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>索引失效一般是针对联合索引，联合索引一般由几个字段组成，排序方式是先按照第一个字段进行排序，然后排序第二个，依此类推，图示（a, b）索引，<strong>a 相等的情况下 b 是有序的</strong></p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理1.png" style="zoom:67%;"><ul><li><p>最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。这种无序不仅体现在叶子节点，也会<strong>导致查询时扫描的非叶子节点也是无序的</strong>，因为索引树相当于忽略的第一个字段，就无法使用二分查找</p></li><li><p>范围查询右边的列，不能使用索引，比如语句： <code>WHERE a &gt; 1 AND b = 1 </code>，在 a 大于 1 的时候，b 是无序的，a &gt; 1 是扫描时有序的，但是找到以后进行寻找 b 时，索引树就不是有序的了</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理2.png" style="zoom:67%;"></li><li><p>以 % 开头的 LIKE 模糊查询，索引失效，比如语句：<code>WHERE a LIKE &#39;%d&#39;</code>，前面的不确定，导致不符合最左匹配，直接去索引中搜索以 d 结尾的节点，所以没有顺序<br>                            <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png"></p></li></ul><p>参考文章：<a href="https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ">https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ</a></p><hr><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Handler_read%&#x27;;</span><br><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Handler_read%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png"></p><ul><li><p>Handler_read_first：索引中第一条被读的次数，如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）</p></li><li><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，值越低表示索引不经常使用（这个值越高越好）</p></li><li><p>Handler_read_next：按照键顺序读下一行的请求数，如果范围约束或执行索引扫描来查询索引列，值增加</p></li><li><p>Handler_read_prev：按照键顺序读前一行的请求数，该读方法主要用于优化 ORDER BY … DESC</p></li><li><p>Handler_read_rnd：根据固定位置读一行的请求数，如果执行大量查询并对结果进行排序则该值较高，可能是使用了大量需要 MySQL 扫描整个表的查询或连接，这个值较高意味着运行效率低，应该建立索引来解决</p></li><li><p>Handler_read_rnd_next：在数据文件中读下一行的请求数，如果正进行大量的表扫描，该值较高，说明表索引不正确或写入的查询没有利用索引</p></li></ul><hr><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><h5 id="自增机制"><a href="#自增机制" class="headerlink" title="自增机制"></a>自增机制</h5><p>自增主键可以让主键索引尽量地保持在数据页中递增顺序插入，不自增需要寻找其他页插入，导致随机 IO 和页分裂的情况</p><p>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值，不同的引擎对于自增值的保存策略不同：</p><ul><li>MyISAM 引擎的自增值保存在数据文件中</li><li>InnoDB 引擎的自增值保存在了内存里，每次打开表都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为当前的自增值；8.0 版本后，才有了自增值持久化的能力，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值</li></ul><p>在插入一行数据的时候，自增值的行为如下：</p><ul><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段</li><li>如果插入数据时 id 字段指定了具体的值，比如某次要插入的值是 X，当前的自增值是 Y<ul><li>如果 X&lt;Y，那么这个表的自增值不变</li><li>如果 X≥Y，就需要把当前自增值修改为新的自增值</li></ul></li></ul><p>参数说明：auto_increment_offset 和 auto_increment_increment 分别表示自增的初始值和步长，默认值都是 1</p><p>语句执行失败也不回退自增 id，所以保证了自增 id 是递增的，但不保证是连续的（不能回退，所以有些回滚事务的自增 id 就不会重新使用，导致出现不连续）</p><hr><h5 id="自增-ID"><a href="#自增-ID" class="headerlink" title="自增 ID"></a>自增 ID</h5><p>MySQL 不同的自增 id 在达到上限后的表现不同：</p><ul><li><p>表的自增 id 如果是 int 类型，达到上限 2^32-1 后，再申请时值就不会改变，进而导致继续插入数据时报主键冲突的错误</p></li><li><p>row_id 长度为 6 个字节，达到上限后则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据，造成旧数据丢失，影响的是数据可靠性，所以应该在 InnoDB 表中主动创建自增主键报主键冲突，插入失败影响的是可用性，而一般情况下，<strong>可靠性优先于可用性</strong></p></li><li><p>Xid 长度 8 字节，由 Server 层维护，只需要不在同一个 binlog 文件中出现重复值即可，虽然理论上会出现重复值，但是概率极小</p></li><li><p>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，重启也不会重置为 0，所以会导致一直增加到达上限，然后从 0 开始，这时原事务 0 修改的数据对当前事务就是可见的，产生脏读的现象</p><p>只读事务不分配 trx_id，所以 trx_id 的增加速度变慢了</p></li><li><p>thread_id 长度 4 个字节，到达上限后就会重置为 0，MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 时做判断，保证不会出现两个相同的 thread_id：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">new_id = thread_id_counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (!thread_ids.<span class="built_in">insert_unique</span>(new_id).second);</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/83183">https://time.geekbang.org/column/article/83183</a></p><hr><h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>复合索引叶子节点不仅保存了复合索引的值，还有主键索引，所以使用覆盖索引的时候，加上主键也会用到索引</p><p>尽量使用覆盖索引，避免 SELECT *：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%958.png"></p><p>如果查询列，超出索引列，也会降低性能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address,password FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%959.png"></p><hr><h4 id="减少访问"><a href="#减少访问" class="headerlink" title="减少访问"></a>减少访问</h4><p>避免对数据进行重复检索：能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求</p><ul><li><p>查询数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name FROM tb_book;</span><br><span class="line">SELECT id,status FROM tb_book; -- 向数据库提交两次请求，数据库就要做两次查询操作</span><br><span class="line">-- &gt; 优化为:</span><br><span class="line">SELECT id,name,statu FROM tb_book;</span><br></pre></td></tr></table></figure></li><li><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);-- 连接三次数据库</span><br><span class="line">-- &gt;优化为</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;)，(3,&#x27;Jerry&#x27;);-- 连接一次</span><br></pre></td></tr></table></figure></li><li><p>在事务中进行数据插入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br><span class="line">commit;-- 手动提交，分段提交</span><br></pre></td></tr></table></figure></li><li><p>数据有序插入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br></pre></td></tr></table></figure></li></ul><p>增加 cache 层：在应用中增加缓存层来达到减轻数据库负担的目的。可以部分数据从数据库中抽取出来放到应用端以文本方式存储，或者使用框架（Mybatis）提供的一级缓存 &#x2F; 二级缓存，或者使用 Redis 数据库来缓存数据 </p><hr><h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><p>当使用 load 命令导入数据的时候，适当的设置可以提高导入的效率：</p><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> load data.png)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE = &#x27;/home/seazean/sql1.log&#x27; INTO TABLE `tb_user_1` FIELD TERMINATED BY &#x27;,&#x27; LINES TERMINATED BY &#x27;\n&#x27;; -- 文件格式如上图</span><br></pre></td></tr></table></figure><p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p><ol><li><p><strong>主键顺序插入</strong>：因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率，如果 InnoDB 表没有主键，那么系统会自动默认创建一个内部列作为主键</p><p>主键是否连续对性能影响不大，只要是递增的就可以，比如雪花算法产生的 ID 不是连续的，但是是递增的，因为递增可以让主键索引尽量地保持顺序插入，<strong>避免了页分裂</strong>，因此索引更紧凑</p><ul><li>插入 ID 顺序排列数据：</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p><ul><li>插入 ID 无序排列数据：</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E6%97%A0%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p></li><li><p><strong>关闭唯一性校验</strong>：在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验；导入结束后执行 <code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%85%B3%E9%97%AD%E5%94%AF%E4%B8%80%E6%80%A7%E6%A0%A1%E9%AA%8C.png"></p></li><li><p><strong>手动提交事务</strong>：如果应用使用自动提交的方式，建议在导入前执行<code>SET AUTOCOMMIT=0</code>，关闭自动提交；导入结束后再打开自动提交，可以提高导入的效率。</p><p>事务需要控制大小，事务太大可能会影响执行的效率。MySQL 有 innodb_log_buffer_size 配置项，超过这个值的日志会写入磁盘数据，效率会下降，所以在事务大小达到配置项数据级前进行事务提交可以提高效率</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png"></p></li></ol><hr><h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><h5 id="ORDER"><a href="#ORDER" class="headerlink" title="ORDER"></a>ORDER</h5><p>数据准备：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `emp` (</span><br><span class="line">  `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(100) NOT NULL,</span><br><span class="line">  `age` INT(3) NOT NULL,</span><br><span class="line">  `salary` INT(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `emp` (`id`, `name`, `age`, `salary`) VALUES(&#x27;1&#x27;,&#x27;Tom&#x27;,&#x27;25&#x27;,&#x27;2300&#x27;);-- ...</span><br><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure><ul><li><p>第一种是通过对返回数据进行排序，所有不通过索引直接返回结果的排序都叫 FileSort 排序，会在内存中重新排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp ORDER BY age DESC;-- 年龄降序</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序1.png)</p></li><li><p>第二种通过有序索引顺序扫描直接返回<strong>有序数据</strong>，这种情况为 Using index，不需要额外排序，操作效率高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, age, salary FROM emp ORDER BY age DESC;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序2.png)</p></li><li><p>多字段排序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY salary DESC, age DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary ASC;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序3.png)</p><p>尽量减少额外的排序，通过索引直接返回有序数据。<strong>需要满足 Order by 使用相同的索引、Order By 的顺序和索引顺序相同、Order  by 的字段都是升序或都是降序</strong>，否则需要额外的操作，就会出现 FileSort</p></li><li><p>ORDER BY RAND() 命令用来进行随机排序，会使用了临时内存表，临时内存表排序的时使用 rowid 排序方法</p></li></ul><p>优化方式：创建合适的索引能够减少 Filesort 的出现，但是某些情况下条件限制不能让 Filesort 消失，就要加快 Filesort 的排序操作</p><p>内存临时表，MySQL 有两种 Filesort 排序算法：</p><ul><li><p>rowid 排序：首先根据条件取出排序字段和信息，然后在<strong>排序区 sort buffer（Server 层）</strong>中排序，如果 sort buffer 不够，则在临时表 temporary table 中存储排序结果。完成排序后再根据行指针<strong>回表读取记录</strong>，该操作可能会导致大量随机 I&#x2F;O 操作</p><p>说明：对于临时内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，不会导致多访问磁盘，优先选择该方式</p></li><li><p>全字段排序：一次性取出满足条件的所有数据，需要回表，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法高</p></li></ul><p>具体的选择方式：</p><ul><li><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和 Query 语句取出的字段的大小，来判定使用哪种排序算法。如果前者大，则说明 sort  buffer 空间足够，使用第二种优化之后的算法，否则使用第一种。</p></li><li><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@max_length_for_sort_data = 10000; -- 设置全局变量</span><br><span class="line">SET max_length_for_sort_data = 10240; -- 设置会话变量</span><br><span class="line">SHOW VARIABLES LIKE &#x27;max_length_for_sort_data&#x27;;-- 默认1024</span><br><span class="line">SHOW VARIABLES LIKE &#x27;sort_buffer_size&#x27;;-- 默认262114</span><br></pre></td></tr></table></figure></li></ul><p>磁盘临时表：排序使用优先队列（堆）的方式</p><hr><h5 id="GROUP"><a href="#GROUP" class="headerlink" title="GROUP"></a>GROUP</h5><p>GROUP BY 也会进行排序操作，与 ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作，所以在 GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引</p><ul><li><p>分组查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_emp_age_salary ON emp;</span><br><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序1.png)</p><p>Using temporary：表示 MySQL 需要使用临时表（不是 sort buffer）来存储结果集，常见于排序和分组查询</p></li><li><p>查询包含 GROUP BY 但是用户想要避免排序结果的消耗， 则可以执行 ORDER BY NULL 禁止排序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age ORDER BY NULL;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序2.png)</p></li><li><p>创建索引：索引本身有序，不需要临时表，也不需要再额外排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序3.png)</p></li><li><p>数据量很大时，使用 SQL_BIG_RESULT 提示优化器直接使用直接用磁盘临时表</p></li></ul><hr><h4 id="联合查询-1"><a href="#联合查询-1" class="headerlink" title="联合查询"></a>联合查询</h4><p>对于包含 OR 的查询子句，如果要利用索引，则 OR 之间的<strong>每个条件列都必须用到索引，而且不能使用到条件之间的复合索引</strong>，如果没有索引，则应该考虑增加索引</p><ul><li><p>执行查询语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 OR age = 30;-- 两个索引，并且不是复合索引</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询1.png)</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Extra: Using sort_union(idx_emp_age_salary,PRIMARY); Using <span class="built_in">where</span></span><br></pre></td></tr></table></figure></li><li><p>使用 UNION 替换 OR，求并集：</p><p>注意：该优化只针对多个索引列有效，如果有列没有被索引，查询效率可能会因为没有选择 OR 而降低</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 UNION SELECT * FROM emp WHERE age = 30;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询2.png)</p></li><li><p>UNION 要优于 OR 的原因：</p><ul><li>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range</li><li>UNION 语句的 ref 值为 const，OR 语句的 ref 值为 null，const 表示是常量值引用，非常快</li></ul></li></ul><hr><h4 id="嵌套查询-1"><a href="#嵌套查询-1" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>MySQL 4.1 版本之后，开始支持 SQL 的子查询</p><ul><li>可以使用 SELECT 语句来创建一个单列的查询结果，然后把结果作为过滤条件用在另一个查询中</li><li>使用子查询可以一次性的完成逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死</li><li>在有些情况下，<strong>子查询是可以被更高效的连接（JOIN）替代</strong></li></ul><p>例如查找有角色的所有的用户信息：</p><ul><li><p>执行计划：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user WHERE id IN (SELECT user_id FROM user_role);</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A21.png"></p></li><li><p>优化后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user u , user_role ur WHERE u.id = ur.user_id;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A22.png"></p><p>连接查询之所以效率更高 ，是因为<strong>不需要在内存中创建临时表</strong>来完成逻辑上需要两个步骤的查询工作</p></li></ul><hr><h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能</p><p>一个常见的问题是 <code>LIMIT 200000,10</code>，此时需要 MySQL 扫描前 200010 记录，仅仅返回 200000 - 200010 之间的记录，其他记录丢弃，查询排序的代价非常大</p><ul><li><p>分页查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 LIMIT 200000,10;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A21.png"></p></li><li><p>优化方式一：内连接查询，在索引列 id 上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 t,(SELECT id FROM tb_user_1 ORDER BY id LIMIT 200000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A22.png"></p></li><li><p>优化方式二：方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id &gt; 200000 LIMIT 10;-- 写法 1</span><br><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id BETWEEN 200000 and 200010;-- 写法 2</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A23.png"></p></li></ul><hr><h4 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h4><p>SQL 提示，是优化数据库的一个重要手段，就是在 SQL 语句中加入一些提示来达到优化操作的目的</p><ul><li><p>USE INDEX：在查询语句中表名的后面添加 USE INDEX 来提供 MySQL 去参考的索引列表，可以让 MySQL 不再考虑其他可用的索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_seller_name ON tb_seller(name);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller USE INDEX(idx_seller_name) WHERE name=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA1.png"></p></li><li><p>IGNORE INDEX：让 MySQL 忽略一个或者多个索引，则可以使用 IGNORE INDEX 作为提示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller IGNORE INDEX(idx_seller_name) WHERE name = &#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA2.png"></p></li><li><p>FORCE INDEX：强制 MySQL 使用一个特定的索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller FORCE INDEX(idx_seller_name_sta_addr) WHERE NAME=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA3.png"></p></li></ul><hr><h4 id="统计计数"><a href="#统计计数" class="headerlink" title="统计计数"></a>统计计数</h4><p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高，但不支持事务</li><li>show table status 命令通过采样估算可以快速获取，但是不准确</li><li>InnoDB 表执行 count(*) 会遍历全表，虽然结果准确，但会导致性能问题</li></ul><p>解决方案：</p><ul><li><p>计数保存在 Redis 中，但是更新 MySQL 和 Redis 的操作不是原子的，会存在数据一致性的问题</p></li><li><p>计数直接放到数据库里单独的一张计数表中，利用事务解决计数精确问题：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-计数count优化.png" style="zoom: 50%;"><p>会话 B 的读操作在 T3 执行的，这时更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见，因此会话 B 查询的计数值和最近 100 条记录，返回的结果逻辑上就是一致的</p><p>并发系统性能的角度考虑，应该先插入操作记录再更新计数表，因为更新计数表涉及到行锁的竞争，<strong>先插入再更新能最大程度地减少事务之间的锁等待，提升并发度</strong></p></li></ul><p>count 函数的按照效率排序：<code>count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)</code>，所以建议尽量使用 count(*)</p><ul><li>count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来返回给 Server 层，Server 判断 id 不为空就按行累加</li><li>count(1)：InnoDB 引擎遍历整张表但不取值，Server 层对于返回的每一行，放一个数字 1 进去，判断不为空就按行累加</li><li>count(字段)：如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li><li>count(*)：不取值，按行累加</li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/72775">https://time.geekbang.org/column/article/72775</a></p><hr><h3 id="缓冲优化"><a href="#缓冲优化" class="headerlink" title="缓冲优化"></a>缓冲优化</h3><h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><p>三个原则：</p><ul><li>将尽量多的内存分配给 MySQL 做缓存，但也要给操作系统和其他程序预留足够内存</li><li>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的 IO 缓存，如果有 MyISAM 表，就要预留更多的内存给操作系统做 IO 缓存</li><li>排序区、连接区等缓存是分配给每个数据库会话（Session）专用的，值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发数较高时会导致物理内存耗尽</li></ul><hr><h4 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h4><p>Buffer Pool 本质上是 InnoDB 向操作系统申请的一段连续的内存空间。InnoDB 的数据是按数据页为单位来读写，每个数据页的大小默认是 16KB。数据是存放在磁盘中，每次读写数据都需要进行磁盘 IO 将数据读入内存进行操作，效率会很低，所以提供了 Buffer Pool 来暂存这些数据页，缓存中的这些页又叫缓冲页</p><p>工作原理：</p><ul><li>从数据库读取数据时，会首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入 Buffer Pool</li><li>向数据库写入数据时，会写入缓存，缓存中修改的数据会<strong>定期刷新</strong>到磁盘，这一过程称为刷脏</li></ul><p>Buffer Pool 中每个缓冲页都有对应的控制信息，包括表空间编号、页号、偏移量、链表信息等，控制信息存放在占用的内存称为控制块，控制块与缓冲页是一一对应的，但并不是物理上相连的，都在缓冲池中</p><p>MySQL 提供了缓冲页的快速查找方式：<strong>哈希表</strong>，使用表空间号和页号作为 Key，缓冲页控制块的地址作为 Value 创建一个哈希表，获取数据页时根据 Key 进行哈希寻址：</p><ul><li>如果不存在对应的缓存页，就从 free 链表中选一个空闲缓冲页，把磁盘中的对应页加载到该位置</li><li>如果存在对应的缓存页，直接获取使用，提高查询数据的效率</li></ul><p>当内存数据页跟磁盘数据页内容不一致时，称这个内存页为脏页；内存数据写入磁盘后，内存和磁盘上的数据页一致，称为干净页</p><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="Free-链表"><a href="#Free-链表" class="headerlink" title="Free 链表"></a>Free 链表</h5><p>MySQL 启动时完成对 Buffer Pool 的初始化，先向操作系统申请连续的内存空间，然后将内存划分为若干对控制块和缓冲页。为了区分空闲和已占用的数据页，将所有空闲缓冲页对应的<strong>控制块作为一个节点</strong>放入一个链表中，就是 Free 链表（<strong>空闲链表</strong>）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-空闲链表.png" style="zoom: 50%;"><p>基节点：是一块单独申请的内存空间（占 40 字节），并不在 Buffer Pool 的那一大片连续内存空间里</p><p>磁盘加载页的流程：</p><ul><li>从 Free 链表中取出一个空闲的缓冲页</li><li>把缓冲页对应的控制块的信息填上（页所在的表空间、页号之类的信息）</li><li>把缓冲页对应的 Free 链表节点（控制块）从链表中移除，表示该缓冲页已经被使用</li></ul><p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121124440">https://blog.csdn.net/li1325169021/article/details/121124440</a></p><hr><h5 id="Flush-链表"><a href="#Flush-链表" class="headerlink" title="Flush 链表"></a>Flush 链表</h5><p>Flush 链表是一个用来<strong>存储脏页</strong>的链表，对于已经修改过的缓冲脏页，第一次修改后加入到<strong>链表头部</strong>，以后每次修改都不会重新加入，只修改部分控制信息，出于性能考虑并不是直接更新到磁盘，而是在未来的某个时间进行刷脏</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-脏页链表.png" style="zoom:50%;"><p><strong>后台有专门的线程每隔一段时间把脏页刷新到磁盘</strong>：</p><ul><li>从 Flush 链表中刷新一部分页面到磁盘：<ul><li><strong>后台线程定时</strong>从 Flush 链表刷脏，根据系统的繁忙程度来决定刷新速率，这种方式称为 BUF_FLUSH_LIST</li><li>线程刷脏的比较慢，导致用户线程加载一个新的数据页时发现没有空闲缓冲页，此时会尝试从 LRU 链表尾部寻找缓冲页直接释放，如果该页面是已经修改过的脏页就<strong>同步刷新</strong>到磁盘，速度较慢，这种方式称为 BUF_FLUSH_SINGLE_PAGE</li></ul></li><li>从 LRU 链表的冷数据中刷新一部分页面到磁盘，即：BUF_FLUSH_LRU<ul><li>后台线程会定时从 LRU 链表的尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 指定，如果在 LRU 链表中发现脏页，则把它们刷新到磁盘，这种方式称为 BUF_FLUSH_LRU</li><li>控制块里会存储该缓冲页是否被修改的信息，所以可以很容易的获取到某个缓冲页是否是脏页</li></ul></li></ul><p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121125765">https://blog.csdn.net/li1325169021/article/details/121125765</a></p><hr><h5 id="LRU-链表"><a href="#LRU-链表" class="headerlink" title="LRU 链表"></a>LRU 链表</h5><p>Buffer Pool 需要保证缓存的命中率，所以 MySQL 创建了一个 LRU 链表，当访问某个页时：</p><ul><li>如果该页不在 Buffer Pool 中，把该页从磁盘加载进来后会将该缓冲页对应的控制块作为节点放入 <strong>LRU 链表的头部</strong>，保证热点数据在链表头</li><li>如果该页在 Buffer Pool 中，则直接把该页对应的控制块移动到 LRU 链表的头部，所以 LRU 链表尾部就是最近最少使用的缓冲页</li></ul><p>MySQL 基于局部性原理提供了预读功能：</p><ul><li>线性预读：系统变量 <code>innodb_read_ahead_threshold</code>，如果顺序访问某个区（extent：16 KB 的页，连续 64 个形成一个区，一个区默认 1MB 大小）的页面数超过了该系统变量值，就会触发一次<strong>异步读取</strong>下一个区中全部的页面到 Buffer Pool 中</li><li>随机预读：如果某个区 13 个连续的页面都被加载到 Buffer Pool，无论这些页面是否是顺序读取，都会触发一次<strong>异步读取</strong>本区所有的其他页面到 Buffer Pool 中</li></ul><p>预读会造成加载太多用不到的数据页，造成那些使用频率很高的数据页被挤到 LRU 链表尾部，所以 InnoDB 将 LRU 链表分成两段，<strong>冷热数据隔离</strong>：</p><ul><li>一部分存储使用频率很高的数据页，这部分链表也叫热数据，young 区，靠近链表头部的区域</li><li>一部分存储使用频率不高的冷数据，old 区，靠近链表尾部，默认占 37%，可以通过系统变量 <code>innodb_old_blocks_pct</code> 指定</li></ul><p>当磁盘上的某数据页被初次加载到 Buffer Pool 中会被放入 old 区，淘汰时优先淘汰 old 区</p><ul><li>当对 old 区的数据进行访问时，会在控制块记录下访问时间，等待后续的访问时间与第一次访问的时间是否在某个时间间隔内，通过系统变量 <code>innodb_old_blocks_time</code> 指定时间间隔，默认 1000ms，成立就<strong>移动到 young 区的链表头部</strong></li><li><code>innodb_old_blocks_time</code> 为 0 时，每次访问一个页面都会放入 young 区的头部</li></ul><hr><h4 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h4><p>InnoDB 用一块内存区做 IO 缓存池，该缓存池不仅用来缓存 InnoDB 的索引块，也用来缓存 InnoDB 的数据块，可以通过下面的指令查看 Buffer Pool 的状态信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure><p><code>Buffer pool hit rate</code> 字段代表<strong>内存命中率</strong>，表示 Buffer Pool 对查询的加速效果</p><p>核心参数：</p><ul><li><p><code>innodb_buffer_pool_size</code>：该变量决定了 Innodb 存储引擎表数据和索引数据的最大缓存区大小，默认 128M</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure><p>在保证操作系统及其他程序有足够内存可用的情况下，<code>innodb_buffer_pool_size</code> 的值越大，缓存命中率越高，建议设置成可用物理内存的 60%~80%</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size=512M</span><br></pre></td></tr></table></figure></li><li><p><code>innodb_log_buffer_size</code>：该值决定了 Innodb 日志缓冲区的大小，保存要写入磁盘上的日志文件数据</p><p>对于可能产生大量更新记录的大事务，增加该值的大小，可以避免 Innodb 在事务提交前就执行不必要的日志写入磁盘操作，影响执行效率，通过配置文件修改：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size=10M</span><br></pre></td></tr></table></figure></li></ul><p>在多线程下，访问 Buffer Pool 中的各种链表都需要加锁，所以将 Buffer Pool 拆成若干个小实例，<strong>每个线程对应一个实例</strong>，独立管理内存空间和各种链表（类似 ThreadLocal），多线程访问各自实例互不影响，提高了并发能力</p><p>MySQL 5.7.5 之前 <code>innodb_buffer_pool_size</code> 只支持在系统启动时修改，现在已经支持运行时修改 Buffer Pool 的大小，但是每次调整参数都会重新向操作系统申请一块连续的内存空间，<strong>将旧的缓冲池的内容拷贝到新空间</strong>非常耗时，所以 MySQL 开始以一个 chunk 为单位向操作系统申请内存，所以一个 Buffer Pool 实例可以由多个 chunk 组成</p><ul><li>在系统启动时设置系统变量 <code>innodb_buffer_pool_instance</code> 可以指定 Buffer Pool 实例的个数，但是当 Buffer Pool 小于 1GB 时，设置多个实例时无效的</li><li>指定系统变量 <code>innodb_buffer_pool_chunk_size</code> 来改变 chunk 的大小，只能在启动时修改，运行中不能修改，而且该变量并不包含缓冲页的控制块的内存大小</li><li><code>innodb_buffer_pool_size</code> 必须是 <code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instance</code> 的倍数，默认值是 <code>128M × 16 = 2G</code>，Buffer Pool 必须是 2G 的整数倍，如果指定 5G，会自动调整成 6G</li><li>如果启动时 <code>chunk × instances</code> &gt; <code>pool_size</code>，那么 chunk 的值会自动设置为 <code>pool_size ÷ instances</code></li></ul><hr><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><h4 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h4><p>InnoDB 管理的 Buffer Pool 中有一块内存叫 Change Buffer 用来对<strong>增删改操作</strong>提供缓存，可以通过参数来动态设置，设置为 50 时表示 Change Buffer 的大小最多占用 Buffer Pool 的 50%</p><ul><li>唯一索引的更新不能使用 Change Buffer，需要将数据页读入内存，判断没有冲突在写入</li><li>普通索引可以使用 Change Buffer，<strong>直接写入 Buffer 就结束</strong>，不用校验唯一性</li></ul><p>Change Buffer 并不是数据页，只是对操作的缓存，所以需要将 Change Buffer 中的操作应用到旧数据页，得到新的数据页（脏页）的过程称为 Merge</p><ul><li>触发时机：访问数据页时会触发 Merge、后台有定时线程进行 Merge、在数据库正常关闭（shutdown）的过程中也会触发</li><li>工作流程：首先从磁盘读入数据页到内存（因为 Buffer Pool 中不一定存在对应的数据页），从 Change Buffer 中找到对应的操作应用到数据页，得到新的数据页即为脏页，然后写入 redo log，等待刷脏即可</li></ul><p>说明：Change Buffer 中的记录，在事务提交时也会写入 redo log，所以是可以保证不丢失的</p><p>业务场景：</p><ul><li><p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 Change Buffer 的使用效果最好，常见的就是账单类、日志类的系统</p></li><li><p>一个业务的更新模式是写入后马上做查询，那么即使满足了条件，将更新先记录在 Change Buffer，但之后由于马上要访问这个数据页，会立即触发 Merge 过程，这样随机访问 IO 的次数不会减少，并且增加了 Change Buffer 的维护代价</p></li></ul><p>补充：Change Buffer 的前身是 Insert Buffer，只能对 Insert 操作优化，后来增加了 Update&#x2F;Delete 的支持，改为 Change Buffer</p><hr><h4 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h4><p>Server 层针对优化<strong>查询</strong>的内存为 Net Buffer，内存的大小是由参数 <code>net_buffer_length</code>定义，默认 16k，实现流程：</p><ul><li>获取一行数据写入 Net Buffer，重复获取直到 Net Buffer 写满，调用网络接口发出去</li><li>若发送成功就清空 Net Buffer，然后继续取下一行；若发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，表示本地网络栈 <code>socket send buffer</code> 写满了，<strong>进入等待</strong>，直到网络栈重新可写再继续发送</li></ul><p>MySQL 采用的是边读边发的逻辑，因此对于数据量很大的查询来说，不会在 Server 端保存完整的结果集，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是<strong>不会把内存打爆导致 OOM</strong></p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询内存优化.png" style="zoom:50%;"><p>SHOW PROCESSLIST 获取线程信息后，处于 Sending to client 状态代表服务器端的网络栈写满，等待客户端接收数据</p><p>假设有一个业务的逻辑比较复杂，每读一行数据以后要处理很久的逻辑，就会导致客户端要过很久才会去取下一行数据，导致 MySQL 的阻塞，一直处于 Sending to client 的状态</p><p>解决方法：如果一个查询的返回结果很是很多，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存</p><p>参考文章：<a href="https://blog.csdn.net/qq_33589510/article/details/117673449">https://blog.csdn.net/qq_33589510/article/details/117673449</a></p><hr><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>read_rnd_buffer 是 MySQL 的随机读缓冲区，当按任意顺序读取记录行时将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，大小是由 read_rnd_buffer_size 参数控制的</p><p>Multi-Range Read 优化，<strong>将随机 IO 转化为顺序 IO</strong> 以降低查询过程中 IO 开销，因为大多数的数据都是按照主键递增顺序插入得到，所以按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能</p><p>二级索引为 a，聚簇索引为 id，优化回表流程：</p><ul><li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中</li><li>将 read_rnd_buffer 中的 id 进行<strong>递增排序</strong></li><li>排序后的 id 数组，依次回表到主键 id 索引中查记录，并作为结果返回</li></ul><p>说明：如果步骤 1 中 read_rnd_buffer 放满了，就会先执行步骤 2 和 3，然后清空 read_rnd_buffer，之后继续找索引 a 的下个记录</p><p>使用 MRR 优化需要设进行设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr_cost_based=off&#x27;</span><br></pre></td></tr></table></figure><hr><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>MyISAM 存储引擎使用 key_buffer 缓存索引块，加速 MyISAM 索引的读写速度。对于 MyISAM 表的数据块没有特别的缓存机制，完全依赖于操作系统的 IO 缓存</p><ul><li><p>key_buffer_size：该变量决定 MyISAM 索引块缓存区的大小，直接影响到 MyISAM 表的存取效率</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;key_buffer_size&#x27;;-- 单位是字节</span><br></pre></td></tr></table></figure><p>在 MySQL 配置文件中设置该值，建议至少将1&#x2F;4可用内存分配给 key_buffer_size：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line">key_buffer_size=1024M</span><br></pre></td></tr></table></figure></li><li><p>read_buffer_size：如果需要经常顺序扫描 MyISAM 表，可以通过增大 read_buffer_size 的值来改善性能。但 read_buffer_size 是每个 Session 独占的，如果默认值设置太大，并发环境就会造成内存浪费</p></li><li><p>read_rnd_buffer_size：对于需要做排序的 MyISAM 表的查询，如带有 ORDER BY 子句的语句，适当增加该的值，可以改善此类的 SQL 的性能，但是 read_rnd_buffer_size 是每个 Session 独占的，如果默认值设置太大，就会造成内存浪费</p></li></ul><hr><h3 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>系统表空间是用来放系统信息的，比如数据字典什么的，对应的磁盘文件是 ibdata，数据表空间是一个个的表数据文件，对应的磁盘文件就是表名.ibd</p><p>表数据既可以存在共享表空间里，也可以是单独的文件，这个行为是由参数 innodb_file_per_table 控制的：</p><ul><li>OFF：表示表的数据放在系统共享表空间，也就是跟数据字典放在一起</li><li>ON ：表示每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中（默认）</li></ul><p>一个表单独存储为一个文件更容易管理，在不需要这个表时通过 drop table 命令，系统就会直接删除这个文件；如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p><hr><h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>MySQL 的数据删除就是移除掉某个记录后，该位置就被标记为<strong>可复用</strong>，如果有符合范围条件的数据可以插入到这里。符合范围条件的意思是假设删除记录 R4，之后要再插入一个 ID 在 300 和 600 之间的记录时，就会复用这个位置</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-删除数据.png" style="zoom:50%;"><p>InnoDB 的数据是按页存储的如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了，如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用</p><p>删除命令其实只是把记录的位置，或者<strong>数据页标记为了可复用，但磁盘文件的大小是不会变的</strong>，这些可以复用还没有被使用的空间，看起来就像是空洞，造成数据库的稀疏，因此需要进行紧凑处理</p><hr><h4 id="重建数据"><a href="#重建数据" class="headerlink" title="重建数据"></a>重建数据</h4><p>重建表就是按照主键 ID 递增的顺序，把数据一行一行地从旧表中读出来再插入到新表中，让数据更加紧凑。重建表时 MySQL 会自动完成转存数据、交换表名、删除旧表的操作，线上操作会阻塞大量的线程增删改查的操作</p><p>重建命令：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure><p>工作流程：新建临时表 tmp_table B（在 Server 层创建的），把表 A 中的数据导入到表 B 中，操作完成后用表 B 替换表 A，完成重建</p><p>重建表的步骤需要 DDL 不是 Online 的，因为在导入数据的过程有新的数据要写入到表 A 的话，就会造成数据丢失</p><p>MySQL 5.6 版本开始引入的 <strong>Online DDL</strong>，重建表的命令默认执行此步骤：</p><ul><li>建立一个临时文件 tmp_file（InnoDB 创建），扫描表 A 主键的所有数据页</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3</li><li>用临时文件替换表 A 的数据文件</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-重建表.png" style="zoom: 67%;"><p>Online DDL 操作会先获取 MDL 写锁，再退化成 MDL 读锁。但 MDL 写锁持有时间比较短，所以可以称为 Online； 而 MDL 读锁，不阻止数据增删查改，但会阻止其它线程修改表结构（可以对比 <code>ANALYZE TABLE t</code>  命令）</p><p>问题：重建表可以收缩表空间，但是执行指令后整体占用空间增大</p><p>原因：在重建表后 InnoDB 不会把整张表占满，每个页留了 1&#x2F;16 给后续的更新使用。表在未整理之前页已经占用 15&#x2F;16 以上，收缩之后需要保持数据占用空间在 15&#x2F;16，所以文件占用空间更大才能保持</p><p>注意：临时文件也要占用空间，如果空间不足会重建失败</p><hr><h4 id="原地置换"><a href="#原地置换" class="headerlink" title="原地置换"></a>原地置换</h4><p>DDL 中的临时表 tmp_table 是在 Server 层创建的，Online DDL 中的临时文件 tmp_file 是 InnoDB 在内部创建出来的，整个 DDL 过程都在 InnoDB 内部完成，对于 Server 层来说，没有把数据挪动到临时表，是一个原地操作，这就是 inplace</p><p>两者的关系：</p><ul><li>DDL 过程如果是 Online 的，就一定是 inplace 的</li><li>inplace 的 DDL，有可能不是 Online 的，截止到 MySQL 8.0，全文索引（FULLTEXT）和空间索引（SPATIAL）属于这种情况</li></ul><hr><h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在 MySQL 中，控制并发连接和线程的主要参数：</p><ul><li><p>max_connections：控制允许连接到 MySQL 数据库的最大连接数，默认值是 151</p><p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值</p><p>MySQL 最大可支持的连接数取决于很多因素，包括操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度、期望的响应时间等。在 Linux 平台下，性能好的服务器，可以支持 500-1000 个连接，需要根据服务器性能进行评估设定</p></li><li><p>innodb_thread_concurrency：并发线程数，代表系统内同时运行的线程数量（已经被移除）</p></li><li><p>back_log：控制 MySQL 监听 TCP 端口时的积压请求栈的大小</p><p>如果 Mysql 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log。如果等待连接的数量超过 back_log，将不被授予连接资源直接报错</p><p>5.6.6 版本之前默认值为 50，之后的版本默认为 <code>50 + (max_connections/5)</code>，但最大不超过900，如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大 back_log 的值</p></li><li><p>table_open_cache：控制所有 SQL 语句执行线程可打开表缓存的数量</p><p>在执行 SQL 语句时，每个执行线程至少要打开1个表缓存，该参数的值应该根据设置的最大连接数以及每个连接执行关联查询中涉及的表的最大数量来设定：<code>max_connections * N</code></p></li><li><p>thread_cache_size：可控制 MySQL 缓存客户服务线程的数量</p><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，池化思想</p></li><li><p>innodb_lock_wait_timeout：设置 InnoDB 事务等待行锁的时间，默认值是 50ms</p><p>对于需要快速反馈的业务系统，可以将行锁的等待时间调小，以避免事务被长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作</p></li></ul><hr><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQL 支持事务。</p><p>单元中的每条 SQL 语句都相互依赖，形成一个整体</p><ul><li><p>如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态</p></li><li><p>如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行</p></li></ul><p>事务的四大特征：ACID</p><ul><li>原子性 (atomicity)</li><li>一致性 (consistency)</li><li>隔离性 (isolaction)</li><li>持久性 (durability)</li></ul><p>事务的几种状态：</p><ul><li>活动的（active）：事务对应的数据库操作正在执行中</li><li>部分提交的（partially committed）：事务的最后一个操作执行完，但是内存还没刷新至磁盘</li><li>失败的（failed）：当事务处于活动状态或部分提交状态时，如果数据库遇到了错误或刷脏失败，或者用户主动停止当前的事务</li><li>中止的（aborted）：失败状态的事务回滚完成后的状态</li><li>提交的（committed）：当处于部分提交状态的事务刷脏成功，就处于提交状态</li></ul><hr><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>事务管理的三个步骤</p><ol><li><p>开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败</p></li><li><p>执行 SQL 语句：执行具体的一条或多条 SQL 语句</p></li><li><p>结束事务（提交|回滚）</p><ul><li>提交：没出现问题，数据进行更新</li><li>回滚：出现问题，数据恢复到开启事务时的状态</li></ul></li></ol><p>事务操作：</p><ul><li><p>显式开启事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION [READ ONLY|READ WRITE|WITH CONSISTENT SNAPSHOT]; #可以跟一个或多个状态，最后的是一致性读</span><br><span class="line">BEGIN [WORK];</span><br></pre></td></tr></table></figure><p>说明：不填状态默认是读写事务</p></li><li><p>回滚事务，用来手动中止事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></li><li><p>提交事务，显示执行是手动提交，MySQL 默认为自动提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li><li><p>保存点：在事务的执行过程中设置的还原点，调用 ROLLBACK 时可以指定回滚到哪个点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT point_name;#设置保存点</span><br><span class="line">RELEASE point_name#删除保存点</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] point_name#回滚至某个保存点，不填默认回滚到事务执行之前的状态</span><br></pre></td></tr></table></figure></li><li><p>操作演示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 张三给李四转账500元</span><br><span class="line">-- 1.张三账户-500</span><br><span class="line">UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;</span><br><span class="line">-- 2.李四账户+500</span><br><span class="line">UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 回滚事务(出现问题)</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 提交事务(没出现问题)</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h4><p>提交方式的相关语法：</p><ul><li><p>查看事务提交方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;  -- 会话，1 代表自动提交    0 代表手动提交</span><br><span class="line">SELECT @@GLOBAL.AUTOCOMMIT;-- 系统</span><br></pre></td></tr></table></figure></li><li><p>修改事务提交方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@AUTOCOMMIT=数字;-- 系统</span><br><span class="line">SET AUTOCOMMIT=数字;-- 会话</span><br></pre></td></tr></table></figure></li><li><p><strong>系统变量的操作</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] 变量名 <span class="operator">=</span> 值;<span class="comment">-- 默认是会话</span></span><br><span class="line"><span class="keyword">SET</span> @@[(<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION).]变量名 <span class="operator">=</span> 值;<span class="comment">-- 默认是系统</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] VARIABLES [<span class="keyword">LIKE</span> <span class="string">&#x27;变量%&#x27;</span>];  <span class="comment">-- 默认查看会话内系统变量值</span></span><br></pre></td></tr></table></figure></li></ul><p>工作原理：</p><ul><li>自动提交：如果没有 START TRANSACTION 显式地开始一个事务，那么<strong>每条 SQL 语句都会被当做一个事务执行提交操作</strong>；显式开启事务后，会在本次事务结束（提交或回滚）前暂时关闭自动提交</li><li>手动提交：不需要显式的开启事务，所有的 SQL 语句都在一个事务中，直到执行了提交或回滚，然后进入下一个事务</li><li>隐式提交：存在一些特殊的命令，在事务中执行了这些命令会马上<strong>强制执行 COMMIT 提交事务</strong><ul><li><strong>DDL 语句</strong> (CREATE&#x2F;DROP&#x2F;ALTER)、LOCK TABLES 语句、LOAD DATA 导入数据语句、主从复制语句等</li><li>当一个事务还没提交或回滚，显式的开启一个事务会隐式的提交上一个事务</li></ul></li></ul><hr><h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>事务在执行过程中对某个表执行了<strong>增删改操作或者创建表</strong>，就会为当前事务分配一个独一无二的事务 ID（对临时表并不会分配 ID），如果当前事务没有被分配 ID，默认是 0</p><p>说明：只读事务不能对普通的表进行增删改操作，但是可以对临时表增删改，读写事务可以对数据表执行增删改查操作</p><p>事务 ID 本质上就是一个数字，服务器在内存中维护一个全局变量：</p><ul><li>每当需要为某个事务分配 ID，就会把全局变量的值赋值给事务 ID，然后变量自增 1</li><li>每当变量值为 256 的倍数时，就将该变量的值刷新到系统表空间的 Max Trx ID 属性中，该属性占 8 字节</li><li>系统再次启动后，会读取表空间的 Max Trx ID 属性到内存，加上 256 后赋值给全局变量，因为关机时的事务 ID 可能并不是 256 的倍数，会比 Max Trx ID 大，所以需要加上 256 保持事务 ID 是一个<strong>递增的数字</strong></li></ul><p><strong>聚簇索引</strong>的行记录除了完整的数据，还会自动添加 trx_id、roll_pointer 隐藏列，如果表中没有主键并且没有非空唯一索引，也会添加一个 row_id 的隐藏列作为聚簇索引</p><hr><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="四种级别"><a href="#四种级别" class="headerlink" title="四种级别"></a>四种级别</h4><p>事务的隔离级别：多个客户端操作时，各个客户端的事务之间应该是隔离的，<strong>不同的事务之间不该互相影响</strong>，而如果多个事务操作同一批数据时，则需要设置不同的隔离级别，否则就会产生问题。</p><p>隔离级别分类：</p><table><thead><tr><th>隔离级别</th><th>名称</th><th>会引发的问题</th><th>数据库默认隔离级别</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>读未提交</td><td>脏读、不可重复读、幻读</td><td></td></tr><tr><td>Read Committed</td><td>读已提交</td><td>不可重复读、幻读</td><td>Oracle &#x2F; SQL Server</td></tr><tr><td>Repeatable Read</td><td>可重复读</td><td>幻读</td><td>MySQL</td></tr><tr><td>Serializable</td><td>可串行化</td><td>无</td><td></td></tr></tbody></table><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差</p><ul><li><p>脏写 (Dirty Write)：当两个或多个事务选择同一行，最初的事务修改的值被后面事务修改的值覆盖，所有的隔离级别都可以避免脏写（又叫丢失更新），因为有行锁</p></li><li><p>脏读 (Dirty Reads)：在一个事务处理过程中读取了另一个<strong>未提交</strong>的事务中修改过的数据</p></li><li><p>不可重复读 (Non-Repeatable Reads)：在一个事务处理过程中读取了另一个事务中修改并<strong>已提交</strong>的数据</p><blockquote><p>可重复读的意思是不管读几次，结果都一样，可以重复的读，可以理解为快照读，要读的数据集不会发生变化</p></blockquote></li><li><p>幻读 (Phantom Reads)：在事务中按某个条件先后两次查询数据库，后一次查询查到了前一次查询没有查到的行，<strong>数据条目</strong>发生了变化。比如查询某数据不存在，准备插入此记录，但执行插入时发现此记录已存在，无法插入</p></li></ul><p>隔离级别操作语法：</p><ul><li><p>查询数据库隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@TX_ISOLATION;-- 会话</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;-- 系统</span><br></pre></td></tr></table></figure></li><li><p>修改数据库隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>InnoDB 存储引擎支持事务，所以加锁分析是基于该存储引擎</p><ul><li><p>Read Uncommitted 级别，任何操作都不会加锁</p></li><li><p>Read Committed 级别，增删改操作会加写锁（行锁），读操作不加锁</p><p>在 Server 层过滤条件时发现不满足的记录会调用 unlock_row 方法释放该记录的行锁，保证最后只有满足条件的记录加锁，但是扫表过程中每条记录的<strong>加锁操作不能省略</strong>。所以对数据量很大的表做批量修改时，如果无法使用相应的索引（全表扫描），在 Server 过滤数据时就会特别慢，出现虽然没有修改某些行的数据，但是还是被锁住了的现象（锁表），这种情况同样适用于  RR</p></li><li><p>Repeatable Read 级别，增删改操作会加写锁，读操作不加锁。因为读写锁不兼容，<strong>加了读锁后其他事务就无法修改数据</strong>，影响了并发性能，为了保证隔离性和并发性，MySQL 通过 MVCC 解决了读写冲突。RR 级别下的锁有很多种，锁机制章节详解</p></li><li><p>Serializable 级别，读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差</p><ul><li>串行化：让所有事务按顺序单独执行，写操作会加写锁，读操作会加读锁</li><li>可串行化：让所有操作相同数据的事务顺序执行，通过加锁实现</li></ul></li></ul><p>参考文章：<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><hr><h3 id="原子特性"><a href="#原子特性" class="headerlink" title="原子特性"></a>原子特性</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>原子性是指事务是一个不可分割的工作单位，事务的操作如果成功就必须要完全应用到数据库，失败则不能对数据库有任何影响。比如事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p><p>InnoDB 存储引擎提供了两种事务日志：redo log（重做日志）和 undo log（回滚日志）</p><ul><li>redo log 用于保证事务持久性</li><li>undo log 用于保证事务原子性和隔离性</li></ul><p>undo log 属于<strong>逻辑日志</strong>，根据每行操作进行记录，记录了 SQL 执行相关的信息，用来回滚行记录到某个版本</p><p>当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p><ul><li><p>对于每个 insert，回滚时会执行 delete</p></li><li><p>对于每个 delete，回滚时会执行 insert</p></li><li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p><hr><h4 id="DML-解析"><a href="#DML-解析" class="headerlink" title="DML 解析"></a>DML 解析</h4><h5 id="INSERT-1"><a href="#INSERT-1" class="headerlink" title="INSERT"></a>INSERT</h5><p>乐观插入：当前数据页的剩余空间充足，直接将数据进行插入</p><p>悲观插入：当前数据页的剩余空间不足，需要进行页分裂，申请一个新的页面来插入数据，会造成更多的 redo log，undo log 影响不大</p><p>当向某个表插入一条记录，实际上需要向聚簇索引和所有二级索引都插入一条记录，但是 undo log <strong>只针对聚簇索引记录</strong>，在回滚时会根据聚簇索引去所有的二级索引进行回滚操作</p><p>roll_pointer 是一个指针，<strong>指向记录对应的 undo log 日志</strong>，一条记录就是一个数据行，行格式中的 roll_pointer 就指向 undo log</p><hr><h5 id="DELETE-1"><a href="#DELETE-1" class="headerlink" title="DELETE"></a>DELETE</h5><p>插入到页面中的记录会根据 next_record 属性组成一个单向链表，这个链表称为正常链表，被删除的记录也会通过 next_record 组成一个垃圾链表，该链表中所占用的存储空间可以被重新利用，并不会直接清除数据</p><p>在页面 Page Header 中，PAGE_FREE 属性指向垃圾链表的头节点，删除的工作过程：</p><ul><li><p>将要删除的记录的 delete_flag 位置为 1，其他不做修改，这个过程叫 <strong>delete mark</strong></p></li><li><p>在事务提交前，delete_flag &#x3D; 1 的记录一直都会处于中间状态</p></li><li><p>事务提交后，有专门的线程将 delete_flag &#x3D; 1 的记录从正常链表移除并加入垃圾链表，这个过程叫 <strong>purge</strong></p><p>purge 线程在执行删除操作时会创建一个 ReadView，根据事务的可见性移除数据（隔离特性部分详解）</p></li></ul><p>当有新插入的记录时，首先判断 PAGE_FREE 指向的头节点是否足够容纳新纪录：</p><ul><li>如果可以容纳新纪录，就会直接重用已删除的记录的存储空间，然后让 PAGE_FREE 指向垃圾链表的下一个节点</li><li>如果不能容纳新纪录，就直接向页面申请新的空间存储，并不会遍历垃圾链表</li></ul><p>重用已删除的记录空间，可能会造成空间碎片，当数据页容纳不了一条记录时，会判断将碎片空间加起来是否可以容纳，判断为真就会重新组织页内的记录：</p><ul><li>开辟一个临时页面，将页内记录一次插入到临时页面，此时临时页面时没有碎片的</li><li>把临时页面的内容复制到本页，这样就解放出了内存碎片，但是会耗费很大的性能资源</li></ul><hr><h5 id="UPDATE-1"><a href="#UPDATE-1" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>执行 UPDATE 语句，对于更新主键和不更新主键有两种不同的处理方式</p><p>不更新主键的情况：</p><ul><li><p>就地更新（in-place update），如果更新后的列和更新前的列占用的存储空间一样大，就可以直接在原记录上修改</p></li><li><p>先删除旧纪录，再插入新纪录，这里的删除不是 delete mark，而是直接将记录加入垃圾链表，并且修改页面的相应的控制信息，执行删除的线程不是 purge，是执行更新的用户线程，插入新记录时可能造成页空间不足，从而导致页分裂</p></li></ul><p>更新主键的情况：</p><ul><li>将旧纪录进行 delete mark，在更新语句提交后由 purge 线程移入垃圾链表</li><li>根据更新的各列的值创建一条新纪录，插入到聚簇索引中</li></ul><p>在对一条记录修改前会<strong>将记录的隐藏列 trx_id 和 roll_pointer 的旧值记录到当前 undo log 对应的属性中</strong>，这样当前记录的 roll_pointer 指向当前 undo log 记录，当前 undo log 记录的 roll_pointer 指向旧的 undo log 记录，<strong>形成一个版本链</strong></p><p>UPDATE、DELETE 操作产生的 undo 日志会用于其他事务的 MVCC 操作，所以不能立即删除，INSERT 可以删除的原因是 MVCC 是对现有数据的快照</p><hr><h4 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h4><p>undo log 是采用段的方式来记录，Rollback Segement 称为回滚段，本质上就是一个类型是 Rollback Segement Header 的页面</p><p>每个回滚段中有 1024 个 undo slot，每个 slot 存放 undo 链表页面的头节点页号，每个链表对应一个叫 undo log segment 的段</p><ul><li>在以前老版本，只支持 1 个 Rollback Segement，只能记录 1024 个 undo log segment</li><li>MySQL5.5 开始支持 128 个 Rollback Segement，支持 128*1024 个 undo 操作</li></ul><p>工作流程：</p><ul><li><p>事务执行前需要到系统表空间第 5 号页面中分配一个回滚段（页），获取一个 Rollback Segement Header 页面的地址</p></li><li><p>回滚段页面有 1024 个 undo slot，首先去回滚段的两个 cached 链表获取缓存的 slot，缓存中没有就在回滚段页面中找一个可用的 undo slot 分配给当前事务</p></li><li><p>如果是缓存中获取的 slot，则该 slot 对应的 undo log segment 已经分配了，需要重新分配，然后从 undo log segment 中申请一个页面作为日志链表的头节点，并填入对应的 slot 中</p></li><li><p>每个事务 undo 日志在记录的时候<strong>占用两个 undo 页面的组成链表</strong>，分别为 insert undo 链表和 update undo 链表，链表的头节点页面为 first undo page 会包含一些管理信息，其他页面为 normal undo page</p><p>说明：事务执行过程的临时表也需要两个 undo 链表，不和普通表共用，这些链表并不是事务开始就分配，而是按需分配</p></li></ul><hr><h3 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>隔离性是指，事务内部的操作与其他事务是隔离的，多个并发事务之间要相互隔离，不能互相干扰</p><ul><li><p>严格的隔离性，对应了事务隔离级别中的 serializable，实际应用中对性能考虑很少使用可串行化</p></li><li><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是<strong>不同事务</strong>之间的相互影响</p></li></ul><p>隔离性让并发情形下的事务之间互不干扰：</p><ul><li>一个事务的写操作对另一个事务的写操作（写写）：锁机制保证隔离性</li><li>一个事务的写操作对另一个事务的读操作（读写）：MVCC 保证隔离性</li></ul><p>锁机制：事务在修改数据之前，需要先获得相应的锁，获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁（详解见锁机制）</p><hr><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，用来<strong>解决读写冲突的无锁并发控制</strong>，可以在发生读写请求冲突时不用加锁解决，这个读是指的快照读（也叫一致性读或一致性无锁读），而不是当前读：</p><ul><li>快照读：实现基于 MVCC，因为是多版本并发，所以快照读读到的数据不一定是当前最新的数据，有可能是历史版本的数据</li><li>当前读：又叫加锁读，读取数据库记录是当前<strong>最新的版本</strong>（产生幻读、不可重复读），可以对读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作，读写操作加共享锁或者排他锁和串行化事务的隔离级别都是当前读</li></ul><p>数据库并发场景：</p><ul><li><p>读-读：不存在任何问题，也不需要并发控制</p></li><li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p></li><li><p>写-写：有线程安全问题，可能会存在脏写（丢失更新）问题</p></li></ul><p>MVCC 的优点：</p><ul><li>在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了并发读写的性能</li><li>可以解决脏读，不可重复读等事务隔离问题（加锁也能解决），但不能解决更新丢失问题（写锁会解决）</li></ul><p>提高读写和写写的并发性能：</p><ul><li>MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突</li></ul><p>参考文章：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>实现原理主要是隐藏字段，undo日志，Read View 来实现的</p><p>InnoDB 存储引擎，数据库中的<strong>聚簇索引</strong>每行数据，除了自定义的字段，还有数据库隐式定义的字段：</p><ul><li>DB_TRX_ID：最近修改事务 ID，记录创建该数据或最后一次修改该数据的事务 ID</li><li>DB_ROLL_PTR：回滚指针，<strong>指向记录对应的 undo log 日志</strong>，undo log 中又指向上一个旧版本的 undo log</li><li>DB_ROW_ID：隐含的自增 ID（<strong>隐藏主键</strong>），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 作为聚簇索引</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png"></p><hr><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>undo log 是逻辑日志，记录的是每个事务对数据执行的操作，而不是记录的全部数据，要<strong>根据 undo log 逆推出以往事务的数据</strong></p><p>undo log 的作用：</p><ul><li>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复</li><li>用于 MVCC 快照读，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据</li></ul><p>undo log 主要分为两种：</p><ul><li><p>insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p>update undo log：事务在进行 update 或 delete 时产生的 undo log，在事务回滚时需要，在快照读时也需要。不能随意删除，只有在当前读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p></li></ul><p>每次对数据库记录进行改动，都会产生的新版本的 undo log，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前的最新的 undo log，链尾就是最早的旧 undo log</p><p>说明：因为 DELETE 删除记录，都是移动到垃圾链表中，不是真正的删除，所以才可以通过版本链访问原始数据</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC版本链.png" style="zoom: 80%;"><p>注意：undo 是逻辑日志，这里只是直观的展示出来</p><p>工作流程：</p><ul><li>有个事务插入 persion 表一条新记录，name 为 Jerry，age 为 24</li><li>事务 1 修改该行数据时，数据库会先对该行加排他锁，然后先记录 undo log，然后修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID（默认为 1 之后递增），回滚指针指向拷贝到 undo log 的副本记录，事务提交后，释放锁</li><li>以此类推</li></ul><hr><h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a>读视图</h5><p>Read View 是事务进行读数据操作时产生的读视图，该事务执行快照读的那一刻会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，用来做可见性判断，根据视图判断当前事务能够看到哪个版本的数据</p><p>注意：这里的快照并不是把所有的数据拷贝一份副本，而是由 undo log 记录的逻辑日志，根据库中的数据进行计算出历史数据</p><p>工作流程：将版本链的头节点的事务 ID（最新数据事务 ID，大概率不是当前线程）DB_TRX_ID 取出来，与系统当前活跃事务的 ID 对比进行可见性分析，不可见就通过 DB_ROLL_PTR 回滚指针去取出 undo log 中的下一个 DB_TRX_ID 比较，直到找到最近的满足可见性的 DB_TRX_ID，该事务 ID 所在的旧记录就是当前事务能看见的最新的记录</p><p>Read View 几个属性：</p><ul><li>m_ids：生成 Read View 时当前系统中活跃的事务 id 列表（未提交的事务集合，当前事务也在其中）</li><li>min_trx_id：生成 Read View 时当前系统中活跃的最小的事务 id，也就是 m_ids 中的最小值（已提交的事务集合）</li><li>max_trx_id：生成 Read View 时当前系统应该分配给下一个事务的 id 值，m_ids 中的最大值加 1（未开始事务）</li><li>creator_trx_id：生成该 Read View 的事务的事务 id，就是判断该 id 的事务能读到什么数据</li></ul><p>creator 创建一个 Read View，进行可见性算法分析：（解决了读未提交）</p><ul><li><p>db_trx_id &#x3D;&#x3D; creator_trx_id：表示这个数据就是当前事务自己生成的，自己生成的数据自己肯定能看见，所以此数据对 creator 是可见的</p></li><li><p>db_trx_id &lt;  min_trx_id：该版本对应的事务 ID 小于 Read view 中的最小活跃事务 ID，则这个事务在当前事务之前就已经被提交了，对 creator 可见（因为比已提交的最大事务 ID 小的并不一定已经提交，所以应该判断是否在活跃事务列表）</p></li><li><p>db_trx_id &gt;&#x3D; max_trx_id：该版本对应的事务 ID 大于 Read view 中当前系统的最大事务 ID，则说明该数据是在当前 Read view 创建之后才产生的，对 creator 不可见</p></li><li><p>min_trx_id&lt;&#x3D; db_trx_id &lt; max_trx_id：判断 db_trx_id 是否在活跃事务列表 m_ids 中</p><ul><li>在列表中，说明该版本对应的事务正在运行，数据不能显示（<strong>不能读到未提交的数据</strong>）</li><li>不在列表中，说明该版本对应的事务已经被提交，数据可以显示（<strong>可以读到已经提交的数据</strong>）</li></ul></li></ul><hr><h5 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h5><p>表 user 数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>nameage</span><br><span class="line">1张三   18</span><br></pre></td></tr></table></figure><p>Transaction 20：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;-- 开启事务</span><br><span class="line">UPDATE user SET name = &#x27;李四&#x27; WHERE id = 1;</span><br><span class="line">UPDATE user SET name = &#x27;王五&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure><p>Transaction 60：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;-- 开启事务</span><br><span class="line">-- 操作表的其他数据</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p><p>ID 为 0 的事务创建 Read View：</p><ul><li>m_ids：20、60</li><li>min_trx_id：20</li><li>max_trx_id：61</li><li>creator_trx_id：0</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p><p>只有红框部分才复合条件，所以只有张三对应的版本的数据可以被看到</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1t5411u7Fg">https://www.bilibili.com/video/BV1t5411u7Fg</a></p><hr><h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>只有在聚簇索引中才有 trx_id 和 roll_pointer 的隐藏列，对于二级索引判断可见性的方式：</p><ul><li>二级索引页面的 Page Header 中有一个 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，SELECT 语句访问某个二级索引时会判断 ReadView 的 min_trx_id 是否大于该属性，大于说明该页面的所有属性对 ReadView 可见</li><li>如果属性判断不可见，就需要利用二级索引获取主键值进行<strong>回表操作</strong>，得到聚簇索引后按照聚簇索引的可见性判断的方法操作</li></ul><hr><h4 id="RC-RR"><a href="#RC-RR" class="headerlink" title="RC RR"></a>RC RR</h4><p>Read View 用于支持 RC（Read Committed，读已提交）和 RR（Repeatable Read，可重复读）隔离级别的实现，所以 <strong>SELECT 在 RC 和 RR 隔离级别使用 MVCC 读取记录</strong></p><p>RR、RC 生成时机：</p><ul><li>RC 隔离级别下，每次读取数据前都会生成最新的 Read View（当前读）</li><li>RR 隔离级别下，在第一次数据读取时才会创建 Read View（快照读）</li></ul><p>RC、RR 级别下的 InnoDB 快照读区别</p><ul><li><p>RC 级别下，事务中每次快照读都会新生成一个 Read View，这就是在 RC 级别下的事务中可以看到别的事务提交的更新的原因</p></li><li><p>RR 级别下，某个事务的对某条记录的<strong>第一次快照读</strong>会创建一个 Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，使用的是同一个 Read View，所以一个事务的查询结果每次都是相同的</p><p>RR 级别下，通过 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 开启事务，会在执行该语句后立刻生成一个 Read View，不是在执行第一条 SELECT 语句时生成（所以说 <code>START TRANSACTION</code> 并不是事务的起点，执行第一条语句才算起点）</p></li></ul><p>解决幻读问题：</p><ul><li><p>快照读：通过 MVCC 来进行控制的，在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，但是<strong>并不能完全避免幻读</strong></p><p>场景：RR 级别，T1 事务开启，创建 Read View，此时 T2 去 INSERT 新的一行然后提交，然后 T1 去 UPDATE 该行会发现更新成功，并且把这条新记录的 trx_id 变为当前的事务 id，所以对当前事务就是可见的。因为 <strong>Read View 并不能阻止事务去更新数据，更新数据都是先读后写并且是当前读</strong>，读取到的是最新版本的数据</p></li><li><p>当前读：通过 next-key 锁（行锁 + 间隙锁）来解决问题</p></li></ul><hr><h3 id="持久特性"><a href="#持久特性" class="headerlink" title="持久特性"></a>持久特性</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p><p>Buffer Pool 的使用提高了读写数据的效率，但是如果 MySQL 宕机，此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证，所以引入了 redo log 日志：</p><ul><li>redo log <strong>记录数据页的物理修改</strong>，而不是某一行或某几行的修改，用来恢复提交后的数据页，只能<strong>恢复到最后一次提交</strong>的位置</li><li>redo log 采用的是 WAL（Write-ahead logging，<strong>预写式日志</strong>），所有修改要先写入日志，再更新到磁盘，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求</li><li>简单的 redo log 是纯粹的物理日志，复杂的 redo log 会存在物理日志和逻辑日志</li></ul><p>工作过程：MySQL 发生了宕机，InnoDB 会判断一个数据页在崩溃恢复时丢失了更新，就会将它读到内存，然后根据 redo log 内容更新内存，更新完成后，内存页变成脏页，然后进行刷脏</p><p>缓冲池的<strong>刷脏策略</strong>：</p><ul><li>redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把对应的更新持久化到磁盘中</li><li>Buffer Pool 内存不足，需要淘汰部分数据页（LRU 链表尾部），如果淘汰的是脏页，就要先将脏页写到磁盘（要避免大事务）</li><li>系统空闲时，后台线程会自动进行刷脏（Flush 链表部分已经详解）</li><li>MySQL 正常关闭时，会把内存的脏页都刷新到磁盘上</li></ul><hr><h4 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h4><h5 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h5><p>服务器启动时会向操作系统申请一片连续内存空间作为 redo log buffer（重做日志缓冲区），可以通过 <code>innodb_log_buffer_size</code> 系统变量指定 redo log buffer 的大小，默认是 16MB</p><p>log buffer 被划分为若干 redo log block（块，类似数据页的概念），每个默认大小 512 字节，每个 block 由 12 字节的 log block head、496 字节的 log block body、4 字节的 log block trailer 组成</p><ul><li>当数据修改时，先修改 Change Buffer 中的数据，然后在 redo log buffer 记录这次操作，写入 log buffer 的过程是<strong>顺序写入</strong>的（先写入前面的 block，写满后继续写下一个）</li><li>log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域</li></ul><p>MySQL 规定对底层页面的一次原子访问称为一个 Mini-Transaction（MTR），比如在 B+ 树上插入一条数据就算一个 MTR</p><ul><li><p>一个事务包含若干个 MTR，一个 MTR 对应一组若干条 redo log，一组 redo log 是不可分割的，在进行数据恢复时也把一组 redo log 当作一个不可分割的整体处理</p></li><li><p>不是每生成一条 redo 日志就将其插入到 log buffer 中，而是一个 MTR 结束后<strong>将一组 redo 日志写入</strong></p></li></ul><p>InnoDB 的 redo log 是<strong>固定大小</strong>的，redo 日志在磁盘中以文件组的形式存储，同一组中的每个文件大小一样格式一样</p><ul><li><code>innodb_log_group_home_dir</code> 代表磁盘存储 redo log 的文件目录，默认是当前数据目录</li><li><code>innodb_log_file_size</code> 代表文件大小，默认 48M，<code>innodb_log_files_in_group</code> 代表文件个数，默认 2 最大 100，所以日志的文件大小为 <code>innodb_log_file_size * innodb_log_files_in_group</code></li></ul><p>redo 日志文件也是由若干个 512 字节的 block 组成，日志文件的前 2048 个字节（前 4 个 block）用来存储一些管理信息，以后的用来存储 log buffer 中的 block 镜像</p><p>注意：block 并不代表一组 redo log，一组日志可能占用不到一个 block 或者几个 block，依赖于 MTR 的大小</p><hr><h5 id="日志刷盘"><a href="#日志刷盘" class="headerlink" title="日志刷盘"></a>日志刷盘</h5><p>redo log 需要在事务提交时将日志写入磁盘，但是比 Buffer Pool 修改的数据写入磁盘的速度快，原因：</p><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机；redo log 和 binlog 都是<strong>顺序写</strong>，磁盘的顺序 IO 比随机 IO 速度要快</li><li>刷脏是以数据页（Page）为单位的，一个页上的一个小修改都要整页写入；redo log 中只包含真正需要写入的部分，好几页的数据修改可能只记录在一个 redo log 页中，减少无效 IO</li><li><strong>组提交机制</strong>，可以大幅度降低磁盘的 IO 消耗</li></ul><p>InnoDB 引擎会在适当的时候，把内存中 redo log buffer 持久化（fsync）到磁盘，具体的<strong>刷盘策略</strong>：</p><ul><li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul><li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li><li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li><li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li></ul></li><li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li><li>服务器关闭时</li><li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量</li></ul><p>服务器启动后 redo 磁盘空间不变，所以 redo 磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，所以要确保头部 log 对应的修改已经持久化到磁盘</p><hr><h5 id="日志序号"><a href="#日志序号" class="headerlink" title="日志序号"></a>日志序号</h5><p>lsn (log sequence number) 代表已经写入的 redo 日志量、flushed_to_disk_lsn 指刷新到磁盘中的 redo 日志量，两者都是<strong>全局变量</strong>，如果两者的值相同，说明 log buffer 中所有的 redo 日志都已经持久化到磁盘</p><p>工作过程：写入 log buffer 数据时，buf_free 会进行偏移，偏移量就会加到 lsn 上</p><p>MTR 的执行过程中修改过的页对应的控制块会加到 Buffer Pool 的 flush 链表中，链表中脏页是按照第一次修改的时间进行排序的（头插），控制块中有两个指针用来记录脏页被修改的时间：</p><ul><li>oldest_modification：第一次修改 Buffer Pool 中某个缓冲页时，将修改该页的 MTR <strong>开始时</strong>对应的 lsn 值写入这个属性</li><li>newest_modification：每次修改页面，都将 MTR 结束时全局的 lsn 值写入这个属性，所以该值是该页面最后一次修改后的 lsn 值</li></ul><p>全局变量 checkpoint_lsn 表示<strong>当前系统可以被覆盖的 redo 日志总量</strong>，当 redo 日志对应的脏页已经被刷新到磁盘后，该文件空间就可以被覆盖重用，此时执行一次 checkpoint 来更新 checkpoint_lsn 的值存入管理信息（刷脏和执行一次 checkpoint 并不是同一个线程），该值的增量就代表磁盘文件中当前位置向后可以被覆盖的文件的量，所以该值是一直增大的</p><p><strong>checkpoint</strong>：从 flush 链表尾部中找出还未刷脏的页面，该页面是当前系统中最早被修改的脏页，该页面之前产生的脏页都已经刷脏，然后将该页 oldest_modification 值赋值给 checkpoint_lsn，因为 lsn 小于该值时产生的 redo 日志都可以被覆盖了</p><p>但是在系统忙碌时，后台线程的刷脏操作不能将脏页快速刷出，导致系统无法及时执行 checkpoint ，这时需要用户线程从 flush 链表中把最早修改的脏页刷新到磁盘中，然后执行 checkpoint</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">write pos ------- checkpoint_lsn <span class="comment">// 两值之间的部分表示可以写入的日志量，当 pos 追赶上 lsn 时必须执行 checkpoint</span></span><br></pre></td></tr></table></figure><p>使用命令可以查看当前 InnoDB 存储引擎各种 lsn 的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure><hr><h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p>恢复的起点：在从 redo 日志文件组的管理信息中获取最近发生 checkpoint 的信息，<strong>从 checkpoint_lsn 对应的日志文件开始恢复</strong></p><p>恢复的终点：扫描日志文件的 block，block 的头部记录着当前 block 使用了多少字节，填满的 block 总是 512 字节， 如果某个 block 不是 512 字节，说明该 block 就是需要恢复的最后一个 block</p><p>恢复的过程：按照 redo log 依次执行恢复数据，优化方式</p><ul><li>使用哈希表：根据 redo log 的 space id 和 page number 属性计算出哈希值，将对同一页面的修改放入同一个槽里，可以一次性完成对某页的恢复，<strong>避免了随机 IO</strong></li><li>跳过已经刷新到磁盘中的页面：数据页的 File Header 中的 FILE_PAGE_LSN 属性（类似 newest_modification）表示最近一次修改页面时的 lsn 值，数据页被刷新到磁盘中，那么该页 lsn 属性肯定大于 checkpoint_lsn</li></ul><p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p><hr><h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="日志对比"><a href="#日志对比" class="headerlink" title="日志对比"></a>日志对比</h5><p>MySQL 中还存在 binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>，二者的区别是：</p><ul><li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li><li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li><li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li><li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li></ul><p>binlog 为什么不支持崩溃恢复？</p><ul><li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li><li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的</li></ul><hr><h5 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h5><p>更新一条记录的过程：写之前一定先读</p><ul><li><p>在 B+ 树中定位到该记录，如果该记录所在的页面不在 Buffer Pool 里，先将其加载进内存</p></li><li><p>首先更新该记录对应的聚簇索引，更新聚簇索引记录时：</p><ul><li><p>更新记录前向 undo 页面写 undo 日志，由于这是更改页面，所以需要记录一下相应的 redo 日志</p><p>注意：修改 undo 页面也是在<strong>修改页面</strong>，事务只要修改页面就需要先记录相应的 redo 日志</p></li><li><p>然后<strong>记录对应的 redo 日志</strong>（等待 MTR 提交后写入 redo log buffer），<strong>最后进行真正的更新记录</strong></p></li></ul></li><li><p>更新其他的二级索引记录，不会再记录 undo log，只记录 redo log 到 buffer 中</p></li><li><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就会开始记录该语句对应的 binlog 日志，此时记录的 binlog 并没有刷新到硬盘上，还在内存中，在事务提交时才会统一将该事务运行过程中的所有 binlog 日志刷新到硬盘</p></li></ul><p>假设表中有字段 id 和 a，存在一条 <code>id = 1, a = 2</code> 的记录，此时执行更新语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>InnoDB 会真正的去执行把值修改成 (1,2) 这个操作，先加行锁，在去更新，并不会提前判断相同就不修改了</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA">https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA</a></p><hr><h5 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h5><p>当客户端执行 COMMIT 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-update的执行流程.png" style="zoom: 33%;"><p>流程说明：执行引擎将这行新数据读入到内存中（Buffer Pool）后，先将此次更新操作记录到 redo log buffer 里，然后更新记录。最后将 redo log 刷盘后事务处于 prepare 状态，执行器会生成这个操作的 binlog，并<strong>把 binlog 写入磁盘</strong>，完成提交</p><p>两阶段：</p><ul><li>Prepare 阶段：存储引擎将该事务的 <strong>redo 日志刷盘</strong>，并且将本事务的状态设置为 PREPARE，代表执行完成随时可以提交事务</li><li>Commit 阶段：先将事务执行过程中产生的 binlog 刷新到硬盘，再执行存储引擎的提交工作，引擎把 redo log 改成提交状态</li></ul><p>存储引擎层的 redo log 和 server 层的 binlog 可以认为是一个分布式事务， 都可以用于表示事务的提交状态，而<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>，也有利于主从复制，更好的保持主从数据的一致性</p><hr><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>系统崩溃前没有提交的事务的 redo log 可能已经刷盘（定时线程或者 checkpoint），怎么处理崩溃恢复？</p><p>工作流程：获取 undo 链表首节点页面的 undo segement header 中的 TRX_UNDO_STATE 属性，表示当前链表的事务属性，<strong>事务状态是活跃（未提交）的就全部回滚</strong>，如果是 PREPARE 状态，就需要根据 binlog 的状态进行判断：</p><ul><li>如果在时刻 A 发生了崩溃（crash），由于此时 binlog 还没完成，所以需要进行回滚</li><li>如果在时刻 B 发生了崩溃，redo log 和 binlog 有一个共<strong>同的数据字段叫 XID</strong>，崩溃恢复的时候，会按顺序扫描 redo log：<ul><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，说明 binlog 也已经记录完整，直接从 redo log 恢复数据</li><li>如果 redo log 里面的事务只有 prepare，就根据 XID 去 binlog 中判断对应的事务是否存在并完整，如果完整可以恢复数据</li></ul></li></ul><p>判断一个事务的 binlog 是否完整的方法：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT</li><li>row 格式的 binlog，最后会有一个 XID event</li><li>MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数用来验证 binlog 内容的正确性（可能日志中间出错）</li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/73161">https://time.geekbang.org/column/article/73161</a></p><hr><h4 id="刷脏优化"><a href="#刷脏优化" class="headerlink" title="刷脏优化"></a>刷脏优化</h4><p>系统在进行刷脏时会占用一部分系统资源，会影响系统的性能，<strong>产生系统抖动</strong></p><ul><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li></ul><p>InnoDB 刷脏页的控制策略：</p><ul><li><code>innodb_io_capacity</code> 参数代表磁盘的读写能力，建议设置成磁盘的 IOPS（每秒的 IO 次数）</li><li>刷脏速度参考两个因素：脏页比例和 redo log 写盘速度<ul><li>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%，InnoDB 会根据当前的脏页比例，算出一个范围在 0 到 100 之间的数字</li><li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，InnoDB 根据差值算出一个范围在 0 到 100 之间的数字</li><li>两者较大的值记为 R，执行引擎按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度</li></ul></li><li><code>innodb_flush_neighbors</code> 参数置为 1 代表控制刷脏时检查相邻的数据页，如果也是脏页就一起刷脏，并检查邻居的邻居，这个行为会一直蔓延直到不是脏页，在 MySQL 8.0 中该值的默认值是 0，不建议开启此功能</li></ul><hr><h3 id="一致特性"><a href="#一致特性" class="headerlink" title="一致特性"></a>一致特性</h3><p>一致性是指事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）</p><p>实现一致性的措施：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul><hr><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>锁机制：数据库为了保证数据的一致性，在共享的资源被并发访问时变得安全有序所设计的一种规则</p><p>利用 MVCC 性质进行读取的操作叫<strong>一致性读</strong>，读取数据前加锁的操作叫<strong>锁定读</strong></p><p>锁的分类：</p><ul><li>按操作分类：<ul><li>共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据</li><li>排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入</li></ul></li><li>按粒度分类：<ul><li>表级锁：会锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM</li><li>行级锁：会锁定当前操作行，开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB</li><li>页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，会出现死锁，并发性能一般</li></ul></li><li>按使用方式分类：<ul><li>悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁</li><li>乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据</li></ul></li></ul><ul><li><p>不同存储引擎支持的锁</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页级锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td><strong>支持</strong></td><td><strong>支持</strong></td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table></li></ul><p>从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统</p><hr><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>对一条记录加锁的本质就是<strong>在内存中</strong>创建一个锁结构与之关联，结构包括</p><ul><li>事务信息：锁对应的事务信息，一个锁属于一个事务</li><li>索引信息：对于行级锁，需要记录加锁的记录属于哪个索引</li><li>表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特</li><li>type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分<ul><li>lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类</li><li>lock_type：代表表级锁还是行级锁</li><li>rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting &#x3D; true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程</li></ul></li></ul><p>一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：</p><ul><li>在同一个事务中的加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>加锁的状态是一样的</li></ul><hr><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p><p>MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，<strong>当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁</strong>，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全</p><p>说明：DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务</p><p>MDL 锁的特性：</p><ul><li><p>MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）</p></li><li><p>MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁</p></li><li><p>MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁</p></li></ul><p>FLUSH TABLES WITH READ LOCK 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：</p><ol><li>上全局读锁（lock_global_read_lock）</li><li>清理表缓存（close_cached_tables）</li><li>上全局 COMMIT 锁（make_global_read_lock_block_commit）</li></ol><p>该命令主要用于备份工具做<strong>一致性备份</strong>，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大</p><hr><h3 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型</p><p>MyISAM 引擎在执行查询语句之前，会<strong>自动</strong>给涉及到的所有表加读锁，在执行增删改之前，会<strong>自动</strong>给涉及的表加写锁，这个过程并不需要用户干预，所以用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁</p><ul><li><p>加锁命令：（对 InnoDB 存储引擎也适用）</p><p>读锁：所有连接只能读取数据，不能修改</p><p>写锁：其他连接不能查询和修改数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读锁</span><br><span class="line">LOCK TABLE table_name READ;</span><br><span class="line"></span><br><span class="line">-- 写锁</span><br><span class="line">LOCK TABLE table_name WRITE;</span><br></pre></td></tr></table></figure></li><li><p>解锁命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将当前会话所有的表进行解锁</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li></ul><p>锁的兼容性：</p><ul><li>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</li><li>对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作</li></ul><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁的兼容性.png)</p><p>锁调度：<strong>MyISAM 的读写锁调度是写优先</strong>，因为写锁后其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞，所以 MyISAM 不适合做写为主的表的存储引擎</p><hr><h4 id="锁操作"><a href="#锁操作" class="headerlink" title="锁操作"></a>锁操作</h4><h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>数据准备：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_book` (</span><br><span class="line">  `id` INT(11) AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  `publish_time` DATE DEFAULT NULL,</span><br><span class="line">  `status` CHAR(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MYISAM DEFAULT CHARSET=utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;java编程思想&#x27;,&#x27;2088-08-01&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;mysql编程思想&#x27;,&#x27;2088-08-08&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>C1、C2 加读锁，同时查询可以正常查询出数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- C1、C2</span><br><span class="line">SELECT * FROM tb_book;-- C1、C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁1.png)</p></li><li><p>C1 加读锁，C1、C2 查询未锁定的表，C1 报错，C2 正常查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- C1</span><br><span class="line">SELECT * FROM tb_user;-- C1、C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁2.png)</p><p>C1、C2 执行插入操作，C1 报错，C2 等待获取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Spring高级&#x27;,&#x27;2088-01-01&#x27;,&#x27;1&#x27;);-- C1、C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁3.png)</p><p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 INSERT 语句立即执行</p></li></ul><hr><h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>C1 加写锁，C1、C2查询表，C1 正常查询，C2 需要等待</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;-- C1</span><br><span class="line">SELECT * FROM tb_book;-- C1、C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁1.png)</p><p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 SELECT 语句立即执行</p></li><li><p>C1、C2 同时加写锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁2.png)</p></li><li><p>C1 加写锁，C1、C2查询未锁定的表，C1 报错，C2 正常查询</p></li></ul><hr><h4 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h4><ul><li><p>查看锁竞争：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B1.png"></p><p>In_user：表当前被查询使用的次数，如果该数为零，则表是打开的，但是当前没有被使用</p><p>Name_locked：表名称是否被锁定，名称锁定用于取消表或对表进行重命名等操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- 执行命令</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B2.png"></p></li><li><p>查看锁状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Table_locks%&#x27;;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁状态.png)</p><p>Table_locks_immediate：指的是能立即获得表级锁的次数，每立即获取锁，值加 1</p><p>Table_locks_waited：指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加 1，此值高说明存在着较为严重的表级锁争用情况</p></li></ul><hr><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁，<strong>InnoDB 同时支持表锁和行锁</strong></p><p>行级锁，也称为记录锁（Record Lock），InnoDB  实现了以下两种类型的行锁：</p><ul><li>共享锁 (S)：又称为读锁，简称 S 锁，多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</li><li>排他锁 (X)：又称为写锁，简称 X 锁，不能与其他锁并存，获取排他锁的事务是可以对数据读取和修改</li></ul><p>RR 隔离界别下，对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会<strong>自动给涉及数据集加排他锁</strong>（行锁），在 commit 时自动释放；对于普通 SELECT 语句，不会加任何锁（只是针对 InnoDB 层来说的，因为在 Server 层会<strong>加 MDL 读锁</strong>），通过 MVCC 防止并发冲突</p><p>在事务中加的锁，并不是不需要了就释放，而是在事务中止或提交时自动释放，这个就是<strong>两阶段锁协议</strong>。所以一般将更新共享资源（并发高）的 SQL 放到事务的最后执行，可以让其他线程尽量的减少等待时间</p><p>锁的兼容性：</p><ul><li>共享锁和共享锁     兼容</li><li>共享锁和排他锁     冲突</li><li>排他锁和排他锁     冲突</li><li>排他锁和共享锁     冲突</li></ul><p>显式给数据集加共享锁或排他锁：<strong>加锁读就是当前读，读取的是最新数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE-- 共享锁</span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE-- 排他锁</span><br></pre></td></tr></table></figure><p>注意：<strong>锁默认会锁聚簇索引（锁就是加在索引上）</strong>，但是当使用覆盖索引时，加共享锁只锁二级索引，不锁聚簇索引</p><hr><h5 id="锁操作-1"><a href="#锁操作-1" class="headerlink" title="锁操作"></a>锁操作</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>环境准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_innodb_lock(</span><br><span class="line">id INT(11),</span><br><span class="line">name VARCHAR(16),</span><br><span class="line">sex VARCHAR(1)</span><br><span class="line">)ENGINE = INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_innodb_lock VALUES(1,&#x27;100&#x27;,&#x27;1&#x27;);</span><br><span class="line">-- ..........</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_test_innodb_lock_id ON test_innodb_lock(id);</span><br><span class="line">CREATE INDEX idx_test_innodb_lock_name ON test_innodb_lock(name);</span><br></pre></td></tr></table></figure></li><li><p>关闭自动提交功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure><p>正常查询数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>查询 id 为 3 的数据，正常查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;-- C1、C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作1.png)</p></li><li><p>C1 更新 id 为 3 的数据，但不提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;300&#x27; WHERE id=3;-- C1</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作2.png)</p><p>C2 查询不到 C1 修改的数据，因为隔离界别为 REPEATABLE READ，C1 提交事务，C2 查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;-- C1</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作3.png)</p><p>提交后仍然查询不到 C1 修改的数据，因为隔离级别可以防止脏读、不可重复读，所以 C2 需要提交才可以查询到其他事务对数据的修改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;-- C2</span><br><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作4.png)</p></li><li><p>C1 更新 id 为 3 的数据，但不提交，C2 也更新 id 为 3 的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;3&#x27; WHERE id=3;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作5.png)</p><p>当 C1 提交，C2 直接解除阻塞，直接更新</p></li><li><p>操作不同行的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;10&#x27; WHERE id=1;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作6.png)</p><p>由于 C1、C2 操作的不同行，获取不同的行锁，所以都可以正常获取行锁</p></li></ul><hr><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>InnoDB 会对间隙（GAP）进行加锁，就是间隙锁 （RR 隔离级别下才有该锁）。间隙锁之间不存在冲突关系，<strong>多个事务可以同时对一个间隙加锁</strong>，但是间隙锁会阻止往这个间隙中插入一个记录的操作</p><p>InnoDB 加锁的基本单位是 next-key lock，该锁是行锁和 gap lock 的组合（X or S 锁），但是加锁过程是分为间隙锁和行锁两段执行</p><ul><li>可以<strong>保护当前记录和前面的间隙</strong>，遵循左开右闭原则，单纯的间隙锁是左开右开</li><li>假设有 10、11、13，那么可能的间隙锁包括：(负无穷,10]、(10,11]、(11,13]、(13,正无穷)</li></ul><p>几种索引的加锁情况：</p><ul><li>唯一索引加锁在值存在时是行锁，next-key lock 会退化为行锁，值不存在会变成间隙锁</li><li>普通索引加锁会继续向右遍历到不满足条件的值为止，next-key lock 退化为间隙锁</li><li>范围查询无论是否是唯一索引，都需要访问到不满足条件的第一个值为止</li><li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么会加间隙锁</li></ul><p>间隙锁优点：RR 级别下间隙锁可以<strong>解决事务的一部分的幻读问题</strong>，通过对间隙加锁，可以防止读取过程中数据条目发生变化。一部分的意思是不会对全部间隙加锁，只能加锁一部分的间隙</p><p>间隙锁危害：</p><ul><li>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，造成在锁定的时候无法插入锁定键值范围内的任何数据，在某些场景下这可能会对性能造成很大的危害，影响并发度</li><li>事务 A B 同时锁住一个间隙后，A 往当前间隙插入数据时会被 B 的间隙锁阻塞，B 也执行插入间隙数据的操作时就会<strong>产生死锁</strong></li></ul><p>现场演示：</p><ul><li><p>关闭自动提交功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>查询数据表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁1.png)</p></li><li><p>C1 根据 id 范围更新数据，C2 插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;8888&#x27; WHERE id &lt; 4;-- C1</span><br><span class="line">INSERT INTO test_innodb_lock VALUES(2,&#x27;200&#x27;,&#x27;2&#x27;);-- C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁2.png)</p><p>出现间隙锁，C2 被阻塞，等待 C1 提交事务后才能更新</p></li></ul><hr><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>InnoDB 为了支持多粒度的加锁，允许行锁和表锁同时存在，支持在不同粒度上的加锁操作，InnoDB 增加了意向锁（Intention Lock）</p><p>意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁，意向锁分为两种：</p><ul><li>意向共享锁（IS）：事务有意向对表加共享锁</li><li>意向排他锁（IX）：事务有意向对表加排他锁</li></ul><p><strong>IX，IS 是表级锁</strong>，不会和行级的 X，S 锁发生冲突，意向锁是在加表级锁之前添加，为了在加表级锁时可以快速判断表中是否有记录被上锁，比如向一个表添加表级 X 锁的时：</p><ul><li>没有意向锁，则需要遍历整个表判断是否有锁定的记录</li><li>有了意向锁，首先判断是否存在意向锁，然后判断该意向锁与即将添加的表级锁是否兼容即可，因为意向锁的存在代表有表级锁的存在或者即将有表级锁的存在</li></ul><p>兼容性如下所示：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%84%8F%E5%90%91%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.png"></p><p><strong>插入意向锁</strong> Insert Intention Lock 是在插入一行记录操作之前设置的一种间隙锁，是行级锁</p><p>插入意向锁释放了一种插入信号，即多个事务在相同的索引间隙插入时如果不是插入相同的间隙位置就不需要互相等待。假设某列有索引，只要两个事务插入位置不同，如事务 A 插入 3，事务 B 插入 4，那么就可以同时插入</p><hr><h5 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h5><p>系统会自动给 AUTO_INCREMENT 修饰的列进行递增赋值，实现方式：</p><ul><li>AUTO_INC 锁：表级锁，执行插入语句时会自动添加，在该语句执行完成后释放，并不是事务结束</li><li>轻量级锁：为插入语句生成 AUTO_INCREMENT 修饰的列时获取该锁，生成以后释放掉，不需要等到插入语句执行完后释放</li></ul><p>系统变量 <code>innodb_autoinc_lock_mode</code> 控制采取哪种方式：</p><ul><li>0：全部采用 AUTO_INC 锁</li><li>1：全部采用轻量级锁</li><li>2：混合使用，在插入记录的数量确定时采用轻量级锁，不确定时采用 AUTO_INC 锁</li></ul><hr><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>一般情况下 INSERT 语句是不需要在内存中生成锁结构的，会进行隐式的加锁，保护的是插入后的安全</p><p>注意：如果插入的间隙被其他事务加了间隙锁，此次插入会被阻塞，并在该间隙插入一个插入意向锁</p><ul><li>聚簇索引：索引记录有 trx_id 隐藏列，表示最后改动该记录的事务 id，插入数据后事务 id 就是当前事务。其他事务想获取该记录的锁时会判断当前记录的事务 id 是否是活跃的，如果不是就可以正常加锁；如果是就创建一个 X 的锁结构，该锁的 is_waiting 是 false，为自己的事务创建一个锁结构，is_waiting 是 true（类似 Java 中的锁升级）</li><li>二级索引：获取数据页 Page Header 中的 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，如果小于当前活跃的最小事务 id，就证明插入该数据的事务已经提交，否则就需要获取到主键值进行回表操作</li></ul><p>隐式锁起到了延迟生成锁的效果，如果其他事务与隐式锁没有冲突，就可以避免锁结构的生成，节省了内存资源</p><p>INSERT 在两种情况下会生成锁结构：</p><ul><li><p>重复键：在插入主键或唯一二级索引时遇到重复的键值会报错，在报错前需要对对应的聚簇索引进行加锁</p><ul><li>隔离级别 &lt;&#x3D; Read Uncommitted，加 S 型 Record Lock</li><li>隔离级别 &gt;&#x3D; Repeatable Read，加 S 型 next_key 锁</li></ul></li><li><p>外键检查：如果待插入的记录在父表中可以找到，会对父表的记录加 S 型 Record Lock。如果待插入的记录在父表中找不到</p><ul><li>隔离级别 &lt;&#x3D; Read Committed，不加锁</li><li>隔离级别 &gt;&#x3D; Repeatable Read，加间隙锁</li></ul></li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="优化锁"><a href="#优化锁" class="headerlink" title="优化锁"></a>优化锁</h5><p>InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM</p><p>但是使用不当可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（需要业务层面满足需求）</li></ul><hr><h5 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h5><p>索引失效造成<strong>行锁升级为表锁</strong>，不通过索引检索数据，全局扫描的过程中 InnoDB 会将对表中的所有记录加锁，实际效果和<strong>表锁</strong>一样，实际开发过程应避免出现索引失效的状况</p><ul><li><p>查看当前表的索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test_innodb_lock;</span><br></pre></td></tr></table></figure></li><li><p>关闭自动提交功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>执行更新语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE name=10;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁升级.png)</p><p>索引失效：执行更新时 name 字段为 varchar 类型，造成索引失效，最终行锁变为表锁</p></li></ul><hr><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁</p><p>死锁情况：线程 A 修改了 id &#x3D; 1 的数据，请求修改 id &#x3D; 2 的数据，线程 B 修改了 id &#x3D; 2 的数据，请求修改 id &#x3D; 1 的数据，产生死锁</p><p>解决策略：</p><ul><li><p>直接进入等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认 50 秒，但是时间的设置不好控制，超时可能不是因为死锁，而是因为事务处理比较慢，所以一般不采取该方式</p></li><li><p>主动死锁检测，发现死锁后<strong>主动回滚死锁链条中较小的一个事务</strong>，让其他事务得以继续执行，将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启该功能（事务较小的意思就是事务执行过程中插入、删除、更新的记录条数）</p><p>死锁检测并不是每个语句都要检测，只有在加锁访问的行上已经有锁时，当前事务被阻塞了才会检测，也是从当前事务开始进行检测</p></li></ul><p>通过执行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看最近发生的一次死循环，全局系统变量 <code>innodb_print_all_deadlocks</code> 设置为 on，就可以将每个死锁信息都记录在 MySQL 错误日志中</p><p>死锁一般是行级锁，当表锁发生死锁时，会在事务中访问其他表时<strong>直接报错</strong>，破坏了持有并等待的死锁条件</p><hr><h4 id="锁状态-1"><a href="#锁状态-1" class="headerlink" title="锁状态"></a>锁状态</h4><p>查看锁信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB 锁争用.png" style="zoom: 80%;"><p>参数说明：</p><ul><li><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量</p></li><li><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</p></li><li><p>Innodb_row_lock_time_avg：每次等待所花平均时长</p></li><li><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p></li><li><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</p></li></ul><p>当等待的次数很高，而且每次等待的时长也不短的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果制定优化计划</p><p>查看锁状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_locks;#锁的概况</span><br><span class="line">SHOW ENGINE INNODB STATUS\G; #InnoDB整体状态，其中包括锁的情况</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E6%9F%A5%E7%9C%8B%E9%94%81%E7%8A%B6%E6%80%81.png"></p><p>lock_id 是锁 id；lock_trx_id 为事务 id；lock_mode 为 X 代表排它锁（写锁）；lock_type 为 RECORD 代表锁为行锁（记录锁）</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>悲观锁：在整个数据处理过程中，将数据处于锁定状态，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据，修改删除数据时也加锁，其它事务同样无法读取这些数据</p><p>悲观锁和乐观锁使用前提：</p><ul><li>对于读的操作远多于写的操作的时候，一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量，最后需要释放锁，锁是需要一些开销的，这时候可以选择乐观锁</li><li>如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险，这时候可以选择悲观锁</li></ul><p>乐观锁的实现方式：就是 CAS，比较并交换</p><ul><li><p>版本号</p><ol><li><p>给数据表中添加一个 version 列，每次更新后都将这个列的值加 1</p></li><li><p>读取数据时，将版本号读取出来，在执行更新的时候，比较版本号</p></li><li><p>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</p></li><li><p>用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建city表</span><br><span class="line">CREATE TABLE city(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id</span><br><span class="line">NAME VARCHAR(20),                   -- 城市名称</span><br><span class="line">VERSION INT                         -- 版本号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO city VALUES (NULL,&#x27;北京&#x27;,1),(NULL,&#x27;上海&#x27;,1),(NULL,&#x27;广州&#x27;,1),(NULL,&#x27;深圳&#x27;,1);</span><br><span class="line"></span><br><span class="line">-- 修改北京为北京市</span><br><span class="line">-- 1.查询北京的version</span><br><span class="line">SELECT VERSION FROM city WHERE NAME=&#x27;北京&#x27;;</span><br><span class="line">-- 2.修改北京为北京市，版本号+1。并对比版本号</span><br><span class="line">UPDATE city SET NAME=&#x27;北京市&#x27;,VERSION=VERSION+1 WHERE NAME=&#x27;北京&#x27; AND VERSION=1;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>时间戳</p><ul><li>和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是 <strong>timestamp</strong></li><li>每次更新后都将最新时间插入到此列</li><li>读取数据时，将时间读取出来，在执行更新的时候，比较时间</li><li>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</li></ul></li></ul><p>乐观锁的异常情况：如果 version 被其他事务抢先更新，则在当前事务中更新失败，trx_id 没有变成当前事务的 ID，当前事务再次查询还是旧值，就会出现<strong>值没变但是更新不了</strong>的现象（anomaly）</p><p>解决方案：每次 CAS 更新不管成功失败，就结束当前事务；如果失败则重新起一个事务进行查询更新</p><hr><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步</p><p>MySQL 支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制</p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li><p>主库出现问题，可以快速切换到从库提供服务</p></li><li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库的服务（备份时会加全局读锁）</p></li></ul><hr><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h4><p>MySQL 的主从之间维持了一个<strong>长连接</strong>。主库内部有一个线程，专门用于服务从库的长连接，连接过程：</p><ul><li>从库执行 change master 命令，设置主库的 IP、端口、用户名、密码以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量</li><li>从库执行 start slave 命令，这时从库会启动两个线程，就是图中的 io_thread 和 sql_thread，其中 io_thread 负责与主库建立连接</li><li>主库校验完用户名、密码后，开始按照从传过来的位置，从本地读取 binlog 发给从库，开始主从复制</li></ul><p>主从复制原理图：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%9B%BE.jpg"></p><p>主从复制主要依赖的是 binlog，MySQL 默认是异步复制，需要三个线程：</p><ul><li>binlog thread：在主库事务提交时，把数据变更记录在日志文件 binlog 中，并通知 slave 有数据更新</li><li>I&#x2F;O thread：负责从主服务器上<strong>拉取二进制日志</strong>，并将 binlog 日志内容依次写到 relay log 中转日志的最末端，并将新的 binlog 文件名和 offset 记录到 master-info 文件中，以便下一次读取日志时从指定 binlog 日志文件及位置开始读取新的 binlog 日志内容</li><li>SQL thread：监测本地 relay log 中新增了日志内容，读取中继日志并重做其中的 SQL 语句，从库在 relay-log.info 中记录当前应用中继日志的文件名和位点以便下一次执行</li></ul><p>同步与异步：</p><ul><li>异步复制有数据丢失风险，例如数据还未同步到从库，主库就给客户端响应，然后主库挂了，此时从库晋升为主库的话数据是缺失的</li><li>同步复制，主库需要将 binlog 复制到所有从库，等所有从库响应了之后主库才进行其他逻辑，这样的话性能很差，一般不会选择</li><li>MySQL 5.7 之后出现了半同步复制，有参数可以选择成功同步几个从库就返回响应</li></ul><hr><h4 id="主主结构"><a href="#主主结构" class="headerlink" title="主主结构"></a>主主结构</h4><p>主主结构就是两个数据库之间总是互为主从关系，这样在切换的时候就不用再修改主从关系</p><p>循环复制：在库 A 上更新了一条语句，然后把生成的 binlog 发给库 B，库 B 执行完这条更新语句后也会生成 binlog，会再发给 A</p><p>解决方法：</p><ul><li>两个库的 server id 必须不同，如果相同则它们之间不能设定为主主关系</li><li>一个库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog</li><li>每个库在收到从主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志</li></ul><hr><h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><h4 id="延迟原因"><a href="#延迟原因" class="headerlink" title="延迟原因"></a>延迟原因</h4><p>正常情况主库执行更新生成的所有 binlog，都可以传到从库并被正确地执行，从库就能达到跟主库一致的状态，这就是最终一致性</p><p>主从延迟是主从之间是存在一定时间的数据不一致，就是同一个事务在从库执行完成的时间和主库执行完成的时间的差值，即 T2-T1</p><ul><li>主库 A 执行完成一个事务，写入 binlog，该时刻记为 T1</li><li>日志传给从库 B，从库 B 执行完这个事务，该时刻记为 T2</li></ul><p>通过在从库执行 <code>show slave status</code> 命令，返回结果会显示 seconds_behind_master 表示当前从库延迟了多少秒</p><ul><li>每一个事务的 binlog 都有一个时间字段，用于记录主库上写入的时间</li><li>从库取出当前正在执行的事务的时间字段，跟系统的时间进行相减，得到的就是 seconds_behind_master</li></ul><p>主从延迟的原因：</p><ul><li>从库的机器性能比主库的差，导致从库的复制能力弱</li><li>从库的查询压力大，建立一主多从的结构</li><li>大事务的执行，主库必须要等到事务完成之后才会写入 binlog，导致从节点出现应用 binlog 延迟</li><li>主库的 DDL，从库与主库的 DDL 同步是串行进行，DDL 在主库执行时间很长，那么从库也会消耗同样的时间</li><li>锁冲突问题也可能导致从节点的 SQL 线程执行慢</li></ul><p>主从同步问题永远都是<strong>一致性和性能的权衡</strong>，需要根据实际的应用场景，可以采取下面的办法：</p><ul><li><p>优化 SQL，避免慢 SQL，减少批量操作</p></li><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>业务中大多数情况查询操作要比更新操作更多，搭建<strong>一主多从</strong>结构，让这些从库来分担读的压力</p></li><li><p>尽量采用短的链路，主库和从库服务器的距离尽量要短，提升端口带宽，减少 binlog 传输的网络延时</p></li><li><p>实时性要求高的业务读强制走主库，从库只做备份</p></li></ul><hr><h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><h5 id="MySQL5-6"><a href="#MySQL5-6" class="headerlink" title="MySQL5.6"></a>MySQL5.6</h5><p>高并发情况下，主库的会产生大量的 binlog，在从库中有两个线程 IO Thread 和 SQL Thread 单线程执行，会导致主库延迟变大。为了改善复制延迟问题，MySQL 5.6 版本增加了并行复制功能，以采用多线程机制来促进执行</p><p>coordinator 就是原来的 SQL Thread，并行复制中它不再直接更新数据，<strong>只负责读取中转日志和分发事务</strong>：</p><ul><li>线程分配完成并不是立即执行，为了防止造成更新覆盖，更新同一 DB 的两个事务必须被分发到同一个工作线程</li><li>同一个事务不能被拆开，必须放到同一个工作线程</li></ul><p>MySQL 5.6 版本的策略：每个线程对应一个 hash 表，用于保存当前这个线程的执行队列里的事务所涉及的表，hash 表的 key 是数据库名，value 是一个数字，表示队列中有多少个事务修改这个库，适用于主库上有多个 DB 的情况</p><p>每个事务在分发的时候，跟线程的<strong>冲突</strong>（事务操作的是同一个库）关系包括以下三种情况：</p><ul><li>如果跟所有线程都不冲突，coordinator 线程就会把这个事务分配给最空闲的线程</li><li>如果只跟一个线程冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的线程</li><li>如果跟多于一个线程冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的线程只剩下 1 个</li></ul><p>优缺点：</p><ul><li>构造 hash 值的时候很快，只需要库名，而且一个实例上 DB 数也不会很多，不会出现需要构造很多项的情况</li><li>不要求 binlog 的格式，statement 格式的 binlog 也可以很容易拿到库名（日志章节详解了 binlog）</li><li>主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果，需要<strong>把相同热度的表均匀分到这些不同的 DB 中</strong>，才可以使用这个策略</li></ul><hr><h5 id="MySQL5-7"><a href="#MySQL5-7" class="headerlink" title="MySQL5.7"></a>MySQL5.7</h5><p>MySQL 5.7 由参数 slave-parallel-type 来控制并行复制策略：</p><ul><li>配置为 DATABASE，表示使用 MySQL 5.6 版本的<strong>按库（DB）并行策略</strong></li><li>配置为 LOGICAL_CLOCK，表示的<strong>按提交状态并行</strong>执行</li></ul><p>按提交状态并行复制策略的思想是：</p><ul><li>所有处于 commit 状态的事务可以并行执行；同时处于 prepare 状态的事务，在从库执行时是可以并行的</li><li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在从库执行时也是可以并行的</li></ul><p>MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制，新增了一个参数 binlog-transaction-dependency-tracking，用来控制是否启用这个新策略：</p><ul><li><p>COMMIT_ORDER：表示根据同时进入 prepare 和 commit 来判断是否可以并行的策略</p></li><li><p>WRITESET：表示的是对于每个事务涉及更新的每一行，计算出这一行的 hash 值，组成该事务的 writeset 集合，如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行（<strong>按行并行</strong>）</p><p>为了唯一标识，这个 hash 表的值是通过 <code>库名 + 表名 + 索引名 + 值</code>（表示的是某一行）计算出来的</p></li><li><p>WRITESET_SESSION：是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序</p></li></ul><p>MySQL 5.7.22 按行并发的优势：</p><ul><li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容，节省了计算量</li><li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个线程，更省内存</li><li>从库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也可以，更节约内存（因为 row 才记录更改的行）</li></ul><p>MySQL 5.7.22 的并行复制策略在通用性上是有保证的，但是对于表上没主键、唯一和外键约束的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型</p><p>参考文章：<a href="https://time.geekbang.org/column/article/77083">https://time.geekbang.org/column/article/77083</a></p><hr><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="读写延迟"><a href="#读写延迟" class="headerlink" title="读写延迟"></a>读写延迟</h4><p>读写分离：可以降低主库的访问压力，提高系统的并发能力</p><ul><li>主库不建查询的索引，从库建查询的索引。因为索引需要维护的，比如插入一条数据，不仅要在聚簇索引上面插入，对应的二级索引也得插入</li><li>将读操作分到从库了之后，可以在主库把查询要用的索引删了，减少写操作对主库的影响</li></ul><p>读写分离产生了读写延迟，造成数据的不一致性。假如客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，可能读到的还是以前的数据，叫过期读</p><p>解决方案：</p><ul><li>强制将写之后<strong>立刻读的操作转移到主库</strong>，比如刚注册的用户，直接登录从库查询可能查询不到，先走主库登录</li><li><strong>二次查询</strong>，如果从库查不到数据，则再去主库查一遍，由 API 封装，比较简单，但导致主库压力大</li><li>更新主库后，读从库之前先 sleep 一下，类似于执行一条 <code>select sleep(1)</code> 命令，大多数情况下主备延迟在 1 秒之内</li></ul><hr><h4 id="确保机制"><a href="#确保机制" class="headerlink" title="确保机制"></a>确保机制</h4><h5 id="无延迟"><a href="#无延迟" class="headerlink" title="无延迟"></a>无延迟</h5><p>确保主备无延迟的方法：</p><ul><li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0，如果不等于那就等到参数变为 0 执行查询请求</li><li>对比位点，Master_Log_File 和 Read_Master_Log_Pos 表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos 表示的是备库执行的最新位点，这两组值完全相同就说明接收到的日志已经同步完成</li><li>对比 GTID 集合，Retrieved_Gtid_Set 是备库收到的所有日志的 GTID 集合，Executed_Gtid_Set 是备库所有已经执行完成的 GTID 集合，如果这两个集合相同也表示备库接收到的日志都已经同步完成</li></ul><hr><h5 id="半同步"><a href="#半同步" class="headerlink" title="半同步"></a>半同步</h5><p>半同步复制就是 semi-sync replication，适用于一主一备的场景，工作流程：</p><ul><li>事务提交的时候，主库把 binlog 发给从库</li><li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了</li><li>主库收到这个 ack 以后，才能给客户端返回事务完成的确认</li></ul><p>在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认，这时在从库上执行查询请求，有两种情况：</p><ul><li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据</li><li>如果查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题</li></ul><p>在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，导致从库来不及处理，那么两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况</p><hr><h5 id="等位点"><a href="#等位点" class="headerlink" title="等位点"></a>等位点</h5><p>在<strong>从库执行判断位点</strong>的命令，参数 file 和 pos 指的是主库上的文件名和位置，timeout 可选，设置为正整数 N 表示最多等待 N 秒</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务</p><ul><li>如果执行期间，备库同步线程发生异常，则返回 NULL</li><li>如果等待超过 N 秒，就返回 -1</li><li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0</li></ul><p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要<strong>保证能够查到正确的数据</strong></p><ul><li>trx1 事务更新完成后，马上执行 <code>show master status</code> 得到当前主库执行到的 File 和 Position</li><li>选定一个从库执行判断位点语句，如果返回值是 &gt;&#x3D;0 的正整数，说明从库已经同步完事务，可以在这个从库执行查询语句</li><li>如果出现其他情况，需要到主库执行查询语句</li></ul><p>注意：如果所有的从库都延迟超过 timeout 秒，查询压力就都跑到主库上，所以需要进行权衡</p><hr><h5 id="等GTID"><a href="#等GTID" class="headerlink" title="等GTID"></a>等GTID</h5><p>数据库开启了 GTID 模式，MySQL 提供了判断 GTID 的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT wait_for_executed_gtid_set(gtid_set [, timeout])</span><br></pre></td></tr></table></figure><ul><li>等待直到这个库执行的事务中包含传入的 gtid_set，返回 0</li><li>超时返回 1</li></ul><p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据</p><ul><li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid</li><li>选定一个从库执行查询语句，如果返回值是 0，则在这个从库执行查询语句，否则到主库执行查询语句</li></ul><p>对比等待位点方法，减少了一次 <code>show master status</code> 的方法，将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可</p><p>总结：所有的等待无延迟的方法，都需要根据具体的业务场景去判断实施</p><p>参考文章：<a href="https://time.geekbang.org/column/article/77636">https://time.geekbang.org/column/article/77636</a></p><hr><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上，以此来降低单台服务器的负载，达到优化的效果</p><ul><li><p>分流查询：通过 MySQL 的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.jpg"></p></li><li><p>分布式数据库架构：适合大数据量、负载高的情况，具有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率</p></li></ul><hr><h3 id="主从搭建"><a href="#主从搭建" class="headerlink" title="主从搭建"></a>主从搭建</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><ol><li><p>在master 的配置文件（&#x2F;etc&#x2F;mysql&#x2F;my.cnf）中，配置如下内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure></li><li><p>执行完毕之后，需要重启 MySQL</p></li><li><p>创建同步数据的账户，并且进行授权操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;seazean&#x27;@&#x27;192.168.0.137&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li><li><p>查看 master 状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8Bmaster%E7%8A%B6%E6%80%81.jpg"></p><ul><li>File：从哪个日志文件开始推送日志文件 </li><li>Position：从哪个位置开始推送日志</li><li>Binlog_Ignore_DB：指定不需要同步的数据库</li></ul></li></ol><hr><h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><ol><li><p>在 slave 端配置文件中，配置如下内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure></li><li><p>执行完毕之后，需要重启 MySQL</p></li><li><p>指定当前从库对应的主库的IP地址、用户名、密码，从哪个日志文件开始的那个位置开始同步推送日志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST= &#x27;192.168.0.138&#x27;, MASTER_USER=&#x27;seazean&#x27;, MASTER_PASSWORD=&#x27;seazean&#x27;, MASTER_LOG_FILE=&#x27;mysqlbin.000001&#x27;, MASTER_LOG_POS=413;</span><br></pre></td></tr></table></figure></li><li><p>开启同步操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START SLAVE;</span><br><span class="line">SHOW SLAVE STATUS;</span><br></pre></td></tr></table></figure></li><li><p>停止同步操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOP SLAVE;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><p>在主库中创建数据库，创建表并插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db01;</span><br><span class="line">USE db01;</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">name VARCHAR(50) NOT NULL,</span><br><span class="line">sex VARCHAR(1),</span><br><span class="line">PRIMARY KEY (id)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Tom&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Trigger&#x27;,&#x27;0&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Dawn&#x27;,&#x27;1&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>在从库中查询数据，进行验证：</p><p>在从库中，可以查看到刚才创建的数据库：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%811.jpg"></p><p>在该数据库中，查询表中的数据：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%812.jpg"></p></li></ol><hr><h3 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h3><h4 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h4><p>正常切换步骤：</p><ul><li><p>在开始切换之前先对主库进行锁表 <code>flush tables with read lock</code>，然后等待所有语句执行完成，切换完成后可以释放锁</p></li><li><p>检查 slave 同步状态，在 slave 执行 <code>show processlist</code></p></li><li><p>停止 slave io 线程，执行命令 <code>STOP SLAVE IO_THREAD</code></p></li><li><p>提升 slave 为 master</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Stop slave;</span><br><span class="line">Reset master;</span><br><span class="line">Reset slave <span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> read_only<span class="operator">=</span>off;<span class="comment">-- 设置为可更新状态</span></span><br></pre></td></tr></table></figure></li><li><p>将原来 master 变为 slave（参考搭建流程中的 slave 方法）</p></li></ul><p><strong>可靠性优先策略</strong>：</p><ul><li>判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步</li><li>把主库 A 改成只读状态，即把 readonly 设置为 true</li><li>判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止（该步骤比较耗时，所以步骤 1 中要尽量等待该值变小）</li><li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false</li><li>把业务请求切到备库 B</li></ul><p>可用性优先策略：先做最后两步，会造成主备数据不一致的问题</p><p>参考文章：<a href="https://time.geekbang.org/column/article/76795">https://time.geekbang.org/column/article/76795</a></p><hr><h4 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h4><p>主库发生故障后从库会上位，<strong>其他从库指向新的主库</strong>，所以需要一个健康检测的机制来判断主库是否宕机</p><ul><li><p>select 1 判断，但是高并发下检测不出线程的锁等待的阻塞问题</p></li><li><p>查表判断，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行。但是当 binlog 所在磁盘的空间占用率达到 100%，所有的更新和事务提交语句都被阻塞，查询语句可以继续运行</p></li><li><p>更新判断，在健康检测表中放一个 timestamp 字段，用来表示最后一次执行检测的时间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.health_check SET t_modified=now();</span><br></pre></td></tr></table></figure><p>节点可用性的检测都应该包含主库和备库，为了让主备之间的更新不产生冲突，可以在 mysql.health_check 表上存入多行数据，并用主备的 server_id 做主键，保证主、备库各自的检测命令不会发生冲突</p></li></ul><hr><h4 id="基于位点"><a href="#基于位点" class="headerlink" title="基于位点"></a>基于位点</h4><p>主库上位后，从库 B 执行 CHANGE MASTER TO 命令，指定 MASTER_LOG_FILE、MASTER_LOG_POS 表示从新主库 A 的哪个文件的哪个位点开始同步，这个位置就是<strong>同步位点</strong>，对应主库的文件名和日志偏移量</p><p>寻找位点需要找一个稍微往前的，然后再通过判断跳过那些在从库 B 上已经执行过的事务，获取位点方法：</p><ul><li>等待新主库 A 把中转日志（relay log）全部同步完成</li><li>在 A 上执行 show master status 命令，得到当前 A 上最新的 File 和 Position</li><li>取原主库故障的时刻 T，用 mysqlbinlog 工具解析新主库 A 的 File，得到 T 时刻的位点</li></ul><p>通常情况下该值并不准确，在切换的过程中会发生错误，所以要先主动跳过这些错误：</p><ul><li><p>切换过程中，可能会重复执行一个事务，所以需要主动跳过所有重复的事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL sql_slave_skip_counter=1;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure></li><li><p>设置 slave_skip_errors 参数，直接设置跳过指定的错误，保证主从切换的正常进行</p><ul><li>1062 错误是插入数据时唯一键冲突</li><li>1032 错误是删除数据时找不到行</li></ul><p>该方法针对的是主备切换时，由于找不到精确的同步位点，只能采用这种方法来创建从库和新主库的主备关系。等到主备间的同步关系建立完成并稳定执行一段时间后，还需要把这个参数设置为空，以免真的出现了主从数据不一致也跳过了</p></li></ul><hr><h4 id="基于GTID"><a href="#基于GTID" class="headerlink" title="基于GTID"></a>基于GTID</h4><h5 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h5><p>GTID 的全称是 Global Transaction Identifier，全局事务 ID，是一个事务<strong>在提交时生成</strong>的，是这个事务的唯一标识，组成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure><ul><li>source_id：是一个实例第一次启动时自动生成的，是一个全局唯一的值</li><li>transaction_id：初始值是 1，每次提交事务的时候分配给这个事务，并加 1，是连续的（区分事务 ID，事务 ID 是在执行时生成）</li></ul><p>启动 MySQL 实例时，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code> 就可以启动 GTID 模式，每个事务都会和一个 GTID 一一对应，每个 MySQL 实例都维护了一个 GTID 集合，用来存储当前实例<strong>执行过的所有事务</strong></p><p>GTID 有两种生成方式，使用哪种方式取决于 session 变量 gtid_next：</p><ul><li><p><code>gtid_next=automatic</code>：使用默认值，把 source_id:transaction_id （递增）分配给这个事务，然后加入本实例的 GTID 集合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@SESSION.GTID_NEXT = &#x27;source_id:transaction_id&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><code>gtid_next=GTID</code>：指定的 GTID 的值，如果该值已经存在于实例的 GTID 集合中，接下来执行的事务会直接被系统忽略；反之就将该值分配给接下来要执行的事务，系统不需要给这个事务生成新的 GTID，也不用加 1</p><p>注意：一个 GTID 只能给一个事务使用，所以执行下一个事务，要把 gtid_next 设置成另外一个 GTID 或者 automatic</p></li></ul><p>业务场景：</p><ul><li><p>主库 X 和从库 Y 执行一条相同的指令后进行事务同步</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO t VALUES(1,1);</span><br></pre></td></tr></table></figure></li><li><p>当 Y 同步 X 时，会出现主键冲突，导致实例 X 的同步线程停止，解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET gtid_next=&#x27;(这里是主库 X 的 GTID 值)&#x27;;</span><br><span class="line">BEGIN;</span><br><span class="line">COMMIT;</span><br><span class="line">SET gtid_next=automatic;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><p>前三条语句通过<strong>提交一个空事务</strong>，把 X 的 GTID 加到实例 Y 的 GTID 集合中，实例 Y 就会直接跳过这个事务</p></li></ul><hr><h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><p>在 GTID 模式下，CHANGE MASTER TO 不需要指定日志名和日志偏移量，指定 <code>master_auto_position=1</code> 代表使用 GTID 模式</p><p>新主库实例 A 的 GTID 集合记为 set_a，从库实例 B 的 GTID 集合记为 set_b，主备切换逻辑：</p><ul><li>实例 B 指定主库 A，基于主备协议建立连接，实例 B 并把 set_b 发给主库 A</li><li>实例 A 算出 set_a 与 set_b 的差集，就是所有存在于 set_a 但不存在于 set_b 的 GTID 的集合，判断 A 本地是否包含了这个<strong>差集</strong>需要的所有 binlog 事务<ul><li>如果不包含，表示 A 已经把实例 B 需要的 binlog 给删掉了，直接返回错误</li><li>如果确认全部包含，A 从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B</li></ul></li><li>实例 A 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行</li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/77427">https://time.geekbang.org/column/article/77427</a></p><hr><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的过程，可以帮助数据库管理员追踪数据库曾经发生过的各种事件</p><p>MySQL日志主要包括六种：</p><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（binlog）（二进制日志）</li><li>错误日志（errorlog）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><hr><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</p><p>该日志是默认开启的，默认位置是：<code>/var/log/mysql/error.log</code></p><p>查看指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;log_error%&#x27;;</span><br></pre></td></tr></table></figure><p>查看日志内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/mysql/error.log</span><br></pre></td></tr></table></figure><hr><h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>归档日志（BINLOG）也叫二进制日志，是因为采用二进制进行存储，记录了所有的 DDL（数据定义语言）语句和 DML（数据操作语言）语句，但<strong>不包括数据查询语句，在事务提交前的最后阶段写入</strong></p><p>作用：<strong>灾难时的数据恢复和 MySQL 的主从复制</strong></p><p>归档日志默认情况下是没有开启的，需要在 MySQL 配置文件中开启，并配置 MySQL 日志的格式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mysql</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如: mysqlbin.000001</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>日志存放位置：配置时给定了文件名但是没有指定路径，日志默认写入MySQL 的数据目录</p><p>日志格式：</p><ul><li><p>STATEMENT：该日志格式在日志文件中记录的都是 <strong>SQL 语句</strong>，每一条对数据进行修改的 SQL 都会记录在日志文件中，通过 mysqlbinlog 工具，可以查看到每条语句的文本。主从复制时，从库会将日志解析为原语句，并在从库重新执行一遍</p><p>缺点：可能会导致主备不一致，因为记录的 SQL 在不同的环境中可能选择的索引不同，导致结果不同</p></li><li><p>ROW：该日志格式在日志文件中记录的是每一行的<strong>数据变更</strong>，而不是记录 SQL 语句。比如执行 SQL 语句 <code>update tb_book set status=&#39;1&#39;</code>，如果是 STATEMENT，在日志中会记录一行 SQL 语句； 如果是 ROW，由于是对全表进行更新，就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更</p><p>缺点：记录的数据比较多，占用很多的存储空间</p></li><li><p>MIXED：这是 MySQL 默认的日志格式，混合了STATEMENT 和 ROW 两种格式，MIXED 格式能尽量利用两种模式的优点，而避开它们的缺点</p></li></ul><hr><h4 id="日志刷盘-1"><a href="#日志刷盘-1" class="headerlink" title="日志刷盘"></a>日志刷盘</h4><p>事务执行过程中，先将日志写（write）到 binlog cache，事务提交时再把 binlog cache 写（fsync）到 binlog 文件中，一个事务的 binlog 是不能被拆开的，所以不论这个事务多大也要确保一次性写入</p><p>事务提交时执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache</p><p>write 和 fsync 的时机由参数 sync_binlog 控制的：</p><ul><li>sync_binlog&#x3D;0：表示每次提交事务都只 write，不 fsync</li><li>sync_binlog&#x3D;1：表示每次提交事务都会执行 fsync</li><li>sync_binlog&#x3D;N(N&gt;1)：表示每次提交事务都 write，但累积 N 个事务后才 fsync，但是如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志</li></ul><hr><h4 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h4><p>日志文件存储位置：&#x2F;var&#x2F;lib&#x2F;mysql</p><p>由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log-file;</span><br></pre></td></tr></table></figure><p>查看 STATEMENT 格式日志：</p><ul><li><p>执行插入语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Lucene&#x27;,&#x27;2088-05-01&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><code>cd /var/lib/mysql</code>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rw-r-----  1 mysql mysql      177 5月  23 21:08 mysqlbin.000001</span><br><span class="line">-rw-r-----  1 mysql mysql       18 5月  23 21:04 mysqlbin.index</span><br></pre></td></tr></table></figure><p>mysqlbin.index：该文件是日志索引文件 ， 记录日志的文件名；</p><p>mysqlbing.000001：日志文件</p></li><li><p>查看日志内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p><p>日志结尾有 COMMIT</p></li></ul><p>查看 ROW 格式日志：</p><ul><li><p>修改配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure></li><li><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;SpringCloud实战&#x27;,&#x27;2088-05-05&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>查看日志内容：日志格式 ROW，直接查看数据是乱码，可以在 mysqlbinlog 后面加上参数 -vv </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -vv mysqlbin.000002</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p></li></ul><hr><h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的系统，生成日志量大，这些日志如果长时间不清除，将会占用大量的磁盘空间，需要删除日志</p><ul><li><p>Reset Master 指令删除全部 binlog 日志，删除之后，日志编号将从 xxxx.000001重新开始</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reset Master-- MySQL指令</span><br></pre></td></tr></table></figure></li><li><p>执行指令 <code>PURGE MASTER LOGS TO &#39;mysqlbin.***</code>，该命令将删除 <code> ***</code> 编号之前的所有日志</p></li><li><p>执行指令 <code>PURGE MASTER LOGS BEFORE &#39;yyyy-mm-dd hh:mm:ss&#39;</code> ，该命令将删除日志为 <code>yyyy-mm-dd hh:mm:ss</code> 之前产生的日志</p></li><li><p>设置参数 <code>--expire_logs_days=#</code>，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样做有利于减少管理日志的工作量，配置 my.cnf 文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">log_bin=mysqlbin</span><br><span class="line">binlog_format=ROW</span><br><span class="line">--expire_logs_days=3</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>误删库或者表时，需要根据 binlog 进行数据恢复</p><p>一般情况下数据库有定时的全量备份，假如每天 0 点定时备份，12 点误删了库，恢复流程：</p><ul><li>取最近一次全量备份，用备份恢复出一个临时库</li><li>从日志文件中取出凌晨 0 点之后的日志</li><li>把除了误删除数据的语句外日志，全部应用到临时库</li></ul><p>跳过误删除语句日志的方法：</p><ul><li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用 –stop-position 参数执行到误操作之前的日志，然后再用 –start-position 从误操作之后的日志继续执行</li><li>如果实例使用了 GTID 模式，假设误操作命令的 GTID 是 gtid1，那么只需要提交一个空事务先将这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时就会自动跳过误操作的语句</li></ul><hr><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的 SQL 语句</p><p>默认情况下，查询日志是未开启的。如果需要开启查询日志，配置 my.cnf：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该选项用来开启查询日志，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment"># 设置日志的文件名，如果没有指定，默认的文件名为host_name.log，存放在/var/lib/mysql</span></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p>配置完毕之后，在数据库执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_book;</span><br><span class="line">SELECT * FROM tb_book WHERE id = 1;</span><br><span class="line">UPDATE tb_book SET name = &#x27;lucene入门指南&#x27; WHERE id = 5;</span><br><span class="line">SELECT * FROM tb_book WHERE id &lt; 8</span><br></pre></td></tr></table></figure><p>执行完毕之后， 再次来查询日志文件：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png"></p><hr><h3 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h3><p>慢查询日志记录所有执行时间超过 long_query_time 并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志long_query_time 默认为 10 秒，最小为 0， 精度到微秒</p><p>慢查询日志默认是关闭的，可以通过两个参数来控制慢查询日志，配置文件 <code>/etc/mysql/my.cnf</code>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">slow_query_log=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数用来指定慢查询日志的文件名，存放在 /var/lib/mysql</span></span><br><span class="line">slow_query_log_file=slow_query.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用来配置查询的时间限制，超过这个时间将认为值慢查询，将需要进行日志记录，默认10s</span></span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure><p>日志读取：</p><ul><li><p>直接通过 cat 指令查询该日志文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> slow_query.log</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p></li><li><p>如果慢查询日志内容很多，直接查看文件比较繁琐，可以借助 mysql 自带的 mysqldumpslow 工具对慢查询日志进行分类汇总：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldumpslow slow_query.log</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p></li></ul><hr><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>建立科学的，<strong>规范的数据表</strong>就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式</p><p><strong>1NF：</strong>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，<strong>第一范式每一列不可再拆分，称为原子性</strong></p><p>基本表：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%99%AE%E9%80%9A%E8%A1%A8.png"></p><p>第一范式表：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png"></p><hr><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p><strong>2NF：</strong>在满足第一范式的基础上，非主属性完全依赖于主码（主关键字、主键），消除非主属性对主码的部分函数依赖。简而言之，<strong>表中的每一个字段 （所有列）都完全依赖于主键，记录的唯一性</strong></p><p>作用：遵守第二范式减少数据冗余，通过主键区分相同数据。</p><ol><li>函数依赖：A → B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，则称 B 依赖于 A<ul><li>学号 → 姓名；(学号，课程名称) → 分数</li></ul></li><li>完全函数依赖：A → B，如果A是一个属性组，则 B 属性值的确定需要依赖于 A 属性组的所有属性值<ul><li>(学号，课程名称) → 分数</li></ul></li><li>部分函数依赖：A → B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组的某些属性值<ul><li>(学号，课程名称) → 姓名</li></ul></li><li>传递函数依赖：A → B，B → C，如果通过A属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值，可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A<ul><li>学号 → 系名，系名 → 系主任</li></ul></li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<ul><li>该表中的码：(学号，课程名称)</li><li>主属性：码属性组中的所有属性</li><li>非主属性：除码属性组以外的属性</li></ul></li></ol><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png"></p><hr><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p><strong>3NF：</strong>在满足第二范式的基础上，表中的任何属性不依赖于其它非主属性，消除传递依赖。简而言之，<strong>非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键</strong>。</p><p>作用：可以通过主键 id 区分相同数据，修改数据的时候只需要修改一张表（方便修改），反之需要修改多表。</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F.png"></p><hr><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>NoSQL（Not-Only SQL）：泛指非关系型的数据库，作为关系型数据库的补充</p><p>MySQL 支持 ACID 特性，保证可靠性和持久性，读取性能不高，因此需要缓存的来减缓数据库的访问压力</p><p>作用：应对基于海量用户和海量数据前提下的数据处理问题</p><p>特征：</p><ul><li>可扩容，可伸缩，SQL 数据关系过于复杂，Nosql 不存关系，只存数据</li><li>大数据量下高性能，数据不存取在磁盘 IO，存取在内存</li><li>灵活的数据模型，设计了一些数据存储格式，能保证效率上的提高</li><li>高可用，集群</li></ul><p>常见的 NoSQL：Redis、memcache、HBase、MongoDB</p><p>参考书籍：<a href="https://book.douban.com/subject/25900156/">https://book.douban.com/subject/25900156/</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p><hr><h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>Redis (REmote DIctionary Server) ：用 C 语言开发的一个开源的高性能键值对（key-value）数据库</p><p>特征：</p><ul><li>数据间没有必然的关联关系，<strong>不存关系，只存数据</strong></li><li>数据<strong>存储在内存</strong>，存取速度快，解决了磁盘 IO 速度慢的问题</li><li>内部采用<strong>单线程</strong>机制进行工作</li><li>高性能，官方测试数据，50 个并发执行 100000 个请求，读的速度是 110000 次&#x2F;s，写的速度是 81000 次&#x2F;s</li><li>多数据类型支持<ul><li>字符串类型：string（String）</li><li>列表类型：list（LinkedList）</li><li>散列类型：hash（HashMap）</li><li>集合类型：set（HashSet）</li><li>有序集合类型：zset&#x2F;sorted_set（TreeSet）</li></ul></li><li>支持持久化，可以进行数据灾难恢复</li></ul><hr><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：</p><ul><li><p>Redis 5.0 被包含在默认的 Ubuntu 20.04 软件源中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure></li><li><p>检查 Redis 状态</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></table></figure></li></ul><p>启动：</p><ul><li><p>启动服务器——参数启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server [--port port]</span><br><span class="line"><span class="comment">#redis-server --port 6379</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务器——配置文件启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br><span class="line"><span class="comment">#redis-server /etc/redis/conf/redis-6397.conf</span></span><br></pre></td></tr></table></figure></li><li><p>启动客户端：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [-h host] [-p port]</span><br><span class="line"><span class="comment">#redis-cli -h 192.168.2.185 -p 6397</span></span><br></pre></td></tr></table></figure><p>注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p</p></li></ul><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h4><ol><li><p>创建文件结构</p><p>创建配置文件存储目录</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> conf</span><br></pre></td></tr></table></figure><p>创建服务器文件存储目录（包含日志、数据、临时配置文件等）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件副本放入 conf 目录，Ubuntu 系统配置文件 redis.conf 在目录 <code>/etc/redis</code> 中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> redis.conf | grep -v <span class="string">&quot;#&quot;</span> | grep -v <span class="string">&quot;^$&quot;</span> -&gt; /conf/redis-6379.conf</span><br></pre></td></tr></table></figure><p>去除配置文件的注释和空格，输出到新的文件，命令方式采用 redis-port.conf</p></li></ol><hr><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul><li><p>设置服务器以守护进程的方式运行，关闭后服务器控制台中将打印服务器运行信息（同日志内容相同）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure></li><li><p>绑定主机地址，绑定本地IP地址，否则SSH无法访问：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> ip</span><br></pre></td></tr></table></figure></li><li><p>设置服务器端口：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port port</span><br></pre></td></tr></table></figure></li><li><p>设置服务器文件保存地址：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path</span><br></pre></td></tr></table></figure></li><li><p>设置数据库的数量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li><li><p>多服务器快捷配置：</p><p>导入并加载指定配置文件信息，用于快速创建 redis 公共配置较多的 redis 实例配置文件，便于维护</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">include /path/conf_name.conf</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>服务器允许客户端连接最大数量，默认 0，表示无限制，当客户端连接到达上限后，Redis 会拒绝新的连接：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxclients count</span><br></pre></td></tr></table></figure></li><li><p>客户端闲置等待最大时长，达到最大值后关闭对应连接，如需关闭该功能，设置为 0：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> seconds</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>设置日志记录</p><ul><li><p>设置服务器以指定日志记录级别</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure></li><li><p>日志记录文件名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">logfile filename</span><br></pre></td></tr></table></figure></li></ul><p>注意：日志级别开发期设置为 verbose 即可，生产环境中配置为 notice，简化日志输出量，降低写日志 IO 的频度</p><p><strong>配置文件：</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.2.185</span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">#timeout 0</span></span><br><span class="line">daemonize no</span><br><span class="line">logfile /etc/redis/data/redis-6379.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">dir</span> /etc/redis/data</span><br><span class="line">dbfilename <span class="string">&quot;dump-6379.rdb&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><p>帮助信息：</p><ul><li><p>获取命令帮助文档</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br><span class="line"><span class="comment">#help set</span></span><br></pre></td></tr></table></figure></li><li><p>获取组中所有命令信息名称</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [@group-name]</span><br><span class="line"><span class="comment">#help @string</span></span><br></pre></td></tr></table></figure></li></ul><p>退出服务</p><ul><li><p>退出客户端：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li><li><p>退出客户端服务器快捷键：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="数据库-2"><a href="#数据库-2" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><p>Redis 服务器将所有数据库保存在<strong>服务器状态 redisServer 结构</strong>的 db 数组中，数组的每一项都是 redisDb 结构，代表一个数据库，每个数据库之间相互独立，**共用 **Redis 内存，不区分大小。在初始化服务器时，根据 dbnum 属性决定创建数据库的数量，该属性由服务器配置的 database 选项决定，默认 16</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存服务器所有的数据库</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-服务器数据库.png" style="zoom: 67%;"><p><strong>在服务器内部</strong>，客户端状态 redisClient 结构的 db 属性记录了目标数据库，是一个指向 redisDb 结构的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端正在使用的数据库，指向 redisServer.db 数组中的某一个 db</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 Redis 客户端都有目标数据库，执行数据库读写命令时目标数据库就会成为这些命令的操作对象，默认情况下 Redis 客户端的目标数据库为 0 号数据库，客户端可以执行 SELECT 命令切换目标数据库，原理是通过修改 redisClient.db 指针指向服务器中不同数据库</p><p>命令操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">select index<span class="comment">#切换数据库，index从0-15取值</span></span><br><span class="line">move key db<span class="comment">#数据移动到指定数据库，db是数据库编号</span></span><br><span class="line">ping<span class="comment">#测试数据库是否连接正常，返回PONG</span></span><br><span class="line"><span class="built_in">echo</span> message<span class="comment">#控制台输出信息</span></span><br></pre></td></tr></table></figure><p>Redis 没有可以返回客户端目标数据库的命令，但是 redis-cli 客户端旁边会提示当前所使用的目标数据库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SELECT 1 </span><br><span class="line">OK </span><br><span class="line">redis[1]&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h3><h4 id="key-space"><a href="#key-space" class="headerlink" title="key space"></a>key space</h4><p>Redis 是一个键值对（key-value pair）数据库服务器，每个数据库都由一个 redisDb 结构表示，redisDb.dict <strong>字典中保存了数据库的所有键值对</strong>，将这个字典称为键空间（key space）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存所有键值对</span></span><br><span class="line">    dict *dict</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键就是数据库的键，每个键都是一个字符串对象</li><li>键空间的值就是数据库的值，每个值可以是任意一种 Redis 对象</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4.png"></p><p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会<strong>进行一些维护操作</strong>：</p><ul><li>在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中 hit 次数或键空间不命中 miss 次数，这两个值可以在 <code>INFO stats</code> 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看</li><li>更新键的 LRU（最后使用）时间，该值可以用于计算键的闲置时间，使用 <code>OBJECT idletime key</code> 查看键 key 的闲置时间</li><li>如果在读取一个键时发现该键已经过期，服务器会<strong>先删除过期键</strong>，再执行其他操作</li><li>如果客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务注意到这个键已经被修改过</li><li>服务器每次修改一个键之后，都会对 dirty 键计数器的值增1，该计数器会触发服务器的持久化以及复制操作</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li></ul><hr><h4 id="读写指令"><a href="#读写指令" class="headerlink" title="读写指令"></a>读写指令</h4><p>常见键操作指令：</p><ul><li><p>增加指令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value<span class="comment">#添加一个字符串类型的键值对</span></span><br></pre></td></tr></table></figure></li><li><p>删除指令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">del key<span class="comment">#删除指定key</span></span><br><span class="line"><span class="built_in">unlink</span> key   <span class="comment">#非阻塞删除key，真正的删除会在后续异步操作</span></span><br></pre></td></tr></table></figure></li><li><p>更新指令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename key newkey<span class="comment">#改名</span></span><br><span class="line">renamenx key newkey<span class="comment">#改名</span></span><br></pre></td></tr></table></figure><p>值得更新需要参看具体得 Redis 对象得操作方式，比如字符串对象执行 <code>SET key value</code> 就可以完成修改</p></li><li><p>查询指令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">exists key<span class="comment">#获取key是否存在</span></span><br><span class="line">randomkey<span class="comment">#随机返回一个键</span></span><br><span class="line">keys pattern<span class="comment">#查询key</span></span><br></pre></td></tr></table></figure><p>KEYS 命令需要<strong>遍历存储的键值对</strong>，操作延时高，一般不被建议用于生产环境中</p><p>查询模式规则：* 匹配任意数量的任意符号、? 配合一个任意符号、[] 匹配一个指定符号</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keys *<span class="comment">#查询所有key</span></span><br><span class="line">keys aa*<span class="comment">#查询所有以aa开头</span></span><br><span class="line">keys *bb<span class="comment">#查询所有以bb结尾</span></span><br><span class="line">keys ??cc<span class="comment">#查询所有前面两个字符任意，后面以cc结尾 </span></span><br><span class="line">keys user:?<span class="comment">#查询所有以user:开头，最后一个字符任意</span></span><br><span class="line">keys u[st]er:1<span class="comment">#查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span></span><br></pre></td></tr></table></figure></li><li><p>其他指令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> key<span class="comment">#获取key的类型</span></span><br><span class="line">dbsize<span class="comment">#获取当前数据库的数据总量，即key的个数</span></span><br><span class="line">flushdb<span class="comment">#清除当前数据库的所有数据(慎用)</span></span><br><span class="line">flushall<span class="comment">#清除所有数据(慎用)</span></span><br></pre></td></tr></table></figure><p>在执行 FLUSHDB 这样的危险命令之前，最好先执行一个 SELECT 命令，保证当前所操作的数据库是目标数据库</p></li></ul><hr><h4 id="时效设置"><a href="#时效设置" class="headerlink" title="时效设置"></a>时效设置</h4><p>客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间（TimeTo Live, TTL），在经过指定时间之后，服务器就会自动删除生存时间为 0 的键；也可以以 UNIX 时间戳的方式设置过期时间（expire time），当键的过期时间到达，服务器会自动删除这个键</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">expire key seconds<span class="comment">#为指定key设置生存时间，单位为秒</span></span><br><span class="line">pexpire key milliseconds<span class="comment">#为指定key设置生存时间，单位为毫秒</span></span><br><span class="line">expireat key timestamp<span class="comment">#为指定key设置过期时间，单位为时间戳</span></span><br><span class="line">pexpireat key mil-timestamp<span class="comment">#为指定key设置过期时间，单位为毫秒时间戳</span></span><br></pre></td></tr></table></figure><ul><li>实际上 EXPIRE、EXPIRE、EXPIREAT 三个命令<strong>底层都是转换为 PEXPIREAT 命令</strong>来实现的</li><li>SETEX 命令可以在设置一个字符串键的同时为键设置过期时间，但是该命令是一个类型限定命令</li></ul><p>redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，字典称为过期字典：</p><ul><li>键是一个指针，指向键空间中的某个键对象（复用键空间的对象，不会产生内存浪费）</li><li>值是一个 long long 类型的整数，保存了键的过期时间，是一个毫秒精度的 UNIX 时间戳</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 过期字典，保存所有键的过期时间</span></span><br><span class="line">    dict *expires</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure><p>客户端执行 PEXPIREAT 命令，服务器会在数据库的过期字典中关联给定的数据库键和过期时间：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PEXPIREAT</span>(<span class="params">key, expire_time_in_ms</span>):</span><br><span class="line"><span class="comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在过期字典中关联键和过期时间</span></span><br><span class="line">redisDB.expires[key] = expire_time_in_ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过期时间设置成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="时效状态"><a href="#时效状态" class="headerlink" title="时效状态"></a>时效状态</h4><p>TTL 和 PTTL 命令通过计算键的过期时间和当前时间之间的差，返回这个键的剩余生存时间</p><ul><li>返回正数代表该数据在内存中还能存活的时间</li><li>返回 -1 代表永久性，返回 -2 代表键不存在</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ttl key<span class="comment">#获取key的剩余时间，每次获取会自动变化(减小)，类似于倒计时</span></span><br><span class="line">pttl key<span class="comment">#获取key的剩余时间，单位是毫秒，每次获取会自动变化(减小)</span></span><br></pre></td></tr></table></figure><p>PERSIST 是 PEXPIREAT 命令的反操作，在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persist key<span class="comment">#切换key从时效性转换为永久性</span></span><br></pre></td></tr></table></figure><p>Redis 通过过期字典可以检查一个给定键是否过期：</p><ul><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li><li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是那么键已经过期，否则键未过期</li></ul><p>补充：AOF、RDB 和复制功能对过期键的处理</p><ul><li>RDB ：<ul><li>生成 RDB 文件，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中</li><li>载入 RDB 文件，如果服务器以主服务器模式运行，那么在载入时会对键进行检查，过期键会被忽略；如果服务器以从服务器模式运行，会载入所有键，包括过期键，但是主从服务器进行数据同步时就会删除这些键</li></ul></li><li>AOF：<ul><li>写入 AOF 文件，如果数据库中的某个键已经过期，但还没有被删除，那么 AOF 文件不会因为这个过期键而产生任何影响；当该过期键被删除，程序会向 AOF 文件追加一条 DEL 命令，显式的删除该键</li><li>AOF 重写，会对数据库中的键进行检查，忽略已经过期的键</li></ul></li><li>复制：当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制<ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，会当作未过期键处理，只有在接到主服务器发来的 DEL 命令之后，才会删除过期键（数据不一致）</li></ul></li></ul><hr><h3 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h3><h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><p>删除策略就是<strong>针对已过期数据的处理策略</strong>，已过期的数据不一定被立即删除，在不同的场景下使用不同的删除方式会有不同效果，在内存占用与 CPU 占用之间寻找一种平衡，顾此失彼都会造成整体 Redis 性能的下降，甚至引发服务器宕机或内存泄露</p><p>针对过期数据有三种删除策略：</p><ul><li>定时删除</li><li>惰性删除（被动删除）</li><li>定期删除</li></ul><p>Redis 采用惰性删除和定期删除策略的结合使用</p><hr><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间到达时，立即执行对键的删除操作</p><ul><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：对 CPU 不友好，无论 CPU 此时负载多高均占用 CPU，会影响 Redis 服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间（拿时间换空间）</li></ul><p>创建一个定时器需要用到 Redis 服务器中的时间事件，而时间事件的实现方式是无序链表，查找一个事件的时间复杂度为 O(N)，并不能高效地处理大量时间事件，所以采用这种方式并不现实</p><hr><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>数据到达过期时间不做处理，等下次访问到该数据时执行 <strong>expireIfNeeded()</strong> 判断：</p><ul><li>如果输入键已经过期，那么 expireIfNeeded 函数将输入键从数据库中删除，接着访问就会返回空</li><li>如果输入键未过期，那么 expireIfNeeded 函数不做动作</li></ul><p>所有的 Redis 读写命令在执行前都会调用 expireIfNeeded 函数进行检查，该函数就像一个过滤器，在命令真正执行之前过滤掉过期键</p><p>惰性删除的特点： </p><ul><li>优点：节约 CPU 性能，删除的目标仅限于当前处理的键，不会在删除其他无关的过期键上花费任何 CPU 时间</li><li>缺点：内存压力很大，出现长期占用内存的数据，如果过期键永远不被访问，这种情况相当于内存泄漏</li><li>总结：用存储空间换取处理器性能（拿空间换时间）</li></ul><hr><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除策略是每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</p><ul><li>如果删除操作执行得太频繁，或者执行时间太长，就会退化成定时删除策略，将 CPU 时间过多地消耗在删除过期键上</li><li>如果删除操作执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况</li></ul><p>定期删除是<strong>周期性轮询 Redis 库中的时效性</strong>数据，从过期字典中随机抽取一部分键检查，利用过期数据占比的方式控制删除频度</p><ul><li><p>Redis 启动服务器初始化时，读取配置 server.hz 的值，默认为 10，执行指令 info server 可以查看，每秒钟执行 server.hz 次 <code>serverCron() → activeExpireCycle()</code></p></li><li><p>activeExpireCycle() 对某个数据库中的每个 expires 进行检测，工作模式：</p><ul><li><p>轮询每个数据库，从数据库中取出一定数量的随机键进行检查，并删除其中的过期键，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒</p></li><li><p>全局变量 current_db 用于记录 activeExpireCycle() 的检查进度（哪一个数据库），下一次调用时接着该进度处理</p></li><li><p>随着函数的不断执行，服务器中的所有数据库都会被检查一遍，这时将 current_db 重置为 0，然后再次开始新一轮的检查</p></li></ul></li></ul><p>定期删除特点：</p><ul><li>CPU 性能占用设置有峰值，检测频度可自定义设置</li><li>内存压力不是很大，长期占用内存的<strong>冷数据会被持续清理</strong></li><li>周期性抽查存储空间（随机抽查，重点抽查）</li></ul><hr><h3 id="数据淘汰"><a href="#数据淘汰" class="headerlink" title="数据淘汰"></a>数据淘汰</h3><h4 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h4><p>数据淘汰策略：当新数据进入 Redis 时，在执行每一个命令前，会调用 <strong>freeMemoryIfNeeded()</strong> 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis 要临时删除一些数据为当前指令清理存储空间，清理数据的策略称为<strong>逐出算法</strong></p><p>逐出数据的过程不是 100% 能够清理出足够的可使用的内存空间，如果不成功则反复执行，当对所有数据尝试完毕，如不能达到内存清理的要求，<strong>出现 Redis 内存打满异常</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(error) OOM <span class="built_in">command</span> not allowed when used memory &gt;<span class="string">&#x27;maxmemory&#x27;</span></span><br></pre></td></tr></table></figure><hr><h4 id="策略配置"><a href="#策略配置" class="headerlink" title="策略配置"></a>策略配置</h4><p>Redis 如果不设置最大内存大小或者设置最大内存大小为 0，在 64 位操作系统下不限制内存大小，在 32 位操作系统默认为 3GB 内存，一般推荐设置 Redis 内存为最大物理内存的四分之三</p><p>内存配置方式：</p><ul><li><p>通过修改文件配置（永久生效）：修改配置文件 maxmemory 字段，单位为字节</p></li><li><p>通过命令修改（重启失效）：</p><ul><li><p><code>config set maxmemory 104857600</code>：设置 Redis 最大占用内存为 100MB</p></li><li><p><code>config get maxmemory</code>：获取 Redis 最大占用内存</p></li><li><p><code>info</code> ：可以查看 Redis 内存使用情况，<code>used_memory_human</code> 字段表示实际已经占用的内存，<code>maxmemory</code> 表示最大占用内存</p></li></ul></li></ul><p>影响数据淘汰的相关配置如下，配置 conf 文件：</p><ul><li><p>每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据，防止全库扫描，导致严重的性能消耗，降低读写性能</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-samples count</span><br></pre></td></tr></table></figure></li><li><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-policy policy</span><br></pre></td></tr></table></figure><p>数据删除的策略 policy：3 类 8 种</p><p>第一类：检测易失数据（可能会过期的数据集 server.db[i].expires）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">volatile-lru<span class="comment"># 对设置了过期时间的 key 选择最近最久未使用使用的数据淘汰</span></span><br><span class="line">volatile-lfu<span class="comment"># 对设置了过期时间的 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">volatile-ttl<span class="comment"># 对设置了过期时间的 key 选择将要过期的数据淘汰</span></span><br><span class="line">volatile-random<span class="comment"># 对设置了过期时间的 key 选择任意数据淘汰</span></span><br></pre></td></tr></table></figure><p>第二类：检测全库数据（所有数据集 server.db[i].dict ）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">allkeys-lru<span class="comment"># 对所有 key 选择最近最少使用的数据淘汰</span></span><br><span class="line">allkeLyRs-lfu<span class="comment"># 对所有 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">allkeys-random<span class="comment"># 对所有 key 选择任意数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure><p>第三类：放弃数据驱逐</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">no-enviction<span class="comment">#禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)</span></span><br></pre></td></tr></table></figure></li></ul><p>数据淘汰策略配置依据：使用 INFO 命令输出监控信息，查询缓存 hit 和 miss 的次数，根据需求调优 Redis 配置</p><hr><h3 id="排序机制"><a href="#排序机制" class="headerlink" title="排序机制"></a>排序机制</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的 SORT 命令可以对列表键、集合键或者有序集合键的值进行排序，并不更改集合中的数据位置，只是查询</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT key [ASC/DESC]<span class="comment">#对key中数据排序，默认对数字排序，并不更改集合中的数据位置，只是查询</span></span><br><span class="line">SORT key ALPHA<span class="comment">#对key中字母排序，按照字典序</span></span><br></pre></td></tr></table></figure><hr><h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h4><p><code>SORT &lt;key&gt;</code> 命令可以对一个包含数字值的键 key 进行排序</p><p>假设 <code>RPUSH numbers 3 1 2</code>，执行 <code>SORT numbers</code> 的详细步骤：</p><ul><li><p>创建一个和 key 列表长度相同的数组，数组每项都是 redisSortObject 结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisSortObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被排序键的值</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 权重</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// 排序数字值时使用</span></span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line">        <span class="comment">// 排序带有 BY 选项的字符串</span></span><br><span class="line">        robj *cmpobj;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历数组，将各个数组项的 obj 指针分别指向 numbers 列表的各个项</p></li><li><p>遍历数组，将 obj 指针所指向的列表项转换成一个 double 类型的浮点数，并将浮点数保存在对应数组项的 u.score 属性里</p></li><li><p>根据数组项 u.score 属性的值，对数组进行数字值排序，排序后的数组项按 u.score 属性的值<strong>从小到大排列</strong></p></li><li><p>遍历数组，将各个数组项的 obj 指针所指向的值作为排序结果返回给客户端，程序首先访问数组的索引 0，依次向后访问</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-sort%E6%8E%92%E5%BA%8F.png"></p><p>对于 <code>SORT key [ASC/DESC]</code> 函数：</p><ul><li>在执行升序排序时，排序算法使用的对比函数产生升序对比结果</li><li>在执行降序排序时，排序算法使用的对比函数产生降序对比结果</li></ul><hr><h4 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h4><p>SORT 命令默认使用被排序键中包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置，通过使用 BY 选项，SORT 命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt;<span class="comment"># 数值</span></span><br><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt; ALPHA<span class="comment"># 字符</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD fruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span> </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1)<span class="string">&quot;apple&quot;</span></span><br><span class="line">2)<span class="string">&quot;banana&quot;</span></span><br><span class="line">3)<span class="string">&quot;cherry&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MSET apple-price 8 banana-price 5.5 cherry-price 7 </span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 使用水果的价钱进行排序</span></span><br><span class="line">redis&gt; SORT fruits BY *-price</span><br><span class="line">1)<span class="string">&quot;banana&quot;</span></span><br><span class="line">2)<span class="string">&quot;cherry&quot;</span></span><br><span class="line">3)<span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure><p>实现原理：排序时的 u.score 属性就会被设置为对应的权重</p><hr><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>SORT 命令默认会将排序后的所有元素都返回给客户端，通过 LIMIT 选项可以让 SORT 命令只返回其中一部分已排序的元素</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure><ul><li>offset 参数表示要跳过的已排序元素数量</li><li>count 参数表示跳过给定数量的元素后，要返回的已排序元素数量</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对应 a b c d e f  g</span></span><br><span class="line">redis&gt; SORT alphabet ALPHA LIMIT 2 3</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure><p>实现原理：在排序后的 redisSortObject 结构数组中，将指针移动到数组的索引 2 上，依次访问 array[2]、array[3]、array[4] 这 3 个数组项，并将数组项的 obj 指针所指向的元素返回给客户端</p><hr><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>SORT 命令默认在对键进行排序后，返回被排序键本身所包含的元素，通过使用 GET 选项， 可以在对键进行排序后，根据被排序的元素以及 GET 选项所指定的模式，查找并返回某些键的值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; GET &lt;pattern&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line"><span class="comment">#设置全名</span></span><br><span class="line">redis&gt; SET tom-name <span class="string">&quot;Tom Li&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET jack-name <span class="string">&quot;Jack Wang&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET sea-name <span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SORT students ALPHA GET *-name</span><br><span class="line">1)<span class="string">&quot;Jack Wang&quot;</span></span><br><span class="line">2)<span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">3) <span class="string">&quot;Tom Li&quot;</span></span><br></pre></td></tr></table></figure><p>实现原理：对 students 进行排序后，对于 jack 元素和 *-name 模式，查找程序返回键 jack-name，然后获取 jack-name 键对应的值</p><hr><h4 id="STORE"><a href="#STORE" class="headerlink" title="STORE"></a>STORE</h4><p>SORT 命令默认只向客户端返回排序结果，而不保存排序结果，通过使用 STORE 选项可以将排序结果保存在指定的键里面</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; STORE &lt;sort_key&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">redis&gt; SORT students ALPHA STORE sorted_students </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br></pre></td></tr></table></figure><p>实现原理：排序后，检查 sorted_students 键是否存在，如果存在就删除该键，设置 sorted_students 为空白的列表键，遍历排序数组将元素依次放入</p><hr><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>调用 SORT 命令，除了 GET 选项之外，改变其他选项的摆放顺序并不会影响命令执行选项的顺序</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA [ASC/DESC] BY &lt;by-pattern&gt; LIMIT &lt;offset&gt; &lt;count&gt; GET &lt;get-pattern&gt; STORE &lt;store_key&gt;</span><br></pre></td></tr></table></figure><p>执行顺序：</p><ul><li>排序：命令会使用 ALPHA 、ASC 或 DESC、BY 这几个选项，对输入键进行排序，并得到一个排序结果集</li><li>限制排序结果集的长度：使用 LIMIT 选项，对排序结果集的长度进行限制</li><li>获取外部键：根据排序结果集中的元素以及 GET 选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集</li><li>保存排序结果集：使用 STORE 选项，将排序结果集保存到指定的键上面去</li><li>向客户端返回排序结果集：最后一步命令遍历排序结果集，并依次向客户端返回排序结果集中的元素</li></ul><hr><h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p>数据库通知是可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况</p><ul><li>关注某个键执行了什么命令的通知称为键空间通知（key-space notification）</li><li>关注某个命令被什么键执行的通知称为键事件通知（key-event notification）</li></ul><p>图示订阅 0 号数据库 message 键：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-数据库通知.png" style="zoom: 67%;"><p>服务器配置的 notify-keyspace-events 选项决定了服务器所发送通知的类型</p><ul><li>AKE 代表服务器发送所有类型的键空间通知和键事件通知</li><li>AK 代表服务器发送所有类型的键空间通知</li><li>AE 代表服务器发送所有类型的键事件通知</li><li>K$ 代表服务器只发送和字符串键有关的键空间通知</li><li>EL 代表服务器只发送和列表键有关的键事件通知</li><li>…..</li></ul><p>发送数据库通知的功能是由 notifyKeyspaceEvent 函数实现的：</p><ul><li>如果给定的通知类型 type 不是服务器允许发送的通知类型，那么函数会直接返回</li><li>如果给定的通知是服务器允许发送的通知<ul><li>检测服务器是否允许发送键空间通知，允许就会构建并发送事件通知</li><li>检测服务器是否允许发送键事件通知，允许就会构建并发送事件通知</li></ul></li></ul><hr><h2 id="体系架构-1"><a href="#体系架构-1" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件</p><ul><li>文件事件 (file event)：服务器通过套接字与客户端（或其他 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列网络通信操作</li><li>时间事件 (time event)：Redis 服务器中的一些操作（比如 serverCron 函数）需要在指定时间执行，而时间事件就是服务器对这类定时操作的抽象</li></ul><hr><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><h5 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h5><p>Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器被称为文件事件处理器 (file event handler)</p><ul><li><p>使用 I&#x2F;O 多路复用 (multiplexing) 程序来同时监听多个套接字，并根据套接字执行的任务来为套接字关联不同的事件处理器</p></li><li><p>当被监听的套接字准备好执行连接应答 (accept)、 读取 (read)、 写入 (write)、 关闭 (close) 等操作时，与操作相对应的文件事件就会产生，这时文件事件分派器会调用套接字关联好的事件处理器来处理事件</p></li></ul><p>文件事件处理器<strong>以单线程方式运行</strong>，但通过使用  I&#x2F;O 多路复用程序来监听多个套接字， 既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，保持了 Redis 内部单线程设计的简单性</p><p>文件事件处理器的组成结构：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-文件事件处理器.png" style="zoom:80%;"><p>I&#x2F;O 多路复用程序将所有产生事件的套接字处理请求放入一个<strong>单线程的执行队列</strong>中，通过队列有序、同步的向文件事件分派器传送套接字，上一个套接字产生的事件处理完后，才会继续向分派器传送下一个</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-IO多路复用程序.png" style="zoom: 67%;"><p>Redis 单线程也能高效的原因：</p><ul><li>纯内存操作</li><li>核心是基于非阻塞的 IO 多路复用机制，单线程可以高效处理多个请求</li><li>底层使用 C 语言实现，C 语言实现的程序距离操作系统更近，执行速度相对会更快</li><li>单线程同时也<strong>避免了多线程的上下文频繁切换问题</strong>，预防了多线程可能产生的竞争问题</li></ul><hr><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>Redis 的 I&#x2F;O 多路复用程序的所有功能都是通过包装常见的 select 、epoll、 evport 和 kqueue 这些函数库来实现的，Redis 在 I&#x2F;O 多路复用程序的实现源码中用 #include 宏定义了相应的规则，编译时自动选择系统中<strong>性能最高的多路复用函数</strong>来作为底层实现</p><p>I&#x2F;O 多路复用程序监听多个套接字的 AE_READABLE 事件和 AE_WRITABLE 事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得<strong>可读</strong>时（客户端对套接字执行 write 操作或者 close 操作），或者有新的<strong>可应答</strong>（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 连接操作），套接字产生 AE_READABLE 事件</li><li>当套接字变得可写时（客户端对套接字执行 read 操作，对于服务器来说就是可以写了），套接字产生 AE_WRITABLE 事件</li></ul><p>I&#x2F;O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理 AE_READABLE  事件， 等 AE_READABLE 事件处理完之后才处理 AE_WRITABLE 事件</p><hr><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>Redis 为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求：</p><ul><li>连接应答处理器，用于对连接服务器的各个客户端进行应答，Redis 服务器初始化时将该处理器与 AE_READABLE 事件关联</li><li>命令请求处理器，用于接收客户端传来的命令请求，执行套接字的读入操作，与 AE_READABLE 事件关联</li><li>命令回复处理器，用于向客户端返回命令的执行结果，执行套接字的写入操作，与 AE_WRITABLE 事件关联</li><li>复制处理器，当主服务器和从服务器进行复制操作时，主从服务器都需要关联该处理器</li></ul><p>Redis 客户端与服务器进行连接并发送命令的整个过程：</p><ul><li>Redis 服务器正在运作监听套接字的 AE_READABLE 事件，关联连接应答处理器</li><li>当 Redis 客户端向服务器发起连接，监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行，对客户端的连接请求进行应答，创建客户端套接字以及客户端状态，并将客户端套接字的 <strong>AE_READABLE 事件与命令请求处理器</strong>进行关联</li><li>客户端向服务器发送命令请求，客户端套接字产生 AE_READABLE 事件，引发命令请求处理器执行，读取客户端的命令内容传给相关程序去执行</li><li>执行命令会产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的 <strong>AE_WRITABLE 事件与命令回复处理器</strong>进行关联</li><li>当客户端尝试读取命令回复时，客户端套接字产生 AE_WRITABLE 事件，触发命令回复处理器执行，在命令回复全部写入套接字后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联</li></ul><hr><h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：在指定的时间之后执行一次（Redis 中暂时未使用）</li><li>周期事件：每隔指定时间就执行一次</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一 ID（标识号），从小到大顺序递增，新事件的 ID 比旧事件的 ID 号要大</li><li>when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达（arrive）时间</li><li>timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理事件</li></ul><p>时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>定时事件：事件处理器返回 AE_NOMORE，该事件在到达一次后就会被删除</li><li>周期事件：事件处理器返回非 AE_NOMORE 的整数值，服务器根据该值对事件的 when 属性更新，让该事件在一段时间后再次交付</li></ul><p>服务器将所有时间事件都放在一个<strong>无序链表</strong>中，新的时间事件插入到链表的表头：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-时间事件.png" style="zoom:67%;"><p>无序链表指是链表不按 when 属性的大小排序，每当时间事件执行器运行时就必须遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器处理</p><p>无序链表并不影响时间事件处理器的性能，因为正常模式下的 Redis 服务器<strong>只使用 serverCron 一个时间事件</strong>，在 benchmark 模式下服务器也只使用两个时间事件，所以无序链表不会影响服务器的性能，几乎可以按照一个指针处理</p><hr><h4 id="事件调度"><a href="#事件调度" class="headerlink" title="事件调度"></a>事件调度</h4><p>服务器中同时存在文件事件和时间事件两种事件类型，调度伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事件调度伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aeProcessEvents</span>():</span><br><span class="line"><span class="comment"># 获取到达时间离当前时间最接近的时间事件 </span></span><br><span class="line">    time_event = aeSearchNearestTime()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少亳秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval 结构</span></span><br><span class="line">timeval = create_timeval_with_ms(remaind_ms) </span><br><span class="line">    <span class="comment"># 【阻塞并等待文件事件】产生，最大阻塞时间由传入的timeval结构决定，remaind_ms的值为0时调用后马上返回，不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">processFileEvents() </span><br><span class="line"><span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">processTimeEvents()</span><br></pre></td></tr></table></figure><p>事件的调度和执行规则：</p><ul><li>aeApiPoll 函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保 aeApiPoll 函数不会阻塞过长时间</li><li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>，服务器不会中途中断事件处理，也不会对事件进行抢占，所以两种处理器都要尽可地减少程序的阻塞时间，并在有需要时<strong>主动让出执行权</strong>，从而降低事件饥饿的可能性<ul><li>命令回复处理器在写入字节数超过了某个预设常量，就会主动用 break 跳出写入循环，将余下的数据留到下次再写</li><li>时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行</li></ul></li><li>时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间通常会比设定的到达时间稍晚</li></ul><hr><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这是 Redis 的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络），多线程只是用来<strong>处理网络数据的读写和协议解析</strong>， 执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>开启多线程后，还需要设置线程数，否则是不生效的，同样需要修改 redis 配置文件 :</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-多线程.png" style="zoom:80%;"><p>参考文章：<a href="https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA">https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA</a></p><hr><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是典型的一对多程序，一个服务器可以与多个客户端建立网络连接，服务器对每个连接的客户端建立了相应的 redisClient 结构（客户端状态，<strong>在服务器端的存储结构</strong>），保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构</p><p>Redis 服务器状态结构的 clients 属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p><hr><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="redisClient"><a href="#redisClient" class="headerlink" title="redisClient"></a>redisClient</h5><p>客户端的数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">// 输出缓冲区 buf 数组</span></span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">// 记录了 buf 数组目前已使用的字节数量</span></span><br><span class="line">    <span class="type">int</span> bufpos; </span><br><span class="line">    <span class="comment">// 可变大小的输出缓冲区，链表 + 字符串对象</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令数组</span></span><br><span class="line">    rboj **argv;</span><br><span class="line">    <span class="comment">// 命令数组的长度</span></span><br><span class="line">   <span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// 命令的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span>  *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否通过身份验证</span></span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建客户端的时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;</span><br><span class="line">    <span class="comment">// 客户端与服务器最后一次进行交互的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">// 输出缓冲区第一次到达软性限制 (soft limit) 的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端状态包括两类属性</p><ul><li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，都要用到这些属性</li><li>另一类是和特定功能相关的属性，比如操作数据库时用到的 db 属性和 dict id 属性，执行事务时用到的 mstate 属性，以及执行 WATCH 命令时用到的 watched_keys 属性等，代码中没有列出</li></ul><hr><h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>客户端状态的 fd 属性记录了客户端正在使用的套接字描述符，根据客户端类型的不同，fd 属性的值可以是 -1 或者大于 -1 的整数：</p><ul><li>伪客户端 (fake client) 的 fd 属性的值为 -1，命令请求来源于 AOF 文件或者 Lua 脚本，而不是网络，所以不需要套接字连接</li><li>普通客户端的 fd 属性的值为大于 -1 的整数，因为合法的套接字描述符不能是 -1</li></ul><p>执行 <code>CLIENT list</code> 命令可以列出目前所有连接到服务器的普通客户端，不包括伪客户端</p><hr><h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 命令可以为客户端设置一个名字</p><hr><h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性 flags 记录了客户端的角色以及客户端目前所处的状态，每个标志使用一个常量表示</p><ul><li>flags 的值可以是单个标志：<code>flags = &lt;flag&gt; </code></li><li>flags 的值可以是多个标志的二进制：<code>flags = &lt;flagl&gt; | &lt;flag2&gt; | ... </code></li></ul><p>一部分标志记录<strong>客户端的角色</strong>：</p><ul><li>REDIS_MASTER 表示客户端是一个从服务器，REDIS_SLAVE 表示客户端是一个从服务器，在主从复制时使用</li><li>REDIS_PRE_PSYNC 表示客户端是一个版本低于 Redis2.8 的从服务器，主服务器不能使用 PSYNC 命令与该从服务器进行同步，这个标志只能在 REDIS_ SLAVE 标志处于打开状态时使用</li><li>REDIS_LUA_CLIENT 表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端</li></ul><p>一部分标志记录目前<strong>客户端所处的状态</strong>：</p><ul><li>REDIS_UNIX_SOCKET 表示服务器使用 UNIX 套接字来连接客户端</li><li>REDIS_BLOCKED 表示客户端正在被 BRPOP、BLPOP 等命令阻塞</li><li>REDIS_UNBLOCKED 表示客户端已经从 REDIS_BLOCKED 所表示的阻塞状态脱离，在 REDIS_BLOCKED 标志打开的情况下使用</li><li>REDIS_MULTI 标志表示客户端正在执行事务</li><li>REDIS_DIRTY_CAS 表示事务使用 WATCH 命令监视的数据库键已经被修改</li><li>…..</li></ul><hr><h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求，输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但最大大小不能超过 1GB，否则服务器将关闭这个客户端，比如执行 <code>SET key value </code>，那么缓冲区 querybuf 的内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nkey\r\n<span class="variable">$5</span>\r\nvalue\r\n <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>输出缓冲区是服务器用于保存执行客户端命令所得的命令回复，每个客户端都有两个输出缓冲区可用：</p><ul><li>一个是固定大小的缓冲区，保存长度比较小的回复，比如 OK、简短的字符串值、整数值、错误回复等</li><li>一个是可变大小的缓冲区，保存那些长度比较大的回复， 比如一个非常长的字符串值或者一个包含了很多元素的集合等</li></ul><p>buf 是一个大小为 REDIS_REPLY_CHUNK_BYTES (常量默认 16*1024 &#x3D; 16KB) 字节的字节数组，bufpos 属性记录了 buf 数组目前已使用的字节数量，当 buf 数组的空间已经用完或者回复数据太大无法放进 buf 数组里，服务器就会开始使用可变大小的缓冲区</p><p>通过使用 reply 链表连接多个字符串对象，可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区 16KB 大小的限制</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%AF%E5%8F%98%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p><hr><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p>服务器对 querybuf 中的命令请求的内容进行分析，得出的命令参数以及参数的数量分别保存到客户端状态的 argv 和 argc 属性</p><ul><li>argv 属性是一个数组，数组中的每项都是字符串对象，其中 argv[0] 是要执行的命令，而之后的其他项则是命令的参数</li><li>argc 属性负责记录 argv 数组的长度</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令数组.png" style="zoom: 67%;"><p>服务器将根据项 argv[0] 的值，在命令表中查找命令所对应的命令的 redisCommand，将客户端状态的 cmd 指向该结构</p><p>命令表是一个字典结构，键是 SDS 结构保存命令的名字；值是命令所对应的 redisCommand 结构，保存了命令的实现函数、命令标志、 命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令查找.png" style="zoom:67%;"><hr><h5 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h5><p>客户端状态的 authenticated 属性用于记录客户端是否通过了身份验证</p><ul><li>authenticated 值为 0，表示客户端未通过身份验证</li><li>authenticated 值为 1，表示客户端已通过身份验证</li></ul><p>当客户端 authenticated &#x3D; 0 时，除了 AUTH 命令之外， 客户端发送的所有其他命令都会被服务器拒绝执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; PING </span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">redis&gt; AUTH 123321 </span><br><span class="line">OK</span><br><span class="line">redis&gt; PING </span><br><span class="line">PONG </span><br></pre></td></tr></table></figure><hr><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>ctime 属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，<code>CLIENT list</code> 命令的 age 域记录了这个秒数</p><p>lastinteraction 属性记录了客户端与服务器最后一次进行互动 (interaction) 的时间，互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。该属性可以用来计算客户端的空转 (idle) 时长， 就是距离客户端与服务器最后一次进行互动已经过去了多少秒，<code>CLIENT list</code> 命令的 idle 域记录了这个秒数</p><p>obuf_soft_limit_reached_time 属性记录了<strong>输出缓冲区第一次到达软性限制</strong> (soft limit) 的时间</p><hr><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>服务器使用不同的方式来创建和关闭不同类型的客户端</p><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用 connect 函数连接到服务器时，服务器就会调用连接应答处理器为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p><p>服务器会在初始化时创建负责执行 Lua 脚本中包含的 Redis 命令的伪客户端，并将伪客户端关联在服务器状态的 lua_client 属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存伪客户端</span></span><br><span class="line">    redisClient *lua_client；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lua_client 伪客户端在服务器运行的整个生命周期会一直存在，只有服务器被关闭时，这个客户端才会被关闭</p><p>载入 AOF 文件时， 服务器会创建用于执行 AOF 文件包含的 Redis 命令的伪客户端，并在载入完成之后，关闭这个伪客户端</p><hr><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>一个普通客户端可以因为多种原因而被关闭：</p><ul><li>客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭</li><li>客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端会<strong>被服务器关闭</strong></li><li>客户端是 <code>CLIENT KILL</code> 命令的目标</li><li>如果用户为服务器设置了 timeout 配置选项，那么当客户端的空转时间超过该值时将被关闭，特殊情况不会被关闭：<ul><li>客户端是主服务器（REDIS_MASTER ）或者从服务器（打开了 REDIS_SLAVE 标志）</li><li>正在被 BLPOP 等命令阻塞（REDIS_BLOCKED）</li><li>正在执行 SUBSCRIBE、PSUBSCRIBE 等订阅命令</li></ul></li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为 1GB）</li><li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li></ul><p>理论上来说，可变缓冲区可以保存任意长的命令回复，但是为了回复过大占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作：</p><ul><li>硬性限制 (hard limit)：输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器会关闭客户端（serverCron 函数中执行），积存在输出缓冲区中的所有内容会被<strong>直接释放</strong>，不会返回给客户端</li><li>软性限制 (soft limit)：输出缓冲区的大小超过了软性限制所设置的大小，小于硬性限制的大小，服务器的操作：<ul><li>用属性 obuf_soft_limit_reached_time 记录下客户端到达软性限制的起始时间，继续监视客户端</li><li>如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端</li><li>如果在指定时间内不再超出软性限制，那么客户端就不会被关闭，并且 o_s_l_r_t 属性清零</li></ul></li></ul><p>使用 client-output-buffer-limit 选项可以为普通客户端、从服务器客户端、执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制，格式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard <span class="built_in">limit</span>&gt; &lt;soft <span class="built_in">limit</span>&gt; &lt;soft seconds&gt;</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0 </span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60 </span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure><ul><li>第一行：将普通客户端的硬性限制和软性限制都设置为 0，表示不限制客户端的输出缓冲区大小</li><li>第二行：将从服务器客户端的硬性限制设置为 256MB，软性限制设置为 64MB，软性限制的时长为 60 秒</li><li>第三行：将执行发布与订阅功能的客户端的硬性限制设置为 32MB，软性限制设置为 8MB，软性限制的时长为 60 秒</li></ul><hr><h3 id="服务器-2"><a href="#服务器-2" class="headerlink" title="服务器"></a>服务器</h3><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>Redis 服务器与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转，所以一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作</p><h5 id="命令请求"><a href="#命令请求" class="headerlink" title="命令请求"></a>命令请求</h5><p>Redis 服务器的命令请求来自 Redis 客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SET KEY VALUE -&gt;<span class="comment"># 命令</span></span><br><span class="line">*3\r\nS3\r\nSET\r\n<span class="variable">$3</span>\r\nKEY\r\n<span class="variable">$5</span>\r\nVALUE\r\n<span class="comment"># 协议格式</span></span><br></pre></td></tr></table></figure><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读，服务器调用<strong>命令请求处理器</strong>来执行以下操作：</p><ul><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里</li><li>调用命令执行器，执行客户端指定的命令</li></ul><p>最后客户端接收到协议格式的命令回复之后，会将这些回复转换成用户可读的格式打印给用户观看，至此整体流程结束</p><hr><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>命令执行器开始对命令操作：</p><ul><li><p>查找命令：首先根据客户端状态的 argv[0] 参数，在<strong>命令表 (command table)</strong> 中查找参数所指定的命令，并将找到的命令保存到客户端状态的 cmd 属性里面，是一个 redisCommand 结构</p><p>命令查找算法与字母的大小写无关，所以命令名字的大小写不影响命令表的查找结果</p></li><li><p>执行预备操作：</p><ul><li>检查客户端状态的 cmd 指针是否指向 NULL，根据 redisCommand 检查请求参数的数量是否正确</li><li>检查客户端是否通过身份验证</li><li>如果服务器打开了 maxmemory 功能，执行命令之前要先检查服务器的内存占用，在有需要时进行内存回收（<strong>逐出算法</strong>）</li><li>如果服务器上一次执行 BGSAVE 命令出错，并且服务器打开了 stop-writes-on-bgsave-error 功能，那么如果本次执行的是写命令，服务会拒绝执行，并返回错误</li><li>如果客户端当前正在用 SUBSCRIBE 或 PSUBSCRIBE 命令订阅频道，那么服务器会拒绝除了 SUBSCRIBE、SUBSCRIBE、 UNSUBSCRIBE、PUNSUBSCRIBE 之外的其他命令</li><li>如果服务器正在进行载入数据，只有 sflags 带有 1 标识（比如 INFO、SHUTDOWN、PUBLISH等）的命令才会被执行</li><li>如果服务器执行 Lua 脚本而超时并进入阻塞状态，那么只会执行客户端发来的 SHUTDOWN nosave 和 SCRIPT KILL 命令</li><li>如果客户端正在执行事务，那么服务器只会执行客户端发来的 EXEC、DISCARD、MULTI、WATCH 四个命令，其他命令都会被<strong>放进事务队列</strong>中</li><li>如果服务器打开了监视器功能，那么会将要执行的命令和参数等信息发送给监视器</li></ul></li><li><p>调用命令的实现函数：被调用的函数会执行指定的操作并产生相应的命令回复，回复会被保存在客户端状态的输出缓冲区里面（buf 和 reply 属性），然后实现函数还会<strong>为客户端的套接字关联命令回复处理器</strong>，这个处理器负责将命令回复返回给客户端</p></li><li><p>执行后续工作：</p><ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志</li><li>根据执行命令所耗费的时长，更新命令的 redisCommand 结构的 milliseconds 属性，并将命令 calls 计数器的值增一</li><li>如果服务器开启了 AOF 持久化功能，那么 AOF 持久化模块会将执行的命令请求写入到 AOF 缓冲区里面</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将执行的命令传播给所有从服务器</li></ul></li><li><p>将命令回复发送给客户端：客户端<strong>套接字变为可写状态</strong>时，服务器就会执行命令回复处理器，将客户端输出缓冲区中的命令回复发送给客户端，发送完毕之后回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备</p></li></ul><hr><h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>每个 redisCommand 结构记录了一个Redis 命令的实现信息，主要属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 命令的名字，比如&quot;set&quot;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数指针，指向命令的实现函数，比如setCommand</span></span><br><span class="line">    <span class="comment">// redisCommandProc 类型的定义为 typedef void redisCommandProc(redisClient *c)</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令参数的个数，用于检查命令请求的格式是否正确。如果这个值为负数-N, 那么表示参数的数量大于等于N。</span></span><br><span class="line">    <span class="comment">// 注意命令的名字本身也是一个参数，比如 SET msg &quot;hello&quot;，命令的参数是&quot;SET&quot;、&quot;msg&quot;、&quot;hello&quot; 三个</span></span><br><span class="line"><span class="type">int</span> arity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串形式的标识值，这个值记录了命令的属性，，</span></span><br><span class="line">    <span class="comment">// 比如这个命令是写命令还是读命令，这个命令是否允许在载入数据时使用，是否允许在Lua脚本中使用等等</span></span><br><span class="line">    <span class="type">char</span> *sflags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对sflags标识进行分析得出的二进制标识，由程序自动生成。服务器对命令标识进行检查时使用的都是 flags 属性</span></span><br><span class="line">    <span class="comment">// 而不是sflags属性，因为对二进制标识的检查可以方便地通过&amp; ^ ~ 等操作来完成</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器总共执行了多少次这个命令</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> calls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器执行这个命令所耗费的总时长</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> milliseconds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="serverCron"><a href="#serverCron" class="headerlink" title="serverCron"></a>serverCron</h4><h5 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Redis 服务器以周期性事件的方式来运行 serverCron 函数，服务器初始化时读取配置 server.hz 的值，默认为 10，代表每秒钟执行 10 次，即<strong>每隔 100 毫秒执行一次</strong>，执行指令 info server 可以查看</p><p>serverCron 函数负责定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、 数据库占用情况等</li><li>清理数据库中的过期键值对</li><li>关闭和清理连接失效的客户端</li><li>进行 AOF 或 RDB 持久化操作</li><li>如果服务器是主服务器，那么对从服务器进行定期同步</li><li>如果处于集群模式，对集群进行定期同步和连接测试</li></ul><hr><h5 id="时间缓存"><a href="#时间缓存" class="headerlink" title="时间缓存"></a>时间缓存</h5><p>Redis 服务器中有很多功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的 unixtime 属性和 mstime 属性被用作当前时间的缓存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> unixtime;</span><br><span class="line"><span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>serverCron 函数默认以每 100 毫秒一次的频率更新两个属性，所以属性记录的时间的精确度并不高</p><ul><li>服务器只会在打印日志、更新服务器的 LRU 时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上</li><li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间</li></ul><hr><h5 id="LRU-时钟"><a href="#LRU-时钟" class="headerlink" title="LRU 时钟"></a>LRU 时钟</h5><p>服务器状态中的 lruclock 属性保存了服务器的 LRU 时钟</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，用于计算键的空转(idle)时长。 </span></span><br><span class="line">    <span class="type">unsigned</span> lruclock:<span class="number">22</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 Redis 对象都会有一个 lru 属性， 这个 lru 属性保存了对象最后一次被命令访问的时间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>当服务器要计算一个数据库键的空转时间（即数据库键对应的值对象的空转时间），程序会用服务器的 lruclock 属性记录的时间减去对象的 lru 属性记录的时间</p><p>serverCron 函数默认以每 100 毫秒一次的频率更新这个属性，所以得出的空转时间也是模糊的</p><hr><h5 id="命令次数"><a href="#命令次数" class="headerlink" title="命令次数"></a>命令次数</h5><p>serverCron 中的 trackOperationsPerSecond 函数以每 100 毫秒一次的频率执行，函数功能是以<strong>抽样计算</strong>的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过 INFO status 命令的 instantaneous_ops_per_sec 域查看：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO stats</span><br><span class="line"><span class="comment"># Stats </span></span><br><span class="line">instantaneous_ops_per_sec:6</span><br></pre></td></tr></table></figure><p>根据上一次抽样时间 ops_sec_last_sample_time 和当前系统时间，以及上一次已执行的命令数 ops_sec_last_sample_ops 和服务器当前已经执行的命令数，计算出两次函数调用期间，服务器平均每毫秒处理了多少个命令请求，该值乘以 1000 得到每秒内的执行命令的估计值，放入 ops_sec_samples 环形数组里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上一次进行抽样的时间</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">// 上一次抽样时，服务器已执行命令的数量 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">// REDIS_OPS_SEC_SAMPLES 大小（默认值为16)的环形数组，数组的每一项记录一次的抽样结果</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">// ops_sec_samples数组的索引值，每次抽样后将值自增一，值为16时重置为0，让数组成为一个环形数组</span></span><br><span class="line">    <span class="type">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h5 id="内存峰值"><a href="#内存峰值" class="headerlink" title="内存峰值"></a>内存峰值</h5><p>服务器状态里的 stat_peak_memory 属性记录了服务器内存峰值大小，循环函数每次执行时都会查看服务器当前使用的内存数量，并与 stat_peak_memory 保存的数值进行比较，设置为较大的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="type">size_t</span> stat_peak_memory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>INFO memory 命令的 used_memory_peak 和 used_memory_peak_human 两个域分别以两种格式记录了服务器的内存峰值：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">...</span><br><span class="line">used_memory_peak:501824 </span><br><span class="line">used_memory_peak_human:490.06K</span><br></pre></td></tr></table></figure><hr><h5 id="SIGTERM"><a href="#SIGTERM" class="headerlink" title="SIGTERM"></a>SIGTERM</h5><p>服务器启动时，Redis 会为服务器进程的 SIGTERM 信号关联处理器 sigtermHandler 函数，该信号处理器负责在服务器接到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 关闭服务器的标识：值为1时关闭服务器，值为0时不做操作</span></span><br><span class="line">    <span class="type">int</span> shutdown_asap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次 serverCron 函数运行时，程序都会对服务器状态的 shutdown_asap 属性进行检查，并根据属性的值决定是否关闭服务器</p><p>服务器在接到 SIGTERM 信号之后，关闭服务器并打印相关日志的过程：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[6794 | signal handler] (1384435690) Received SIGTERM, scheduling shutdown ... </span><br><span class="line">[6794] 14 Nov 21:28:10.108 <span class="comment"># User requested shutdown ... </span></span><br><span class="line">[6794] 14 Nov 21:28:10.108 * Saving the final RDB snapshot before exiting. </span><br><span class="line">[6794) 14 Nov 21:28:10.161 * DB saved on disk </span><br><span class="line">[6794) 14 Nov 21:28:10.161 <span class="comment"># Redisis now ready to exit, bye bye ... </span></span><br></pre></td></tr></table></figure><hr><h5 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h5><p>serverCron 函数每次执行都会调用 clientsCron 和 databasesCron 函数，进行管理客户端资源和数据库资源</p><p>clientsCron 函数对一定数量的客户端进行以下两个检查：</p><ul><li>如果客户端与服务器之间的连接巳经超时（很长一段时间客户端和服务器都没有互动），那么程序释放这个客户端</li><li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li></ul><p>databasesCron 函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时对字典进行收缩操作</p><hr><h5 id="持久状态"><a href="#持久状态" class="headerlink" title="持久状态"></a>持久状态</h5><p>服务器状态中记录执行 BGSAVE 命令和 BGREWRITEAOF 命令的子进程的 ID</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID，如果服务器没有在执行BGSAVE，那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID，如果服务器没有在执行那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> aof_child_pid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>serverCron 函数执行时，会检查两个属性的值，只要其中一个属性的值不为 -1，程序就会执行一次 wait3 函数，检查子进程是否有信号发来服务器进程：</p><ul><li>如果有信号到达，那么表示新的 RDB 文件已经生成或者 AOF 重写完毕，服务器需要进行相应命令的后续操作，比如用新的 RDB 文件替换现有的 RDB 文件，用重写后的 AOF 文件替换现有的 AOF 文件</li><li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作</li></ul><p>如果两个属性的值都为 -1，表示服务器没有进行持久化操作</p><ul><li><p>查看是否有 BGREWRITEAOF 被延迟，然后执行 AOF 后台重写</p></li><li><p>查看服务器的自动保存条件是否已经被满足，并且服务器没有在进行持久化，就开始一次新的 BGSAVE 操作</p><p>因为条件 1 可能会引发一次 AOF，所以在这个检查中会再次确认服务器是否已经在执行持久化操作</p></li><li><p>检查服务器设置的 AOF 重写条件是否满足，条件满足并且服务器没有进行持久化，就进行一次 AOF 重写</p></li></ul><p>如果服务器开启了 AOF 持久化功能，并且 AOF 缓冲区里还有待写入的数据， 那么 serverCron 函数会调用相应的程序，将 AOF 缓冲区中的内容写入到 AOF 文件里</p><hr><h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>在服务器执行 BGSAVE 命令的期间，如果客户端发送 BGREWRITEAOF 命令，那么服务器会将 BGREWRITEAOF 命令的执行时间延迟到 BGSAVE 命令执行完毕之后，用服务器状态的 aof_rewrite_scheduled 属性标识延迟与否</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果值为1，那么表示有 BGREWRITEAOF命令被延迟了</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_scheduled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>serverCron 函数会检查 BGSAVE 或者 BGREWRITEAOF 命令是否正在执行，如果这两个命令都没在执行，并且 aof_rewrite_scheduled 属性的值为 1，那么服务器就会执行之前被推延的 BGREWRITEAOF 命令</p><hr><h5 id="执行次数"><a href="#执行次数" class="headerlink" title="执行次数"></a>执行次数</h5><p>服务器状态的 cronloops 属性记录了 serverCron 函数执行的次数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// serverCron 函数每执行一次，这个属性的值就增 1</span></span><br><span class="line">    <span class="type">int</span> cronloops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h5 id="缓冲限制"><a href="#缓冲限制" class="headerlink" title="缓冲限制"></a>缓冲限制</h5><p>服务器会关闭那些输入或者输出<strong>缓冲区大小超出限制</strong>的客户端</p><hr><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h5><p>一个 Redis 服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程</p><p>第一步：创建一个 redisServer 类型的实例变量 server 作为服务器的状态，并为结构中的各个属性设置默认值，由 initServerConfig 函数进行初始化一般属性：</p><ul><li>设置服务器的运行 ID、默认运行频率、默认配置文件路径、默认端口号、默认 RDB 持久化条件和 AOF 持久化条件</li><li>初始化服务器的 LRU 时钟，创建命令表</li></ul><p>第二步：载入配置选项，用户可以通过给定配置参数或者指定配置文件，对 server 变量相关属性的默认值进行修改</p><p>第三步：初始化服务器数据结构（除了命令表之外），因为服务器<strong>必须先载入用户指定的配置选项才能正确地对数据结构进行初始化</strong>，所以载入配置完成后才进性数据结构的初始化，服务器将调用 initServer 函数：</p><ul><li>server.clients 链表，记录了的客户端的状态结构；server.db 数组，包含了服务器的所有数据库</li><li>用于保存频道订阅信息的 server.pubsub_channels 字典， 以及保存模式订阅信息的 server.pubsub_patterns 链表</li><li>用于执行 Lua 脚本的 Lua 环境 server.lua </li><li>保存慢查询日志的 server.slowlog 属性</li></ul><p>initServer 还进行了非常重要的设置操作：</p><ul><li>为服务器设置进程信号处理器</li><li>创建共享对象，包含 OK、ERR、<strong>整数 1 到 10000 的字符串对象</strong>等</li><li><strong>打开服务器的监听端口</strong></li><li><strong>为 serverCron 函数创建时间事件</strong>， 等待服务器正式运行时执行 serverCron 函数</li><li>如果 AOF 持久化功能已经打开，那么打开现有的 AOF 文件，如果 AOF 文件不存在，那么创建并打开一个新的 AOF 文件 ，为 AOF 写入做好准备</li><li><strong>初始化服务器的后台 I&#x2F;O 模块</strong>（BIO）, 为将来的 I&#x2F;O 操作做好准备</li></ul><p>当 initServer 函数执行完毕之后， 服务器将用 ASCII 字符在日志中打印出 Redis 的图标， 以及 Redis 的版本号信息</p><hr><h5 id="还原状态"><a href="#还原状态" class="headerlink" title="还原状态"></a>还原状态</h5><p>在完成了对服务器状态的初始化之后，服务器需要载入RDB文件或者AOF 文件， 并根据文件记录的内容来还原服务器的数据库状态：</p><ul><li>如果服务器启用了 AOF 持久化功能，那么服务器使用 AOF 文件来还原数据库状态</li><li>如果服务器没有启用 AOF 持久化功能，那么服务器使用 RDB 文件来还原数据库状态</li></ul><p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7171] 22 Nov 22:43:49.084 * DB loaded from disk: 0.071 seconds </span><br></pre></td></tr></table></figure><hr><h5 id="驱动循环"><a href="#驱动循环" class="headerlink" title="驱动循环"></a>驱动循环</h5><p>在初始化的最后一步，服务器将打印出以下日志，并开始<strong>执行服务器的事件循环</strong>（loop）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">7171</span>] <span class="number">22</span> Nov <span class="number">22</span>:<span class="number">43</span>:<span class="number">49.084</span> * The server is now ready to accept connections on pert <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了</p><hr><h3 id="慢日志-1"><a href="#慢日志-1" class="headerlink" title="慢日志"></a>慢日志</h3><h4 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过产生的日志来监视和优化查询速度</p><p>服务器配置有两个和慢查询日志相关的选项：</p><ul><li>slowlog-log-slower-than 选项指定执行时间超过多少微秒的命令请求会被记录到日志上</li><li>slowlog-max-len 选项指定服务器最多保存多少条慢查询日志</li></ul><p>服务器使用先进先出 FIFO 的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于 slowlog-max-len 选项的值时，在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除</p><p>配置选项可以通过 CONFIG SET option value 命令进行设置</p><p>常用命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SLOWLOG GET [n]<span class="comment"># 查看 n 条服务器保存的慢日志</span></span><br><span class="line">SLOWLOG LEN<span class="comment"># 查看日志数量</span></span><br><span class="line">SLOWLOG RESET<span class="comment"># 清除所有慢查询日志</span></span><br></pre></td></tr></table></figure><hr><h4 id="日志保存"><a href="#日志保存" class="headerlink" title="日志保存"></a>日志保存</h4><p>服务器状态中包含了慢查询日志功能有关的属性：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// 下一条慢查询日志的ID</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> slowlog_entry_id;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 保存了所有慢查询日志的链表</span></span><br><span class="line"><span class="built_in">list</span> *slowlog;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 服务器配置选项的值 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog-<span class="built_in">log</span>-slower-than;</span><br><span class="line"><span class="comment">// 服务器配置选项的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slowlog_entry_id 属性的初始值为 0，每当创建一条新的慢查询日志时，这个属性就会用作新日志的 id 值，之后该属性增一</p><p>slowlog 链表保存了服务器中的所有慢查询日志，链表中的每个节点是一个 slowlogEntry 结构， 代表一条慢查询日志：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">   <span class="comment">// 命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;</span><br><span class="line"><span class="comment">// 执行命令消耗的时间，以微秒为单位 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line"><span class="comment">// 命令与命令参数</span></span><br><span class="line">robj **argv;</span><br><span class="line"><span class="comment">// 命令与命令参数的数量</span></span><br><span class="line"><span class="type">int</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h4><p>在每次执行命令的前后，程序都会记录微秒格式的当前 UNIX 时间戳，两个时间之差就是执行命令所耗费的时长，函数会检查命令的执行时长是否超过 slowlog-log-slower-than 选项所设置：</p><ul><li><p>如果是的话，就为命令创建一个新的日志，并将新日志添加到 slowlog 链表的表头</p></li><li><p>检查慢查询日志的长度是否超过 slowlog-max-len 选项所设置的长度，如果是将多出来的日志从 slowlog 链表中删除掉</p></li><li><p>将 redisServer. slowlog_entry_id 的值增 1</p></li></ul><hr><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>Redis 构建了简单动态字符串（SDS）的数据类型，作为 Redis 的默认字符串表示，包含字符串的键值对在底层都是由 SDS 实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【字节】数组，用于保存字符串（不是字符数组）</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS 遵循 C 字符串<strong>以空字符结尾</strong>的惯例，保存空字符的 1 字节不计算在 len 属性，SDS 会自动为空字符分配额外的 1 字节空间和添加空字符到字符串末尾，所以空字符对于 SDS 的使用者来说是完全透明的</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>常数复杂度获取字符串长度：</p><ul><li>C 字符串不记录自身的长度，获取时需要遍历整个字符串，遇到空字符串为止，时间复杂度为 O(N)</li><li>SDS 获取字符串长度的时间复杂度为 O(1)，设置和更新 SDS 长度由函数底层自动完成</li></ul><p>杜绝缓冲区溢出：</p><ul><li><p>C 字符串调用 strcat 函数拼接字符串时，如果字符串内存不够容纳目标字符串，就会造成缓冲区溢出（Buffer Overflow）</p><p>s1 和 s2 是内存中相邻的字符串，执行 <code>strcat(s1, &quot; Cluster&quot;)</code>（有空格）：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.png"></p></li><li><p>SDS 空间分配策略：当对 SDS 进行修改时，首先检查 SDS 的空间是否满足修改所需的要求， 如果不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后执行实际的修改操作， 避免了缓冲区溢出的问题</p></li></ul><p>二进制安全：</p><ul><li>C 字符串中的字符必须符合某种编码（比如 ASCII）方式，除了字符串末尾以外其他位置不能包含空字符，否则会被误认为是字符串的结尾，所以只能保存文本数据</li><li>SDS 的 API 都是二进制安全的，使用字节数组 buf 保存一系列的二进制数据，<strong>使用 len 属性来判断数据的结尾</strong>，所以可以保存图片、视频、压缩文件等二进制数据</li></ul><p>兼容 C 字符串的函数：SDS 会在为 buf 数组分配空间时多分配一个字节来保存空字符，所以可以重用一部分 C 字符串函数库的函数</p><hr><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>C 字符串<strong>每次</strong>增长或者缩短都会进行一次内存重分配，拼接操作通过重分配扩展底层数组空间，截断操作通过重分配释放不使用的内存空间，防止出现内存泄露</p><p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中 buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节，字节的数量由 free 属性记录</p><p>内存重分配涉及复杂的算法，需要执行<strong>系统调用</strong>，是一个比较耗时的操作，SDS 的两种优化策略：</p><ul><li><p>空间预分配：当 SDS 需要进行空间扩展时，程序不仅会为 SDS 分配修改所必需的空间， 还会为 SDS 分配额外的未使用空间</p><ul><li><p>对 SDS 修改之后，SDS 的长度（len 属性）小于 1MB，程序分配和 len 属性同样大小的未使用空间，此时 len 和 free 相等</p><p>s 为 Redis，执行 <code>sdscat(s, &quot; Cluster&quot;)</code> 后，len 变为 13 字节，所以也分配了 13 字节的 free 空间，总长度变为 27 字节（额外的一字节保存空字符，13 + 13 + 1 &#x3D; 27）</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D.png"></p></li><li><p>对 SDS 修改之后，SDS 的长度大于等于 1MB，程序会分配 1MB 的未使用空间</p></li></ul><p>在扩展 SDS 空间前，API 会先检查 free 空间是否足够，如果足够就无需执行内存重分配，所以通过预分配策略，SDS 将连续增长 N 次字符串所需内存的重分配次数从<strong>必定 N 次降低为最多 N 次</strong></p></li><li><p>惰性空间释放：当 SDS 缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来复用</p><p>SDS 提供了相应的 API 来真正释放 SDS 的未使用空间，所以不用担心空间惰性释放策略造成的内存浪费问题</p></li></ul><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，C 语言并没有内置这种数据结构，所以 Redis 构建了链表数据类型</p><p>链表节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>多个 listNode 通过 prev 和 next 指针组成<strong>双端链表</strong>：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>list 链表结构：提供了表头指针 head 、表尾指针 tail 以及链表长度计数器 len</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> *(*dup) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等</span></span><br><span class="line">    <span class="type">int</span> (*match) (<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>Redis 链表的特性：</p><ul><li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是 O(1)</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点</li><li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的时间复杂度为 O(1)</li><li>带链表长度计数器：使用 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的时间复杂度为 O(1)</li><li>多态：链表节点使用 void * 指针来保存节点值， 并且可以通过 dup、free 、match 三个属性为节点值设置类型特定函数，所以链表可以保存各种<strong>不同类型的值</strong></li></ul><hr><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典使用的哈希表结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组，数组中每个元素指向 dictEntry 结构</span></span><br><span class="line">dictEntry **table;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 哈希表大小，数组的长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 【size-1】</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 该哈希表已有节点的数量 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>哈希表节点结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line"><span class="type">void</span> *key;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 值，可以是一个指针，或者整数</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;<span class="comment">// 指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 指向下个哈希表节点，形成链表，用来解决冲突问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h4><p>字典，又称为符号表、关联数组、映射（Map），用于保存键值对的数据结构，字典中的每个键都是独一无二的。底层采用哈希表实现，一个哈希表包含多个哈希表节点，每个节点保存一个键值对</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表，数组中的每个项都是一个dictht哈希表，</span></span><br><span class="line">    <span class="comment">// 一般情况下字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数</li><li>privdata 属性保存了需要传给那些类型特定函数的可选参数</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Redis 使用 MurmurHash 算法来计算键的哈希值，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快</p><p>将一个新的键值对添加到字典里，需要先根据键 key 计算出哈希值，然后进行取模运算（取余）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask</span><br></pre></td></tr></table></figure><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，就称这些键发生了哈希冲突（collision）</p><p>Redis 的哈希表使用链地址法（separate chaining）来解决键哈希冲突， 每个哈希表节点都有一个 next 指针，多个节点通过 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p><p>dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，程序总是将新节点添加到链表的表头位置（<strong>头插法</strong>），时间复杂度为 O(1)</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png"></p><hr><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>负载因子的计算方式：哈希表中的<strong>节点数量</strong> &#x2F; 哈希表的大小（<strong>长度</strong>）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure><p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时 ，程序会自动对哈希表的大小进行相应的扩展或者收缩</p><p>哈希表执行扩容的条件：</p><ul><li><p>服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 1</p></li><li><p>服务器正在执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 5</p><p>原因：执行该命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on­-write）技术来优化子进程的使用效率，通过提高执行扩展操作的负载因子，尽可能地避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</p></li></ul><p>哈希表执行收缩的条件：负载因子小于 0.1（自动执行，servreCron 中检测）</p><hr><h4 id="重新散列"><a href="#重新散列" class="headerlink" title="重新散列"></a>重新散列</h4><p>扩展和收缩哈希表的操作通过 rehash（重新散列）来完成，步骤如下：</p><ul><li>为字典的 ht[1] 哈希表分配空间，空间大小的分配情况：<ul><li>如果执行的是扩展操作，ht[1] 的大小为第一个大于等于 $ht[0].used * 2$ 的 $2^n$</li><li>如果执行的是收缩操作，ht[1] 的大小为第一个大于等于 $ht[0].used$ 的 $2^n$</li></ul></li><li>将保存在 ht[0] 中所有的键值对重新计算哈希值和索引值，迁移到 ht[1] 上</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 创建一个新的空白哈希表，为下一次 rehash 做准备</li></ul><p>如果哈希表里保存的键值对数量很少，rehash 就可以在瞬间完成，但是如果哈希表里数据很多，那么要一次性将这些键值对全部 rehash 到 ht[1] 需要大量计算，可能会导致服务器在一段时间内停止服务</p><p>Redis 对 rehash 做了优化，使 rehash 的动作并不是一次性、集中式的完成，而是分多次，渐进式的完成，又叫<strong>渐进式 rehash</strong></p><ul><li>为 ht[1] 分配空间，此时字典同时持有 ht[0] 和 ht[1] 两个哈希表</li><li>在字典中维护了一个索引计数器变量 rehashidx，并将变量的值设为 0，表示 rehash 正式开始</li><li>在 rehash 进行期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后<strong>将 rehashidx 属性的值增一</strong></li><li>随着字典操作的不断执行，最终在某个时间点 ht[0] 的所有键值对都被 rehash 至 ht[1]，将 rehashidx 属性的值设为 -1</li></ul><p>渐进式 rehash 采用<strong>分而治之</strong>的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 带来的庞大计算量</p><p>渐进式 rehash 期间的哈希表操作：</p><ul><li>字典的查找、删除、更新操作会在两个哈希表上进行，比如查找一个键会先在 ht[0] 上查找，查找不到就去 ht[1] 继续查找</li><li>字典的添加操作会直接在 ht[1] 上添加，不在 ht[0] 上进行任何添加</li></ul><hr><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳跃表（skiplist）是一种有序（<strong>默认升序</strong>）的数据结构，在链表的基础上<strong>增加了多级索引以提升查找的效率</strong>，索引是占内存的，所以是一个<strong>空间换时间</strong>的方案，跳表平均 O(logN)、最坏 O(N) 复杂度的节点查找，效率与平衡树相当但是实现更简单</p><p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势可以被放大，而缺点（占内存）则可以忽略</p><p>Redis 只在两个地方应用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点，O(1) 的时间复杂度定位头尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表的长度，也就是表内的节点数量 (表头节点不计算在内)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数 (表头节点的层高不计算在内)</span></span><br><span class="line">    <span class="type">int</span> level</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E8%B7%B3%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a>属性分析</h4><p>层：level 数组包含多个元素，每个元素包含指向其他节点的指针。根据幕次定律（power law，越大的数出现的概率越小）<strong>随机</strong>生成一个介于 1 和 32 之间的值（Redis5 之后最大为 64）作为 level 数组的大小，这个大小就是层的高度，节点的第一层是 level[0] &#x3D; L1</p><p>前进指针：forward 用于从表头到表尾方向<strong>正序（升序）遍历节点</strong>，遇到 NULL 停止遍历</p><p>跨度：span 用于记录两个节点之间的距离，用来计算排位（rank）：</p><ul><li><p>两个节点之间的跨度越大相距的就越远，指向 NULL 的所有前进指针的跨度都为 0</p></li><li><p>在查找某个节点的过程中，<strong>将沿途访问过的所有层的跨度累计起来，结果就是目标节点在跳跃表中的排位</strong>，按照上图所示：</p><p>查找分值为 3.0 的节点，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3</p><p>查找分值为 2.0 的节点，沿途经历的层：经过了两个跨度为 1 的节点，因此可以计算出目标节点在跳跃表中的排位为 2</p></li></ul><p>后退指针：backward 用于从表尾到表头方向<strong>逆序（降序）遍历节点</strong></p><p>分值：score 属性一个 double 类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</p><p>成员对象：obj 属性是一个指针，指向一个 SDS 字符串对象。同一个跳跃表中，各个节点保存的<strong>成员对象必须是唯一的</strong>，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序（从小到大）</p><p>个人笔记：JUC → 并发包 → ConcurrentSkipListMap 详解跳跃表</p><hr><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>整数集合（intset）是用于保存整数值的集合数据结构，是 Redis 集合键的底层实现之一</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"><span class="comment">// 编码方式</span></span><br><span class="line"><span class="type">uint32_t</span> encoding;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 集合包含的元素数量，也就是 contents 数组的长度</span></span><br><span class="line"><span class="type">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding 取值为三种：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</p><p>整数集合的每个元素都是 contents 数组的一个数组项（item），在数组中按值的大小从小到大<strong>有序排列</strong>，并且数组中<strong>不包含任何重复项</strong>。虽然 contents 属性声明为 int8_t 类型，但实际上数组并不保存任何 int8_t 类型的值， 真正类型取决于 encoding 属性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>说明：底层存储结构是数组，所以为了保证有序性和不重复性，每次添加一个元素的时间复杂度是 O(N)</p><hr><h4 id="类型升级"><a href="#类型升级" class="headerlink" title="类型升级"></a>类型升级</h4><p>整数集合添加的新元素的类型比集合现有所有元素的类型都要长时，需要先进行升级（upgrade），升级流程：</p><ul><li><p>根据新元素的类型长度以及集合元素的数量（包括新元素在内），扩展整数集合底层数组的空间大小</p></li><li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放入正确的位置，放置过程保证数组的有序性</p><p>图示 32 * 4 &#x3D; 128 位，首先将 3 放入索引 2（64 位 - 95 位），然后将 2 放置索引 1，将 1 放置在索引 0，从后向前依次放置在对应的区间，最后放置 65535 元素到索引 3（96 位- 127 位），修改 length 属性为 4</p></li><li><p>将新元素添加到底层数组里</p></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7.png"></p><p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为 O(N)</p><p>引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，升级之后新元素的摆放位置：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引 0）</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length-1）</li></ul><p>整数集合升级策略的优点：</p><ul><li><p>提升整数集合的灵活性：C 语言是静态类型语言，为了避免类型错误通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以自动升级底层数组来适应新元素，所以可以随意的添加整数</p></li><li><p>节约内存：要让数组可以同时保存 int16、int32、int64 三种类型的值，可以直接使用 int64_t 类型的数组作为整数集合的底层实现，但是会造成内存浪费，整数集合可以确保升级操作只会在有需要的时候进行，尽量节省内存</p></li></ul><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态</p><hr><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><h4 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h4><p>压缩列表（ziplist）是 Redis 为了节约内存而开发的，是列表键和哈希键的底层实现之一。是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><ul><li>zlbytes：uint32_t 类型 4 字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算 zlend 的位置时使用</li><li>zltail：uint32_t 类型 4 字节，记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量程序无须遍历整个压缩列表就可以确定表尾节点的地址</li><li>zllen：uint16_t 类型 2 字节，记录了压缩列表包含的节点数量，当该属性的值小于 UINT16_MAX (65535) 时，该值就是压缩列表中节点的数量；当这个值等于 UINT16_MAX 时节点的真实数量需要遍历整个压缩列表才能计算得出</li><li>entryX：列表节点，压缩列表中的各个节点，<strong>节点的长度由节点保存的内容决定</strong></li><li>zlend：uint8_t 类型 1 字节，是一个特殊值 0xFF (255)，用于标记压缩列表的末端</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png"></p><p>列表 zlbytes 属性的值为 0x50 (十进制 80)，表示压缩列表的总长为 80 字节，列表 zltail 属性的值为 0x3c (十进制 60)，假设表的起始地址为 p，计算得出表尾节点 entry3 的地址 p + 60</p><hr><h4 id="列表节点"><a href="#列表节点" class="headerlink" title="列表节点"></a>列表节点</h4><p>列表节点 entry 的数据结构：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png"></p><p>previous_entry_length：以字节为单位记录了压缩列表中前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，完成<strong>从表尾向表头遍历</strong>操作</p><ul><li>如果前一节点的长度小于 254 字节，该属性的长度为 1 字节，前一节点的长度就保存在这一个字节里</li><li>如果前一节点的长度大于等于 254 字节，该属性的长度为 5 字节，其中第一字节会被设置为 0xFE（十进制 254），之后的四个字节则用于保存前一节点的长度</li></ul><p>encoding：记录了节点的 content 属性所保存的数据类型和长度</p><ul><li><p><strong>长度为 1 字节、2 字节或者 5 字节</strong>，值的最高位为 00、01 或者 10 的是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录，下划线 <code>_</code> 表示留空，而 <code>b</code>、<code>x</code> 等变量则代表实际的二进制数据</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png"></p></li><li><p>长度为 1 字节，值的最高位为 11 的是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png"></p></li></ul><p>content：每个压缩列表节点可以保存一个字节数组或者一个整数值</p><ul><li><p>字节数组可以是以下三种长度的其中一种：</p><ul><li><p>长度小于等于 $63 (2^6-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $16383(2^{14}-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $4294967295(2^{32}-1)$ 字节的字节数组</p></li></ul></li><li><p>整数值则可以是以下六种长度的其中一种：</p><ul><li><p>4 位长，介于 0 至 12 之间的无符号整数</p></li><li><p>1 字节长的有符号整数</p></li><li><p>3 字节长的有符号整数</p></li><li><p>int16_t 类型整数</p></li><li><p>int32_t 类型整数</p></li><li><p>int64_t 类型整数</p></li></ul></li></ul><hr><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为连锁更新（cascade update）</p><p>假设在一个压缩列表中，有多个连续的、长度介于 250 到 253 字节之间的节点 e1 至 eN。将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的头节点，new 就成为 e1 的前置节点。e1 的 previous_entry_length 属性仅为 1 字节，无法保存新节点 new 的长度，所以要对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从 1 字节长扩展为 5 字节长。由于 e1 原本的长度介于 250 至 253 字节之间，所以扩展后 e1 的长度就变成了 254 至 257 字节之间，导致 e2 的  previous_entry_length 属性无法保存 e1 的长度，程序需要不断地对压缩列表执行空间重分配操作，直到 eN 为止</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png"></p><p> 删除节点也可能会引发连锁更新，big.length &gt;&#x3D; 254，small.length &lt; 254，删除 small 节点</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png"></p><p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配，每次重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)</p><p>说明：尽管连锁更新的复杂度较高，但出现的记录是非常低的，即使出现只要被更新的节点数量不多，就不会对性能造成影响</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="redisObj"><a href="#redisObj" class="headerlink" title="redisObj"></a>redisObj</h3><h4 id="对象系统"><a href="#对象系统" class="headerlink" title="对象系统"></a>对象系统</h4><p>Redis 使用对象来表示数据库中的键和值，当在 Redis 数据库中新创建一个键值对时至少会创建两个对象，一个对象用作键值对的键（<strong>键对象</strong>），另一个对象用作键值对的值（<strong>值对象</strong>）</p><p>Redis 中对象由一个 redisObject 结构表示，该结构中和保存数据有关的三个属性分别是 type、 encoding、ptr：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"><span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 并没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，而每种对象又通过不同的编码映射到不同的底层数据结构</p><p>Redis 是一个 Map 类型，其中所有的数据都是采用 key : value 的形式存储，<strong>键对象都是字符串对象</strong>，而值对象有五种基本类型和三种高级类型对象</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A0%81.png"></p><ul><li>对一个数据库键执行 TYPE 命令，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型</li><li>对一个数据库键执行 OBJECT ENCODING 命令，查看数据库键对应的值对象的编码</li></ul><hr><h4 id="命令多态"><a href="#命令多态" class="headerlink" title="命令多态"></a>命令多态</h4><p>Redis 中用于操作键的命令分为两种类型：</p><ul><li>一种命令可以对任何类型的键执行，比如说 DEL 、EXPIRE、RENAME、 TYPE 等（基于类型的多态）</li><li>只能对特定类型的键执行，比如 SET 只能对字符串键执行、HSET 对哈希键执行、SADD 对集合键执行，如果类型步匹配会报类型错误： <code>(error) WRONGTYPE Operation against a key holding the wrong kind of value</code></li></ul><p>Redis 为了确保只有指定类型的键可以执行某些特定的命令，在执行类型特定的命令之前，先通过值对象 redisObject 结构 type 属性检查操作类型是否正确，然后再决定是否执行指定的命令</p><p>对于多态命令，比如列表对象有 ziplist 和 linkedlist 两种实现方式，通过 redisObject 结构 encoding 属性确定具体的编码类型，底层调用对应的 API 实现具体的操作（基于编码的多态）</p><hr><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>对象的整个生命周期可以划分为创建对象、 操作对象、 释放对象三个阶段</p><p>C 语言没有自动回收内存的功能，所以 Redis 在对象系统中构建了引用计数（reference counting）技术实现的内存回收机制，程序可以跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line"><span class="comment">// 引用计数</span></span><br><span class="line"><span class="type">int</span> refcount;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化，创建时引用计数 refcount 初始化为 1，每次被一个新程序使用时引用计数加 1，当对象不再被一个程序使用时引用计数值会被减 1，当对象的引用计数值变为 0 时，对象所占用的内存会被释放</p><hr><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>对象的引用计数属性带有对象共享的作用，共享对象机制更节约内存，数据库中保存的相同值对象越多，节约的内存就越多</p><p>让多个键共享一个对象的步骤：</p><ul><li><p>将数据库键的值指针指向一个现有的值对象</p></li><li><p>将被共享的值对象的引用计数增一</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-对象共享.png" style="zoom:67%;"></li></ul><p>Redis 在初始化服务器时创建一万个（配置文件可以修改）字符串对象，包含了<strong>从 0 到 9999 的所有整数值</strong>，当服务器需要用到值为 0 到 9999 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</p><p>比如创建一个值为 100 的键 A，并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数，会发现值对象的引用计数为 2，引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键 A</p><p>共享对象在嵌套了字符串对象的对象（linkedlist 编码的列表、hashtable 编码的哈希、zset 编码的有序集合）中也能使用</p><p>Redis 不共享包含字符串对象的原因：验证共享对象和目标对象是否相同的复杂度越高，消耗的 CPU 时间也会越多</p><ul><li>整数值的字符串对象， 验证操作的复杂度为 O(1)</li><li>字符串值的字符串对象， 验证操作的复杂度为 O(N)</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，验证操作的复杂度为 O(N^2)</li></ul><hr><h4 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h4><p>redisObject 结构包含一个 lru 属性，该属性记录了对象最后一次被命令程序访问的时间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME 命令可以打印出给定键的空转时长，该值就是通过将当前时间减去键的值对象的 lru 时间计算得出的，这个命令在访问键的值对象时，不会修改值对象的 lru 属性</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"><span class="comment"># 等待一分钟</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"><span class="comment"># 访问 msg</span></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>空转时长的作用：如果服务器开启 maxmemory 选项，并且回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存（LRU 算法）</p><hr><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型，实质上是存一个字符串，string 类型是二进制安全的，可以包含任何数据，比如图片或者序列化的对象</p><p>存储数据的格式：一个存储空间保存一个数据，每一个空间中只能保存一个字符串信息</p><p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-string结构图.png" style="zoom:50%;"><p>Redis 所有操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>机制，命令是单个顺序执行，无需考虑并发带来影响，原子性就是有一个失败则都失败</p><p>字符串对象可以是 int、raw、embstr 三种实现方式</p><hr><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p><ul><li><p>数据操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value<span class="comment">#添加/修改数据添加/修改数据</span></span><br><span class="line">del key<span class="comment">#删除数据</span></span><br><span class="line">setnx key value<span class="comment">#判定性添加数据，键值为空则设添加</span></span><br><span class="line">mset k1 v1 k2 v2...<span class="comment">#添加/修改多个数据，m：Multiple</span></span><br><span class="line">append key value<span class="comment">#追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</span></span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">get key<span class="comment">#获取数据，如果不存在，返回空（nil）</span></span><br><span class="line">mget key1 key2...<span class="comment">#获取多个数据</span></span><br><span class="line">strlen key<span class="comment">#获取数据字符个数（字符串长度）</span></span><br></pre></td></tr></table></figure></li><li><p>设置数值数据增加&#x2F;减少指定范围的值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">incr key<span class="comment">#key++</span></span><br><span class="line">incrby key increment<span class="comment">#key+increment</span></span><br><span class="line">incrbyfloat key increment<span class="comment">#对小数操作</span></span><br><span class="line">decr key<span class="comment">#key--</span></span><br><span class="line">decrby key increment<span class="comment">#key-increment</span></span><br></pre></td></tr></table></figure></li><li><p>设置数据具有指定的生命周期</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setex key seconds value  <span class="comment">#设置key-value存活时间，seconds单位是秒</span></span><br><span class="line">psetex key milliseconds value<span class="comment">#毫秒级</span></span><br></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol><li><p>数据操作不成功的反馈与数据正常操作之间的差异</p><ul><li><p>表示运行结果是否成功</p><ul><li><p>(integer) 0  → false ，失败</p></li><li><p>(integer) 1  → true，成功</p></li></ul></li><li><p>表示运行结果值</p><ul><li><p>(integer) 3  → 3 个</p></li><li><p>(integer) 1  → 1 个</p></li></ul></li></ul></li><li><p>数据未获取到时，对应的数据为（nil），等同于null</p></li><li><p><strong>数据最大存储量</strong>：512MB</p></li><li><p>string 在 Redis 内部存储默认就是一个字符串，当遇到增减类操作 incr，decr 时<strong>会转成数值型</strong>进行计算</p></li><li><p>按数值进行操作的数据，如果原始数据不能转成数值，或超越了Redis 数值上限范围，将报错<br>9223372036854775807（java 中 Long 型数据最大值，Long.MAX_VALUE）</p></li><li><p>Redis 可用于控制数据库表主键 ID，为数据库表主键提供生成策略，保障数据库表的主键唯一性</p></li></ol><p>单数据和多数据的选择：</p><ul><li>单数据执行 3 条指令的过程：3 次发送 + 3 次处理 + 3 次返回</li><li>多数据执行 1 条指令的过程：1 次发送 + 3 次处理 + 1 次返回（发送和返回的事件略高于单数据）</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/string单数据与多数据操作.png" style="zoom: 33%;"><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>字符串对象的编码可以是 int、raw、embstr 三种</p><ul><li><p>int：字符串对象保存的是<strong>整数值</strong>，并且整数值可以用 long 类型来表示，那么对象会将整数值保存在字符串对象结构的 ptr 属性面（将 void * 转换成 long)，并将字符串对象的编码设置为 int（浮点数用另外两种方式）</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-字符串对象int编码.png" style="zoom:67%;"></li><li><p>raw：字符串对象保存的是一个字符串值，并且值的长度大于 39 字节，那么对象将使用简单动态字符串（SDS）来保存该值，并将对象的编码设置为 raw</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1raw%E7%BC%96%E7%A0%81.png"></p></li><li><p>embstr：字符串对象保存的是一个字符串值，并且值的长度小于等于 39 字节，那么对象将使用 embstr 编码的方式来保存这个字符串值，并将对象的编码设置为 embstr</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1embstr%E7%BC%96%E7%A0%81.png"></p><p>上图所示，embstr 与 raw 都使用了 redisObject 和 sdshdr 来表示字符串对象，但是 raw 需要调用两次内存分配函数分别创建两种结构，embstr 只需要一次内存分配来分配一块<strong>连续的空间</strong></p></li></ul><p>embstr 是用于保存短字符串的一种编码方式，对比 raw 的优点：</p><ul><li>内存分配次数从两次降低为一次，同样释放内存的次数也从两次变为一次</li><li>embstr 编码的字符串对象的数据都保存在同一块连续内存，所以比 raw 编码能够更好地利用缓存优势（局部性原理）</li></ul><p>int 和 embstr 编码的字符串对象在条件满足的情况下，会被转换为 raw 编码的字符串对象：</p><ul><li>int 编码的整数值，执行 APPEND 命令追加一个字符串值，先将整数值转为字符串然后追加，最后得到一个 raw 编码的对象</li><li>Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序，所以 embstr 对象实际上<strong>是只读的</strong>，执行修改命令会将对象的编码从 embstr 转换成 raw，操作完成后得到一个 raw 编码的对象</li></ul><p>某些情况下，程序会将字符串对象里面的字符串值转换回浮点数值，执行某些操作后再将浮点数值转换回字符串值：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SET pi 3.14 </span><br><span class="line">OK </span><br><span class="line">redis&gt; OBJECT ENCODING pi</span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br><span class="line">redis&gt; INCRBYFLOAT pi 2.0 <span class="comment"># 转为浮点数执行增加的操作</span></span><br><span class="line"><span class="string">&quot;5. 14&quot;</span> </span><br><span class="line">redis&gt; OBJECT ENCODING pi </span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br></pre></td></tr></table></figure><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>主页高频访问信息显示控制，例如新浪微博大 V 主页显示粉丝数与微博数量</p><ul><li><p>在 Redis 中为大 V 用户设定用户信息，以用户主键和属性值作为 key，后台设定定时刷新策略</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:fans 12210947</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:blogs 6164</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:focuses 83</span><br></pre></td></tr></table></figure></li><li><p>使用 JSON 格式保存数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;fans&quot;</span>:12210947,<span class="string">&quot;blogs&quot;</span>:6164,<span class="string">&quot;focuses&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure></li><li><p>key的设置约定：表名 : 主键名 : 主键值 : 字段名</p><table><thead><tr><th>表名</th><th>主键名</th><th>主键值</th><th>字段名</th></tr></thead><tbody><tr><td>order</td><td>id</td><td>29437595</td><td>name</td></tr><tr><td>equip</td><td>id</td><td>390472345</td><td>type</td></tr><tr><td>news</td><td>id</td><td>202004150</td><td>title</td></tr></tbody></table></li></ul><hr><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p><p>数据存储结构：一个存储空间保存多个键值对数据</p><p>hash 类型：底层使用<strong>哈希表</strong>结构实现数据存储</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash结构图.png" style="zoom: 33%;"><p>Redis 中的 hash 类似于 Java 中的  <code>Map&lt;String, Map&lt;Object,object&gt;&gt;</code>，左边是 key，右边是值，中间叫 field 字段，本质上 <strong>hash 存了一个 key-value 的存储空间</strong></p><p>hash 是指的一个数据类型，并不是一个数据</p><ul><li>如果 field 数量较少，存储结构优化为<strong>压缩列表结构</strong>（有序）</li><li>如果 field 数量较多，存储结构使用 HashMap 结构（无序）</li></ul><hr><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hset key field value<span class="comment">#添加/修改数据</span></span><br><span class="line">hdel key field1 [field2]<span class="comment">#删除数据，[]代表可选</span></span><br><span class="line">hsetnx key field value<span class="comment">#设置field的值，如果该field存在则不做任何操作</span></span><br><span class="line">hmset key f1 v1 f2 v2...<span class="comment">#添加/修改多个数据</span></span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hget key field<span class="comment">#获取指定field对应数据</span></span><br><span class="line">hgetall key<span class="comment">#获取指定key所有数据</span></span><br><span class="line">hmget key field1 field2...<span class="comment">#获取多个数据</span></span><br><span class="line">hexists key field<span class="comment">#获取哈希表中是否存在指定的字段</span></span><br><span class="line">hlen key<span class="comment">#获取哈希表中字段的数量</span></span><br></pre></td></tr></table></figure></li><li><p>获取哈希表中所有的字段名或字段值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hkeys key<span class="comment">#获取所有的field</span></span><br><span class="line">hvals key<span class="comment">#获取所有的value</span></span><br></pre></td></tr></table></figure></li><li><p>设置指定字段的数值数据增加指定范围的值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hincrby key field increment<span class="comment">#指定字段的数值数据增加指定的值，increment为负数则减少</span></span><br><span class="line">hincrbyfloat key field increment<span class="comment">#操作小数</span></span><br></pre></td></tr></table></figure></li></ul><p>注意事项</p><ol><li>hash 类型中 value 只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值对</li><li>hash 类型和对象的数据存储形式相似，并且可以灵活添加删除对象属性。但 hash 设计初衷不是为了存储大量对象而设计的，不可滥用，不可将 hash 作为对象列表使用</li><li>hgetall 操作可以获取全部属性，如果内部 field 过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ol><hr><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>哈希对象的内部编码有两种：ziplist（压缩列表）、hashtable（哈希表、字典）</p><ul><li><p>压缩列表实现哈希对象：同一键值对的节点总是挨在一起，保存键的节点在前，保存值的节点在后</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>字典实现哈希对象：字典的每一个键都是一个字符串对象，每个值也是</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哈希对象dict.png" style="zoom:67%;"></li></ul><p>当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型，具体需要满足两个条件：</p><ul><li>当键值对数量小于 hash-max-ziplist-entries 配置（默认 512 个）</li><li>所有键和值的长度都小于 hash-max-ziplist-value 配置（默认 64 字节）</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p><p>ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比 hashtable 更加优秀，当 ziplist 无法满足哈希类型时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 O(1)</p><hr><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;春晚&quot;</span>,<span class="string">&quot;fans&quot;</span>:12210862,<span class="string">&quot;blogs&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure><p>对于以上数据，使用单条去存的话，存的条数会很多。但如果用 json 格式，存一条数据就够了。</p><p>假如现在粉丝数量发生了变化，要把整个值都改变，但是用单条存就不存在这个问题，只需要改其中一个就可以</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash应用场景结构图.png" style="zoom: 33%;"><p>可以实现购物车的功能，key 对应着每个用户，存储空间存储购物车的信息</p><hr><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p><p>数据存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序，允许重复元素</p><p>list 类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现，类似于 LinkedList</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/list结构图.png" style="zoom:33%;"><p>如果两端都能存取数据的话，这就是双端队列，如果只能从一端进一端出，这个模型叫栈</p><hr><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush key value1 [value2]...<span class="comment">#从左边添加/修改数据(表头)</span></span><br><span class="line">rpush key value1 [value2]...<span class="comment">#从右边添加/修改数据(表尾)</span></span><br><span class="line">lpop key<span class="comment">#从左边获取并移除第一个数据，类似于出栈/出队</span></span><br><span class="line">rpop key<span class="comment">#从右边获取并移除第一个数据</span></span><br><span class="line">lrem key count value<span class="comment">#删除指定数据，count=2删除2个，该value可能有多个(重复数据)</span></span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lrange key start stop<span class="comment">#从左边遍历数据并指定开始和结束索引，0是第一个索引，-1是终索引</span></span><br><span class="line">lindex key index<span class="comment">#获取指定索引数据，没有则为nil，没有索引越界</span></span><br><span class="line">llen key<span class="comment">#list中数据长度/个数</span></span><br></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">b<span class="comment">#代表阻塞</span></span><br><span class="line">blpop key1 [key2] <span class="built_in">timeout</span><span class="comment">#在指定时间内获取指定key(可以多个)的数据，超时则为(nil)</span></span><br><span class="line"><span class="comment">#可以从其他客户端写数据，当前客户端阻塞读取数据</span></span><br><span class="line">brpop key1 [key2] <span class="built_in">timeout</span><span class="comment">#从右边操作</span></span><br></pre></td></tr></table></figure></li><li><p>复制操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brpoplpush <span class="built_in">source</span> destination <span class="built_in">timeout</span><span class="comment">#从source获取数据放入destination，假如在指定时间内没有任何元素被弹出，则返回一个nil和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长</span></span><br></pre></td></tr></table></figure></li></ul><p>注意事项</p><ol><li>list 中保存的数据都是 string 类型的，数据总容量是有限的，最多 2^32 - 1 个元素（4294967295）</li><li>list 具有索引的概念，但操作数据时通常以队列的形式进行入队出队，或以栈的形式进行入栈出栈</li><li>获取全部数据操作结束索引设置为 -1</li><li>list 可以对数据进行分页操作，通常第一页的信息来自于 list，第 2 页及更多的信息通过数据库的形式加载</li></ol><hr><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>在 Redis3.2 版本以前列表对象的内部编码有两种：ziplist（压缩列表）和 linkedlist（链表）</p><ul><li><p>压缩列表实现的列表对象：PUSH 1、three、5 三个元素</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>链表实现的列表对象：为了简化字符串对象的表示，使用了 StringObject 的结构，底层其实是 sdshdr 结构</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1linkedlist.png"></p></li></ul><p>列表中存储的数据量比较小的时候，列表就会使用一块连续的内存存储，采用压缩列表的方式实现的条件：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节</li><li>列表对象保存的元素数量小于 512 个</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p><p>在 Redis3.2 版本 以后对列表数据结构进行了改造，使用 <strong>quicklist（快速列表）</strong>代替了 linkedlist，quicklist 实际上是 ziplist 和 linkedlist 的混合体，将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来，既满足了快速的插入删除性能，又不会出现太大的空间冗余</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-快速列表数据结构.png" style="zoom: 50%;"><hr><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p><ul><li>依赖 list 的数据具有顺序的特征对信息进行管理，右进左查或者左近左查</li><li>使用队列模型解决多路信息汇总合并的问题</li><li>使用栈模型解决最新消息的问题</li></ul><p>微信文章订阅公众号：</p><ul><li>比如订阅了两个公众号，它们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 <code>LPUSH key 666 888</code> 命令推送给我</li></ul><hr><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储大量的数据，在查询方面提供更高的效率</p><p>数据存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p><p>set 类型：与 hash 存储结构哈希表完全相同，只是仅存储键不存储值（nil），所以添加，删除，查找的复杂度都是 O(1)，并且<strong>值是不允许重复且无序的</strong></p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/set结构图.png" style="zoom: 33%;"><hr><h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd key member1 [member2]<span class="comment">#添加数据</span></span><br><span class="line">srem key member1 [member2]<span class="comment">#删除数据</span></span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smembers key<span class="comment">#获取全部数据</span></span><br><span class="line">scard key<span class="comment">#获取集合数据总量</span></span><br><span class="line">sismember key member<span class="comment">#判断集合中是否包含指定数据</span></span><br></pre></td></tr></table></figure></li><li><p>随机操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spop key [count]<span class="comment">#随机获取集中的某个数据并将该数据移除集合</span></span><br><span class="line">srandmember key [count]<span class="comment">#随机获取集合中指定(数量)的数据</span></span><br></pre></td></tr></table></figure></li><li><p>集合的交、并、差</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sinter key1 [key2...]  <span class="comment">#两个集合的交集，不存在为(empty list or set)</span></span><br><span class="line">sunion key1 [key2...]  <span class="comment">#两个集合的并集</span></span><br><span class="line">sdiff key1 [key2...]<span class="comment">#两个集合的差集</span></span><br><span class="line"></span><br><span class="line">sinterstore destination key1 [key2...]<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">sunionstore destination key1 [key2...]<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br><span class="line">sdiffstore destination key1 [key2...]<span class="comment">#两个集合的差集并存储到指定集合中</span></span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smove <span class="built_in">source</span> destination member<span class="comment">#将指定数据从原始集合中移动到目标集合中</span></span><br></pre></td></tr></table></figure></li></ul><p>注意事项</p><ol><li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li>set 虽然与 hash 的存储结构相同，但是无法启用 hash 中存储值的空间</li></ol><hr><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>集合对象的内部编码有两种：intset（整数集合）、hashtable（哈希表、字典）</p><ul><li><p>整数集合实现的集合对象：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象intset.png" style="zoom:67%;"></li><li><p>字典实现的集合对象：键值对的值为 NULL</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象dict.png" style="zoom:80%;"></li></ul><p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p><ul><li>集合中的元素都是整数值</li><li>集合中的元素数量小于 set-maxintset-entries配置（默认 512 个）</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的</p><hr><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>应用场景：</p><ol><li><p>黑名单：资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密。</p><p>注意：爬虫不一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p></li><li><p>白名单：对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证</p></li><li><p>随机操作可以实现抽奖功能</p></li><li><p>集合的交并补可以实现微博共同关注的查看，可以根据共同关注或者共同喜欢推荐相关内容</p></li></ol><hr><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p><p>数据存储结构：新的存储模型，可以保存可排序的数据</p><hr><h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]<span class="comment">#添加数据</span></span><br><span class="line">zrem key member [member ...]<span class="comment">#删除数据</span></span><br><span class="line">zremrangebyrank key start stop <span class="comment">#删除指定索引范围的数据</span></span><br><span class="line">zremrangebyscore key min max<span class="comment">#删除指定分数区间内的数据</span></span><br><span class="line">zscore key member<span class="comment">#获取指定值的分数</span></span><br><span class="line">zincrby key increment member<span class="comment">#指定值的分数增加increment</span></span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]<span class="comment">#获取指定范围的数据，升序，WITHSCORES 代表显示分数</span></span><br><span class="line">zrevrange key start stop [WITHSCORES]<span class="comment">#获取指定范围的数据，降序</span></span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]<span class="comment">#按条件获取数据，从小到大</span></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES] [...]<span class="comment">#从大到小</span></span><br><span class="line"></span><br><span class="line">zcard key<span class="comment">#获取集合数据的总量</span></span><br><span class="line">zcount key min max<span class="comment">#获取指定分数区间内的数据总量</span></span><br><span class="line">zrank key member<span class="comment">#获取数据对应的索引（排名）升序</span></span><br><span class="line">zrevrank key member<span class="comment">#获取数据对应的索引（排名）降序</span></span><br></pre></td></tr></table></figure><ul><li>min 与 max 用于限定搜索查询的条件</li><li>start 与 stop 用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset 与 count 用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul></li><li><p>集合的交、并操作</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">zunionstore destination numkeys key [key ...]<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol><li>score 保存的数据存储空间是 64 位，如果是整数范围是 -9007199254740992~9007199254740992</li><li>score 保存的数据也可以是一个双精度的 double 值，基于双精度浮点数的特征可能会丢失精度，慎重使用</li><li>sorted_set 底层存储还是基于 set 结构的，因此数据不能重复，如果重复添加相同的数据，score 值将被反复覆盖，保留最后一次修改的结果</li></ol><hr><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>有序集合对象的内部编码有两种：ziplist（压缩列表）和 skiplist（跳跃表）</p><ul><li><p>压缩列表实现有序集合对象：ziplist 本身是有序、不可重复的，符合有序集合的特性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>跳跃表实现有序集合对象：<strong>底层是 zset 结构，zset 同时包含字典和跳跃表的结构</strong>，图示字典和跳跃表中重复展示了各个元素的成员和分值，但实际上两者会<strong>通过指针来共享相同元素的成员和分值</strong>，不会产生空间浪费</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1zset.png"></p></li></ul><p>使用字典加跳跃表的优势：</p><ul><li>字典为有序集合创建了一个<strong>从成员到分值的映射</strong>，用 O(1) 复杂度查找给定成员的分值</li><li><strong>排序操作使用跳跃表完成</strong>，节省每次重新排序带来的时间成本和空间成本</li></ul><p>使用 ziplist 格式存储需要满足以下两个条件：</p><ul><li>有序集合保存的元素个数要小于 128 个；</li><li>有序集合保存的所有元素大小都小于 64 字节</li></ul><p>当元素比较多时，此时 ziplist 的读写效率会下降，时间复杂度是 O(n)，跳表的时间复杂度是 O(logn)</p><p>为什么用跳表而不用平衡树？</p><ul><li>在做范围查找的时候，跳表操作简单（前进指针或后退指针），平衡树需要回旋查找</li><li>跳表比平衡树实现简单，平衡树的插入和删除操作可能引发子树的旋转调整，而跳表的插入和删除只需要修改相邻节点的指针</li></ul><hr><h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><ul><li>排行榜</li><li>对于基于时间线限定的任务处理，将处理时间记录为 score 值，利用排序功能区分处理的先后顺序</li><li>当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，采用 score 记录权重</li></ul><hr><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><p>Bitmaps 是二进制位数组（bit array），底层使用 SDS 字符串表示，因为 SDS 是二进制安全的</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%BD%8D%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png"></p><p>buf 数组的每个字节用一行表示，buf[1] 是 <code>&#39;\0&#39;</code>，保存位数组的顺序和书写位数组的顺序是完全相反的，图示的位数组 0100 1101</p><p>数据结构的详解查看 Java → Algorithm → 位图</p><hr><h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><h5 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h5><p>GETBIT 命令获取位数组 bitarray 在 offset 偏移量上的二进制位的值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GETBIT &lt;bitarray&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ul><li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li><li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li><li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，并返回这个位的值</li></ul><p>GETBIT 命令执行的所有操作都可以在常数时间内完成，所以时间复杂度为 O(1)</p><hr><h5 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h5><p>SETBIT 将位数组 bitarray 在 offset 偏移量上的二进制位的值设置为 value，并向客户端返回二进制位的旧值</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt; </span><br></pre></td></tr></table></figure><p>执行过程：</p><ul><li>计算 <code>len = offset/8 + 1</code>，len 值记录了保存该数据至少需要多少个字节</li><li>检查 bitarray 键保存的位数组的长度是否小于 len，成立就会将 SDS 扩展为 len 字节（注意空间预分配机制），所有新扩展空间的二进制位的值置为 0</li><li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li><li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li><li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，首先将指定位现存的值保存在 oldvalue 变量，然后将新值 value 设置为这个二进制位的值</li><li>向客户端返回 oldvalue 变量的值</li></ul><hr><h5 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h5><p>BITCOUNT 命令用于统计给定位数组中，值为 1 的二进制位的数量</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITCOUNT &lt;bitarray&gt; [start end]</span><br></pre></td></tr></table></figure><p>二进制位统计算法：</p><ul><li>遍历法：遍历位数组中的每个二进制位</li><li>查表算法：读取每个字节（8 位）的数据，查表获取数值对应的二进制中有几个 1 </li><li>variable-precision SWAR算法：计算汉明距离</li><li>Redis 实现：<ul><li>如果二进制位的数量大于等于 128 位， 那么使用 variable-precision SWAR 算法来计算二进制位的汉明重量</li><li>如果二进制位的数量小于 128 位，那么使用查表算法来计算二进制位的汉明重量</li></ul></li></ul><hr><h5 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h5><p>BITOP 命令对指定 key 按位进行交、并、非、异或操作，并将结果保存到指定的键中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITOP OPTION destKey key1 [key2...]</span><br></pre></td></tr></table></figure><p>OPTION 有 AND（与）、OR（或）、 XOR（异或）和 NOT（非）四个选项</p><p>AND、OR、XOR 三个命令可以接受多个位数组作为输入，需要遍历输入的每个位数组的每个字节来进行计算，所以命令的复杂度为 O(n^2)；与此相反，NOT 命令只接受一个位数组输入，所以时间复杂度为 O(n)</p><hr><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p><strong>解决 Redis 缓存穿透</strong>，判断给定数据是否存在， 防止缓存穿透</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps应用之缓存穿透.png" style="zoom: 67%;"></li><li><p>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件</p></li><li><p>爬虫去重，爬给定网址的时候对已经爬取过的 URL 去重</p></li><li><p>信息状态统计</p></li></ul><hr><h3 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h3><p>基数是数据集去重后元素个数，HyperLogLog 是用来做基数统计的，运用了 LogLog 的算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125; 基数集： &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ,<span class="number">7</span>, <span class="number">8</span>&#125; 基数：<span class="number">5</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">1</span>&#125; 基数集： &#123;<span class="number">1</span>,<span class="number">7</span>&#125; 基数：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>相关指令：</p><ul><li><p>添加数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li></ul><p>应用场景：</p><ul><li>用于进行基数统计，不是集合不保存数据，只记录数量而不是具体数据，比如网站的访问量</li><li>核心是基数估算算法，最终数值存在一定误差</li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li>耗空间极小，每个 hyperloglog key 占用了12K的内存用于标记基数</li><li>pfadd 命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li><li>Pfmerge 命令合并后占用的存储空间为12K，无论合并之前数据量多少</li></ul><hr><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>GeoHash 是一种地址编码方法，把二维的空间经纬度数据编码成一个字符串</p><ul><li><p>添加坐标点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>获取坐标点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>计算距离</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]<span class="comment">#计算坐标点距离</span></span><br><span class="line">geohash key member [member ...]<span class="comment">#计算经纬度</span></span><br></pre></td></tr></table></figure></li></ul><p>Redis 应用于地理位置计算</p><hr><h2 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 </p><p>作用：持久化用于防止数据的意外丢失，确保数据安全性，因为 Redis 是内存级，所以需要持久化到磁盘</p><p>计算机中的数据全部都是二进制，保存一组数据有两种方式<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-持久化的两种方式.png" style="zoom: 33%;"></p><p>RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单</p><p>AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂</p><hr><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>RDB 持久化功能所生成的 RDB 文件是一个经过压缩的紧凑二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态，有两个 Redis 命令可以生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE</p><h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE 指令：手动执行一次保存操作，该指令的执行会阻塞当前 Redis 服务器，客户端发送的所有命令请求都会被拒绝，直到当前 RDB 过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</p><p>工作原理：Redis 是个<strong>单线程的工作模式</strong>，会创建一个任务队列，所有的命令都会进到这个队列排队执行。当某个指令在执行的时候，队列后面的指令都要等待，所以这种执行方式会非常耗时</p><p>配置 redis.conf：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path<span class="comment">#设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</span></span><br><span class="line">dbfilename <span class="string">&quot;x.rdb&quot;</span><span class="comment">#设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no<span class="comment">#设置存储至本地数据库时是否压缩数据，默认yes，设置为no节省CPU运行时间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no<span class="comment">#设置读写文件过程是否进行RDB格式校验，默认yes</span></span><br></pre></td></tr></table></figure><hr><h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE：bg 是 background，代表后台执行，命令的完成需要两个进程，<strong>进程之间不相互影响</strong>，所以持久化期间 Redis 正常工作</p><p>工作原理：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-bgsave工作原理.png" style="zoom:67%;"><p>流程：客户端发出 BGSAVE 指令，Redis 服务器使用 fork 函数创建一个子进程，然后响应后台已经开始执行的信息给客户端。子进程会异步执行持久化的操作，持久化过程是先将数据写入到一个临时文件中，持久化操作结束再用这个临时文件<strong>替换</strong>上次持久化的文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 子进程负责创建 RDB 文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line">    <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">    signal_parent()</span><br><span class="line"><span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">    handle_request_and_wait_signal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理出错恃况</span></span><br><span class="line">    handle_fork_error() </span><br></pre></td></tr></table></figure><p>配置 redis.conf</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span>|no<span class="comment">#后台存储过程中如果出现错误，是否停止保存操作，默认yes</span></span><br><span class="line">dbfilename filename  </span><br><span class="line"><span class="built_in">dir</span> path  </span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no  </span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure><p>注意：BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及到 RDB 操作都采用 BGSAVE 的方式，SAVE 命令放弃使用</p><p>在 BGSAVE 命令执行期间，服务器处理 SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式会和平时有所不同</p><ul><li>SAVE 命令会被服务器拒绝，服务器禁止 SAVE 和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，产生竞争条件</li><li>BGSAVE 命令也会被服务器拒绝，也会产生竞争条件</li><li>BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行<ul><li>如果 BGSAVE 命令正在执行，那么 BGREWRITEAOF 命令会被<strong>延迟</strong>到 BGSAVE 命令执行完毕之后执行</li><li>如果 BGREWRITEAOF 命令正在执行，那么 BGSAVE 命令会被服务器拒绝</li></ul></li></ul><hr><h5 id="特殊指令"><a href="#特殊指令" class="headerlink" title="特殊指令"></a>特殊指令</h5><p>RDB 特殊启动形式的指令（客户端输入）</p><ul><li><p>服务器运行过程中重启</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure><p>默认情况下执行 shutdown 命令时，自动执行 bgsave（如果没有开启 AOF 持久化功能）</p></li><li><p>全量复制：主从复制部分详解</p></li></ul><hr><h4 id="文件载入"><a href="#文件载入" class="headerlink" title="文件载入"></a>文件载入</h4><p>RDB 文件的载入工作是在服务器启动时自动执行，期间 Redis 会一直处于阻塞状态，直到载入完成</p><p>Redis 并没有专门用于载入 RDB 文件的命令，只要服务器在启动时检测到 RDB 文件存在，就会自动载入 RDB 文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7379] 30 Aug 21:07:01.289 * DB loaded from disk: 0.018 seconds  <span class="comment"># 服务器在成功载入 RDB 文件之后打印</span></span><br></pre></td></tr></table></figure><p>AOF 文件的更新频率通常比 RDB 文件的更新频率高：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么会优先使用 AOF 文件来还原数据库状态</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态</li></ul><hr><h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>Redis 支持通过配置服务器的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令</p><p>配置 redis.conf：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save second changes <span class="comment">#设置自动持久化条件，满足限定时间范围内key的变化数量就进行持久化(bgsave)</span></span><br></pre></td></tr></table></figure><ul><li>second：监控时间范围</li><li>changes：监控 key 的变化量</li></ul><p>默认三个条件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save 900 1<span class="comment"># 900s内1个key发生变化就进行持久化</span></span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>判定 key 变化的依据：</p><ul><li>对数据产生了影响，不包括查询</li><li>不进行数据比对，比如 name 键存在，重新 set name seazean 也算一次变化</li></ul><p>save 配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p><hr><h5 id="自动原理"><a href="#自动原理" class="headerlink" title="自动原理"></a>自动原理</h5><p>服务器状态相关的属性：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间 </span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>Redis 服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置 save 选项， 如果没有自定义就设置为三个默认值（上节提及），设置服务器状态 redisServe.saveparams 属性，该数组每一项为一个 saveparam 结构，代表 save 的选项设置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>dirty 计数器记录距离上一次成功执行 SAVE 或者 BGSAVE 命令之后，服务器中的所有数据库进行了多少次修改（包括写入、删除、更新等操作），当服务器成功执行一个修改指令，该命令修改了多少次数据库， dirty 的值就增加多少</p></li><li><p>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 或者 BGSAVE 命令的时间</p></li></ul><p>Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护</p><p>serverCron 函数的其中一项工作是检查 save 选项所设置的保存条件是否满足，会遍历 saveparams 数组中的<strong>所有保存条件</strong>，只要有任意一个条件被满足服务器就会执行 BGSAVE 命令</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-BGSAVE%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png"></p><hr><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>RDB 的存储结构：图示全大写单词标示常量，用全小写单词标示变量和数据</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p><ul><li>REDIS：长度为 5 字节，保存着 <code>REDIS</code> 五个字符，是 RDB 文件的开头，在载入文件时可以快速检查所载入的文件是否 RDB 文件</li><li>db_version：长度为 4 字节，是一个用字符串表示的整数，记录 RDB 的版本号</li><li>database：包含着零个或任意多个数据库，以及各个数据库中的键值对数据</li><li>EOF：长度为 1 字节的常量，标志着 RDB 文件正文内容的结束，当读入遇到这个值时，代表所有数据库的键值对都已经载入完毕</li><li>check_sum：长度为 8 字节的无符号整数，保存着一个校验和，该值是通过 REDIS、db_version、databases、EOF 四个部分的内容进行计算得出。服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，来检查 RDB 文件是否有出错或者损坏</li></ul><p>Redis 本身带有 RDB 文件检查工具 redis-check-dump</p><hr><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令（不记录读）来记录数据库状态，<strong>增量保存</strong>只许追加文件但不可以改写文件，<strong>与 RDB 相比可以理解为由记录数据改为记录数据的变化</strong></p><p>AOF 主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是 Redis 持久化的主流方式</p><p>AOF 写数据过程：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF工作原理.png" style="zoom:67%;"><p>Redis 只会将对数据库进行了修改的命令写入到 AOF 文件，并复制到各个从服务器，但是 PUBSUB 和 SCRIPT LOAD 命令例外：</p><ul><li>PUBSUB 命令虽然没有修改数据库，但 PUBSUB 命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变，所以服务器需要使用 REDIS_FORCE_AOF 标志强制将这个命令写入 AOF 文件。这样在将来载入 AOF 文件时，服务器就可以再次执行相同的 PUBSUB 命令，并产生相同的副作用</li><li>SCRIPT LOAD  命令虽然没有修改数据库，但它修改了服务器状态，所以也是一个带有副作用的命令，需要使用 REDIS_FORCE_AOF</li></ul><hr><h4 id="持久实现"><a href="#持久实现" class="headerlink" title="持久实现"></a>持久实现</h4><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>启动 AOF 的基本配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>|no<span class="comment">#开启AOF持久化功能，默认no，即不开启状态</span></span><br><span class="line">appendfilename filename<span class="comment">#AOF持久化文件名，默认appendonly.aof，建议设置appendonly-端口号.aof</span></span><br><span class="line"><span class="built_in">dir</span><span class="comment">#AOF持久化文件保存路径，与RDB持久化文件路径保持一致即可</span></span><br></pre></td></tr></table></figure><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 aof_buf 缓冲区的末尾</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// AOF 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><p>服务器在处理文件事件时会执行<strong>写命令，追加一些内容到 aof_buf 缓冲区</strong>里，所以服务器每次结束一个事件循环之前，就会执行 flushAppendOnlyFile 函数，判断是否需要<strong>将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件</strong>里</p><p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendfsync always|everysec|no<span class="comment">#AOF写数据策略：默认为everysec</span></span><br></pre></td></tr></table></figure><ul><li><p>always：每次写入操作都将 aof_buf 缓冲区中的所有内容<strong>写入并同步</strong>到 AOF 文件</p><p>特点：安全性最高，数据零误差，但是性能较低，不建议使用</p></li><li><p>everysec：先将 aof_buf 缓冲区中的内容写入到操作系统缓存，判断上次同步 AOF 文件的时间距离现在超过一秒钟，再次进行同步 fsync，这个同步操作是由一个（子）线程专门负责执行的</p><p>特点：在系统突然宕机的情况下丢失 1 秒内的数据，准确性较高，性能较高，建议使用，也是默认配置</p></li><li><p>no：将 aof_buf 缓冲区中的内容写入到操作系统缓存，但并不进行同步，何时同步由操作系统来决定</p><p>特点：<strong>整体不可控</strong>，服务器宕机会丢失上次同步 AOF 后的所有写指令</p></li></ul><hr><h5 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h5><p>在现代操作系统中，当用户调用 write 函数将数据写入文件时，操作系统通常会将写入数据暂时保存在一个内存缓冲区空间，等到缓冲区<strong>写满或者到达特定时间周期</strong>，才真正地将缓冲区中的数据写入到磁盘里面（刷脏）</p><ul><li>优点：提高文件的写入效率</li><li>缺点：为写入数据带来了安全问题，如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失</li></ul><p>系统提供了 fsync 和 fdatasync 两个同步函数做<strong>强制硬盘同步</strong>，可以让操作系统立即将缓冲区中的数据写入到硬盘里面，函数会阻塞到写入硬盘完成后返回，保证了数据持久化</p><p>异常恢复：AOF 文件损坏，通过 redis-check-aof–fix appendonly.aof 进行恢复，重启 Redis，然后重新加载</p><hr><h4 id="文件载入-1"><a href="#文件载入-1" class="headerlink" title="文件载入"></a>文件载入</h4><p>AOF 文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里的命令，就还原服务器关闭之前的数据库状态，服务器在启动时，还原数据库状态打印的日志：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[8321] 05 Sep 11:58:50.449 * DB loaded from append only file: 0.000 seconds </span><br></pre></td></tr></table></figure><p>AOF 文件里面除了用于指定数据库的 SELECT 命令是服务器自动添加的，其他都是通过客户端发送的命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 2\r\n<span class="variable">$6</span>\r\nSELECT\r\n<span class="variable">$1</span>\r\n0\r\n<span class="comment"># 服务器自动添加</span></span><br><span class="line">* 3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br><span class="line">* 5\r\n<span class="variable">$4</span>\r\nSADD\r\n<span class="variable">$6</span>\r\nfruits\r\n<span class="variable">$5</span>\r\napple\r\n<span class="variable">$6</span>\r\nbanana\r\n<span class="variable">$6</span>\r\ncherry\r\n</span><br></pre></td></tr></table></figure><p>Redis 读取 AOF 文件并还原数据库状态的步骤：</p><ul><li>创建一个<strong>不带网络连接的伪客户端</strong>（fake client）执行命令，因为 Redis 的命令只能在客户端上下文中执行， 而载入 AOF 文件时所使用的命令来源于本地 AOF 文件而不是网络连接</li><li>从 AOF 文件分析并读取一条写命令</li><li>使用伪客户端执行被读出的写命令，然后重复上述步骤</li></ul><hr><h4 id="重写实现"><a href="#重写实现" class="headerlink" title="重写实现"></a>重写实现</h4><h5 id="重写策略"><a href="#重写策略" class="headerlink" title="重写策略"></a>重写策略</h5><p>AOF 重写：读取服务器当前的数据库状态，<strong>生成新 AOF 文件来替换旧 AOF 文件</strong>，不会对现有的 AOF 文件进行任何读取、分析或者写入操作，而是直接原子替换。新 AOF 文件不会包含任何浪费空间的冗余命令，所以体积通常会比旧 AOF 文件小得多</p><p>AOF 重写规则：</p><ul><li><p>进程内具有时效性的数据，并且数据已超时将不再写入文件 </p></li><li><p>对同一数据的多条写命令合并为一条命令，因为会读取当前的状态，所以直接将当前状态转换为一条命令即可。为防止数据量过大造成客户端缓冲区溢出，对 list、set、hash、zset 等集合类型，<strong>单条指令</strong>最多写入 64 个元素</p><p>如 lpushlist1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c</p></li><li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令，但是 select 指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p></li></ul><p>AOF 重写作用：</p><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高 IO 性能</li><li>降低数据恢复的用时，提高数据恢复效率</li></ul><hr><h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><p>AOF 重写程序 aof_rewrite 函数可以创建一个新 AOF 文件， 但是该函数会进行大量的写入操作，调用这个函数的线程将被长时间阻塞，所以 Redis 将 AOF 重写程序放到 fork 的子进程里执行，不会阻塞父进程，重写命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure><ul><li><p>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求</p></li><li><p>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下， 保证数据安全性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF%E6%89%8B%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.png"></p></li></ul><p>子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致，所以 Redis 设置了 AOF 重写缓冲区</p><p>工作流程：</p><ul><li>Redis 服务器执行完一个写命令，会同时将该命令追加到 AOF 缓冲区和 AOF 重写缓冲区（从创建子进程后才开始写入）</li><li>当子进程完成 AOF 重写工作之后，会向父进程发送一个信号，父进程在接到该信号之后， 会调用一个信号处理函数，该函数执行时会<strong>对服务器进程（父进程）造成阻塞</strong>（影响很小，类似 JVM STW），主要工作：<ul><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中， 这时新 AOF 文件所保存的状态将和服务器当前的数据库状态一致</li><li>对新的 AOF 文件进行改名，<strong>原子地（atomic）覆盖</strong>现有的 AOF 文件，完成新旧两个 AOF 文件的替换</li></ul></li></ul><hr><h5 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h5><p>触发时机：Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size<span class="comment">#设置重写的基准值，最小文件 64MB，达到这个值开始重写</span></span><br><span class="line">auto-aof-rewrite-percentage percent<span class="comment">#触发AOF文件执行重写的增长率，当前AOF文件大小超过上一次重写的AOF文件大小的百分之多少才会重写，比如文件达到 100% 时开始重写就是两倍时触发</span></span><br></pre></td></tr></table></figure><p>自动重写触发比对参数（ 运行指令 <code>info Persistence</code> 获取具体信息 ）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aof_current_size<span class="comment">#AOF文件当前尺寸大小（单位:字节）</span></span><br><span class="line">aof_base_size<span class="comment">#AOF文件上次启动和重写时的尺寸大小（单位:字节）</span></span><br></pre></td></tr></table></figure><p>自动重写触发条件公式：</p><ul><li>aof_current_size &gt; auto-aof-rewrite-min-size</li><li>(aof_current_size - aof_base_size) &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage</li></ul><hr><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>RDB 的特点</p><ul><li><p>RDB 优点：</p><ul><li>RDB 是一个紧凑压缩的二进制文件，存储效率较高，但存储数据量较大时，存储效率较低</li><li>RDB 内部存储的是 Redis 在某个时间点的数据快照，非常<strong>适合用于数据备份，全量复制、灾难恢复</strong></li><li>RDB 恢复数据的速度要比 AOF 快很多，因为是快照，直接恢复</li></ul></li><li><p>RDB 缺点：</p><ul><li>BGSAVE 指令每次运行要执行 fork 操作创建子进程，会牺牲一些性能</li><li>RDB 方式无论是执行指令还是利用配置，无法做到实时持久化，具有丢失数据的可能性，最后一次持久化后的数据可能丢失</li><li>Redis 的众多版本中未进行 RDB 文件格式的版本统一，可能出现各版本之间数据格式无法兼容</li></ul></li></ul><p>AOF 特点：</p><ul><li>AOF 的优点：数据持久化有<strong>较好的实时性</strong>，通过 AOF 重写可以降低文件的体积</li><li>AOF 的缺点：文件较大时恢复较慢</li></ul><p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p><p>应用场景：</p><ul><li><p>对数据<strong>非常敏感</strong>，建议使用默认的 AOF 持久化方案，AOF 持久化策略使用 everysecond，每秒钟 fsync 一次，该策略 Redis 仍可以保持很好的处理性能</p><p>注意：AOF 文件存储体积较大，恢复速度较慢，因为要执行每条指令</p></li><li><p>数据呈现<strong>阶段有效性</strong>，建议使用 RDB 持久化方案，可以做到阶段内无丢失，且恢复速度较快</p><p>注意：利用 RDB 实现紧凑的数据持久化，存储数据量较大时，存储效率较低</p></li></ul><p>综合对比：</p><ul><li>RDB 与 AOF 的选择实际上是在做一种权衡，每种都有利有弊</li><li>灾难恢复选用 RDB</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用 AOF；如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用 RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后 Redis 优先使用 AOF 来恢复数据，降低丢失数据的量</li><li>不建议单独用 AOF，因为可能会出现 Bug，如果只是做纯内存缓存，可以都不用</li></ul><hr><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fork() 函数创建一个子进程，子进程与父进程几乎是完全相同的进程，系统先给子进程分配资源，然后把父进程的所有数据都复制到子进程中，只有少数值与父进程的值不同，相当于克隆了一个进程</p><p>在完成对其调用之后，会产生 2 个进程，且每个进程都会<strong>从 fork() 的返回处开始执行</strong>，这两个进程将执行相同的程序段，但是拥有各自不同的堆段，栈段，数据段，每个子进程都可修改各自的数据段，堆段，和栈段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 父进程返回子进程的pid，子进程返回0，错误返回负值，根据返回值的不同进行对应的逻辑处理</span></span><br></pre></td></tr></table></figure><p>fork 调用一次，却能够<strong>返回两次</strong>，可能有三种不同的返回值：</p><ul><li>在父进程中，fork 返回新创建子进程的进程 ID</li><li>在子进程中，fork 返回 0</li><li>如果出现错误，fork 返回一个负值，错误原因：<ul><li>当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</li><li>系统内存不足，这时 errno 的值被设置为 ENOMEM</li></ul></li></ul><p>fpid 的值在父子进程中不同：进程形成了链表，父进程的 fpid 指向子进程的进程 id，因为子进程没有子进程，所以其 fpid 为0</p><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的调度策略</p><p>每个进程都有一个独特（互不相同）的进程标识符 process ID，可以通过 getpid() 函数获得；还有一个记录父进程 pid 的变量，可以通过 getppid() 函数获得变量的值</p><hr><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>基本使用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">// fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    fpid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>, getpid());    </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>, getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count: %d/n&quot;</span>,count);<span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 输出内容：</span></span><br><span class="line"><span class="comment">    i am the child process, my process id is 5574</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">    i am the parent process, my process id is 5573</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>进阶使用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">   <span class="comment">// ppid 指当前进程的父进程pid  </span></span><br><span class="line">   <span class="comment">// pid 指当前进程的pid,  </span></span><br><span class="line">   <span class="comment">// fpid 指fork返回给当前进程的值，在这可以表示子进程</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;  </span><br><span class="line">       <span class="type">pid_t</span> fpid = fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid == <span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(), fpid);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(),fpid);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*输出内容：</span></span><br><span class="line"><span class="comment">i        父id  id  子id</span></span><br><span class="line"><span class="comment">0 parent 2043 3224 3225</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork函数使用演示.png" style="zoom: 80%;"><p>在 p3224 和 p3225 执行完第二个循环后，main 函数退出，进程死亡。所以 p3226，p3227 就没有父进程了，成为孤儿进程，所以 p3226 和 p3227 的父进程就被置为 ID 为 1 的 init 进程（笔记 Tool → Linux → 进程管理详解）</p><p><a href="https://blog.csdn.net/love_gaohz/article/details/41727415">参考文章</a></p><hr><h4 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h4><p>fork() 调用之后父子进程的内存关系</p><p>早期 Linux 的 fork() 实现时，就是全部复制，这种方法效率太低，而且造成了很大的内存浪费，现在 Linux 实现采用了两种方法：</p><ul><li><p>父子进程的代码段是相同的，所以代码段是没必要复制的，只需内核将代码段标记为只读，父子进程就共享此代码段。fork() 之后在进程创建代码段时，子进程的进程级页表项都指向和父进程相同的物理页帧</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系1.png" style="zoom: 67%;"></li><li><p>对于父进程的数据段，堆段，栈段中的各页，由于父子进程相互独立，采用<strong>写时复制 COW</strong> 的技术，来提高内存以及内核的利用率</p><p>在 fork 之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。如果两者的代码完全相同，代码段继续共享父进程的物理空间；而如果两者执行的代码不同，子进程的代码段也会分配单独的物理空间。   </p><p>fork 之后内核会将子进程放在队列的前面，让子进程先执行，以免父进程执行导致写时复制，而后子进程再执行，因无意义的复制而造成效率的下降</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系2.png" style="zoom:67%;"></li></ul><p>补充知识：</p><p>vfork（虚拟内存 fork virtual memory fork）：调用 vfork() 父进程被挂起，子进程使用父进程的地址空间。不采用写时复制，如果子进程修改父地址空间的任何页面，这些修改过的页面对于恢复的父进程是可见的</p><p><a href="https://blog.csdn.net/Shreck66/article/details/47039937">参考文章</a></p><hr><h2 id="事务机制-1"><a href="#事务机制-1" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="事务特征"><a href="#事务特征" class="headerlink" title="事务特征"></a>事务特征</h3><p>Redis 事务就是将多个命令请求打包，然后<strong>一次性、按顺序</strong>地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务去执行其他的命令请求，会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求，Redis 事务的特性：</p><ul><li>Redis 事务<strong>没有隔离级别</strong>的概念，队列中的命令在事务没有提交之前都不会实际被执行</li><li>Redis 单条命令式保存原子性的，但是事务<strong>不保证原子性</strong>，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><hr><h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p>事务的执行流程分为三个阶段：</p><ul><li><p>事务开始：MULTI 命令的执行标志着事务的开始，通过在客户端状态的 flags 属性中打开 REDIS_MULTI 标识，将执行该命令的客户端从非事务状态切换至事务状态</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MULTI<span class="comment"># 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span></span><br></pre></td></tr></table></figure></li><li><p>命令入队：事务队列以先进先出（FIFO）的方式保存入队的命令，每个 Redis 客户端都有事务状态，包含着事务队列：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;<span class="comment">/* MULTI/EXEC state */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果命令为 EXEC、DISCARD、WATCH、MULTI 四个命中的一个，那么服务器立即执行这个命令</li><li>其他命令服务器不执行，而是将命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</li></ul></li><li><p>事务执行：EXEC 提交事务给服务器执行，服务器会遍历这个客户端的事务队列，执行队列中的命令并将执行结果返回</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXEC<span class="comment"># Commit 提交，执行事务，与multi成对出现，成对使用</span></span><br></pre></td></tr></table></figure></li></ul><p>事务取消的方法：</p><ul><li><p>取消事务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISCARD<span class="comment"># 终止当前事务的定义，发生在multi之后，exec之前</span></span><br></pre></td></tr></table></figure><p>一般用于事务执行过程中输入了错误的指令，直接取消这次事务，类似于回滚</p></li></ul><hr><h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="监视机制"><a href="#监视机制" class="headerlink" title="监视机制"></a>监视机制</h4><p>WATCH 命令是一个乐观锁（optimistic locking），可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复</p><ul><li><p>添加监控锁</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WATCH key1 [key2……]<span class="comment">#可以监控一个或者多个key</span></span><br></pre></td></tr></table></figure></li><li><p>取消对所有 key 的监视</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UNWATCH</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>每个 Redis 数据库都保存着一个 watched_keys 字典，键是某个被 WATCH 监视的数据库键，值则是一个链表，记录了所有监视相应数据库键的客户端：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"><span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对数据库进行修改的命令，在执行后都会调用 <code>multi.c/touchWatchKey</code> 函数对 watched_keys 字典进行检查，是否有客户端正在监视刚被命令修改过的数据库键，如果有的话函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示该客户端的事务安全性已经被破坏</p><p>服务器接收到个客户端 EXEC 命令时，会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识，如果打开了说明客户端提交事务不安全，服务器会拒绝执行</p><hr><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p><p>原子性指事务队列中的命令要么就全部都执行，要么一个都不执行，但是在命令执行出错时，不会保证原子性（下一节详解）</p><p>Redis 不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止</p><p>回滚需要程序员在代码中实现，应该尽可能避免：</p><ul><li><p>事务操作之前记录数据的状态</p><ul><li><p>单数据：string</p></li><li><p>多数据：hash、list、set、zset</p></li></ul></li><li><p>设置指令恢复所有的被修改的项</p><ul><li><p>单数据：直接 set（注意周边属性，例如时效）</p></li><li><p>多数据：修改对应值或整体克隆复制</p></li></ul></li></ul><hr><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务具有一致性指的是，数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的</p><p>一致是数据符合数据库的定义和要求，没有包含非法或者无效的错误数据，Redis 通过错误检测和简单的设计来保证事务的一致性：</p><ul><li><p>入队错误：命令格式输入错误，出现语法错误造成，<strong>整体事务中所有命令均不会执行</strong>，包括那些语法正确的命令</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令的语法错误.png" style="zoom:80%;"></li><li><p>执行错误：命令执行出现错误，例如对字符串进行 incr 操作，事务中正确的命令会被执行，运行错误的命令不会被执行</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-事务中执行错误.png" style="zoom:80%;"></li><li><p>服务器停机：</p><ul><li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据库是一致的</li><li>如果服务器运行在持久化模式下，重启之后将数据库还原到一致的状态</li></ul></li></ul><hr><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>Redis 是一个单线程的执行原理，所以对于隔离性，分以下两种情况：</p><ul><li>并发操作在 EXEC 命令前执行，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证</li><li>并发操作在 EXEC 命令后执行，隔离性可以保证</li></ul><hr><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>Redis 并没有为事务提供任何额外的持久化功能，事务的持久性由 Redis 所使用的持久化模式决定</p><p>配置选项 <code>no-appendfsync-on-rewrite</code> 可以配合 appendfsync 选项在 AOF 持久化模式使用：</p><ul><li>选项打开时在执行 BGSAVE 或者 BGREWRITEAOF 期间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少 I&#x2F;O 阻塞</li><li>选项打开时运行在 always 模式的 AOF 持久化，事务也不具有持久性，所以该选项默认关闭</li></ul><p>在一个事务的最后加上 SAVE 命令总可以保证事务的耐久性</p><hr><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="环境创建"><a href="#环境创建" class="headerlink" title="环境创建"></a>环境创建</h3><h4 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 对 Lua 脚本支持，通过在服务器中嵌入 Lua 环境，客户端可以使用 Lua 脚本直接在服务器端<strong>原子地执行</strong>多个命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br></pre></td></tr></table></figure><p>EVAL 命令可以直接对输入的脚本计算：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">&quot;return 1 + 1&quot;</span> 0<span class="comment"># 0代表需要的参数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure><p>EVALSHA 命令根据脚本的 SHA1 校验和来对脚本计算：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVALSHA <span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure><p>应用场景：Redis 只保证单条命令的原子性，所以为了实现原子操作，将多条的对 Redis 的操作整合到一个脚本里，但是避免把不需要做并发控制的操作写入脚本中</p><p>Lua 语法特点：</p><ul><li>声明变量的时候无需指定数据类型，而是用 local 来声明变量为局部变量</li><li>数组下标是从 1 开始</li></ul><hr><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>Redis 服务器创建并修改 Lua 环境的整个过程：</p><ul><li><p>创建一个基础的 Lua 环境，调用 Lua 的 API 函数 lua_open</p></li><li><p>载入多个函数库到 Lua 环境里面，让 Lua 脚本可以使用这些函数库来进行数据操作，包括基础核心函数</p></li><li><p>创建全局变量 redis 表格，表格包含以下函数：</p><ul><li>执行 Redis 命令的 redis.call 和 redis.pcall 函数</li><li>记录 Redis 日志的 redis.log 函数，以及相应的日志级别 (level) 常量 redis.LOG_DEBUG 等</li><li>计算 SHAl 校验和的 redis.shalhex 函数</li><li>返回错误信息的 redis.error_reply 函数和 redis.status_reply 函数</li></ul></li><li><p>使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数，从而避免在脚本中引入副作用</p><p>Redis 要求所有传入服务器的 Lua 脚本，以及 Lua 环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function），所以对有副作用的随机函数 <code>math.random</code> 和 <code>math.randornseed</code> 进行替换</p></li><li><p>创建排序辅助函数 <code> _redis_compare_helper</code>，使用辅助函数来对一部分 Redis 命令的结果进行排序，从而消除命令的不确定性</p><p>比如集合元素的排列是无序的， 所以即使两个集合的元素完全相同，输出结果也不一定相同，Redis 将 SMEMBERS 这类在相同数据集上产生不同输出的命令称为带有不确定性的命令</p></li><li><p>创建 redis.pcall 函数的错误报告辅助函数 <code>_redis_err_handler </code>，这个函数可以打印出错代码的来源和发生错误的行数</p></li><li><p>对 Lua 环境中的全局环境进行保护，确保传入服务器的脚本不会因忘记使用 local 关键字，而将额外的全局变量添加到 Lua 环境</p></li><li><p>将完成修改的 Lua 环境保存到服务器状态的 lua 属性中，等待执行服务器传来的 Lua 脚本</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    Lua *lua;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>Redis 使用串行化的方式来执行 Redis 命令，所以在任何时间里最多都只会有一个脚本能够被放进 Lua 环境里面运行，因此整个 Redis 服务器只需要创建一个 Lua 环境即可</p><hr><h3 id="协作组件"><a href="#协作组件" class="headerlink" title="协作组件"></a>协作组件</h3><h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>Redis 服务器为 Lua 环境创建了一个伪客户端负责处理 Lua 脚本中包含的所有 Redis 命令，工作流程：</p><ul><li>Lua 环境将 redis.call 或者 redis.pcall 函数想要执行的命令传给伪客户端</li><li>伪客户端将命令传给命令执行器</li><li>命令执行器执行命令并将命令的执行结果返回给伪客户端</li><li>伪客户端接收命令执行器返回的命令结果，并将结果返回给 Lua 环境</li><li>Lua 将命令结果返回给 redis.call 函数或者 redis.pcall 函数</li><li>redis.call 函数或者 redis.pcall 函数会将命令结果作为返回值返回给脚本的调用者</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Lua%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C.png"></p><hr><h4 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h4><p>Redis 服务器为 Lua 环境创建 lua_scripts 字典，键为某个 Lua 脚本的 SHA1 校验和（checksum），值则是校验和对应的 Lua 脚本</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    dict *lua_scripts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器会将所有被 EVAL 命令执行过的 Lua 脚本，以及所有被 SCRIPT LOAD 命令载入过的 Lua 脚本都保存到 lua_scripts 字典</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> <span class="comment"># 字典的键，SHA1 校验和</span></span><br></pre></td></tr></table></figure><hr><h3 id="命令实现-1"><a href="#命令实现-1" class="headerlink" title="命令实现"></a>命令实现</h3><h4 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h4><p>EVAL 命令的执行的第一步是为传入的脚本定义一个相对应的 Lua 函数，Lua 函数的名字由 f_ 前缀加上脚本的 SHA1 校验和（四十个字符长）组成，而函数的体（body）则是脚本本身</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return &#x27;hello world&#x27;&quot;</span> 0 </span><br><span class="line"><span class="comment"># 命令将会定义以下的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f_533203lc6b470dc5a0dd9b4bf2030dea6d65de91</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数来保存客户端传入的脚本有以下优点：</p><ul><li>通过函数的局部性来让 Lua 环境保持清洁，减少了垃圾回收的工作最， 并且避免了使用全局变量</li><li>如果某个脚本在 Lua 环境中被定义过至少一次，那么只需要 SHA1 校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用 Lua 函数来执行脚本</li></ul><p>EVAL 命令第二步是将客户端传入的脚本保存到服务器的 lua_scripts 字典里，在字典中新添加一个键值对</p><hr><h4 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h4><p>EVAL 命令第三步是执行脚本函数</p><ul><li><p>将 EVAL 命令中传入的<strong>键名参数和脚本参数</strong>分别保存到 KEYS 数组和 ARGV 数组，将这两个数组作为<strong>全局变量</strong>传入到 Lua 环境</p></li><li><p>为 Lua 环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过 <code>SCRIPT KILL</code> 命令停止脚本，或者通过 SHUTDOWN 命令直接关闭服务器</p><p>因为 Redis 是单线程的执行命令，当 Lua 脚本阻塞时需要兜底策略，可以中断执行</p></li><li><p>执行脚本函数</p></li><li><p>移除之前装载的超时钩子</p></li><li><p>将执行脚本函数的结果保存到客户端状态的输出缓冲区里，等待服务器将结果返回给客户端</p></li></ul><hr><h4 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的实现原理就是根据脚本的 SHA1 校验和来调用<strong>脚本对应的函数</strong>，如果函数在 Lua 环境中不存在，找不到 f_ 开头的函数，就会返回 <code>SCRIPT NOT FOUND</code></p><hr><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>Redis 中与 Lua 脚本有关的管理命令有四个：</p><ul><li><p>SCRIPT FLUSH：用于清除服务器中所有和 Lua 脚本有关的信息，会释放并重建 lua_scripts 字典，关闭现有的 Lua 环境并重新创建一个新的 Lua 环境</p></li><li><p>SCRIPT EXISTS：根据输入的 SHA1 校验和（允许一次传入多个校验和），检查校验和对应的脚本是否存在于服务器中，通过检查 lua_scripts 字典实现</p></li><li><p>SCRIPT LOAD：在 Lua 环境中为脚本创建相对应的函数，然后将脚本保存到 lua_scripts字典里</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>SCRIPT KILL：停止脚本</p></li></ul><p>如果服务器配置了 lua-time-li­mit 选项，那么在每次执行 Lua 脚本之前，都会设置一个超时处理的钩子。钩子会在脚本运行期间会定期检查运行时间是否超过配置时间，如果超时钩子将定期在脚本运行的间隙中，查看是否有 SCRIPT KILL 或者 SHUTDOWN 到达：</p><ul><li>如果超时运行的脚本没有执行过写入操作，客户端可以通过 SCRIPT KILL 来停止这个脚本</li><li>如果执行过写入操作，客户端只能用 SHUTDOWN nosave 命令来停止服务器，防止不合法的数据被写入数据库中</li></ul><hr><h3 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h3><h4 id="命令复制"><a href="#命令复制" class="headerlink" title="命令复制"></a>命令复制</h4><p>当服务器运行在复制模式时，具有写性质的脚本命令也会被复制到从服务器，包括 EVAL、EVALSHA、SCRIPT FLUSH，以及 SCRIPT LOAD 命令</p><p>Redis 复制 EVAL、SCRIPT FLUSH、SCRIPT LOAD 三个命令的方法和复制普通 Redis 命令的方法一样，当主服务器执行完以上三个命令的其中一个时，会直接将被执行的命令传播（propagate）给所有从服务器，在从服务器中产生相同的效果</p><hr><h4 id="EVALSHA-1"><a href="#EVALSHA-1" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的复制操作相对复杂，因为多个从服务器之间载入 Lua 脚本的清况各有不同，一个在主服务器被成功执行的 EVALSHA 命令，在从服务器执行时可能会出现脚本未找到（not found）错误</p><p>Redis 要求主服务器在传播 EVALSHA 命令时，必须确保 EVALSHA 命令要执行的脚本已经被所有从服务器载入过，如果不能确保主服务器会<strong>将 EVALSHA 命令转换成一个等价的 EVAL 命令</strong>，然后通过传播 EVAL 命令来代替 EVALSHA 命令</p><p>主服务器使用服务器状态的 repl_scriptcache_dict 字典记录已经将哪些脚本传播给了<strong>所有从服务器</strong>，当一个校验和出现在字典时，说明校验和对应的 Lua 脚本已经传播给了所有从服务器，主服务器可以直接传播 EVALSHA 命令</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键是一个个 Lua 脚本的 SHA1 校验和，值则全部都是 NULL</span></span><br><span class="line">    dict *repl_scriptcache_dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每当主服务器添加一个新的从服务器时，都会清空 repl_scriptcache_dict 字典，因为字典里面记录的脚本已经不再被所有从服务器载入过，所以服务器以清空字典的方式，强制重新向所有从服务器传播脚本</p><p>通过使用 EVALSHA 命令指定的 SHA1 校验和，以及 lua_scripts 字典保存的 Lua 脚本，可以将一个 EVALSHA 命令转化为 EVAL 命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVALSHA <span class="string">&quot;533203lc6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span> 0 </span><br><span class="line"><span class="comment"># -&gt; 转换</span></span><br><span class="line">EVAL <span class="string">&quot;return&#x27;hello world&#x27;&quot;</span> 0 </span><br></pre></td></tr></table></figure><p>脚本内容 <code>&quot;return&#39;hello world&#39;&quot;</code> 来源于 lua_scripts 字典 533203lc6b470dc5a0dd9b4bf2030dea6d65de91 键的值</p><hr><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><p>在分布式场景下，锁变量需要由一个共享存储系统来维护，多个客户端才可以通过访问共享存储系统来访问锁变量，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值多步操作</p><p>Redis 分布式锁的基本使用，悲观锁</p><ul><li><p>使用 SETNX 设置一个公共锁</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETNX lock-key value<span class="comment"># value任意数，返回为1设置成功，返回为0设置失败</span></span><br></pre></td></tr></table></figure><p><code>NX</code>：只在键不存在时，才对键进行设置操作，<code>SET key value NX</code> 效果等同于 <code>SETNX key value</code></p><p><code>XX</code>：只在键已经存在时，才对键进行设置操作</p><p><code>EX</code>：设置键 key 的过期时间，单位时秒</p><p><code>PX</code>：设置键 key 的过期时间，单位时毫秒</p><p>说明：由于 <code>SET</code> 命令加上选项已经可以完全取代 SETNX、SETEX、PSETEX 的功能，Redis 不推荐使用这几个命令</p></li><li><p>操作完毕通过 DEL 操作释放锁</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DEL lock-key </span><br></pre></td></tr></table></figure></li><li><p>使用 EXPIRE 为锁 key 添加存活（持有）时间，过期自动删除（放弃）锁，防止线程出现异常，无法释放锁</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXPIRE lock-key second </span><br><span class="line">PEXPIRE lock-key milliseconds</span><br></pre></td></tr></table></figure><p>通过 EXPIRE 设置过期时间缺乏原子性，如果在 SETNX 和 EXPIRE 之间出现异常，锁也无法释放</p></li><li><p>在 SET 时指定过期时间，保证原子性</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SET key value NX [EX seconds | PX milliseconds]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h3><p>场景描述：线程 A 正在执行，但是业务阻塞，在锁的过期时间内未执行完成，过期删除后线程 B 重新获取到锁，此时线程 A 执行完成，删除锁，导致线程 B 的锁被线程 A 误删</p><p>SETNX 获取锁时，设置一个指定的唯一值（UUID），释放前获取这个值，判断是否自己的锁，防止出现线程之间误删了其他线程的锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁, unique_value作为客户端唯一性的标识，</span></span><br><span class="line"><span class="comment">// PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁</span></span><br><span class="line">SET lock_key unique_value NX PX <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Lua 脚本（unlock.script）实现的释放锁操作的伪代码：key 类型参数会放入 KEYS 数组，其它参数会放入 ARGV 数组，在脚本中通过 KEYS 和 ARGV 传递参数，<strong>保证判断标识和释放锁这两个操作的原子性</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> 1 lock_key unique_value <span class="comment"># 1 代表需要一个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁，KEYS[1] 就是锁的 key，ARGV[1] 就是标识值，避免误释放</span></span><br><span class="line"><span class="comment">// 获取标识值，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><hr><h3 id="优化锁-1"><a href="#优化锁-1" class="headerlink" title="优化锁"></a>优化锁</h3><h4 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h4><p>不可重入：同一个线程无法多次获取同一把锁</p><p>使用 hash 键，filed 是加锁的线程标识， value 是<strong>锁重入次数</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span>    key    <span class="operator">|</span>       <span class="keyword">value</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="operator">|</span>  filed  <span class="operator">|</span>  <span class="keyword">value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------------------------|</span></span><br><span class="line"><span class="operator">|</span>  lock_key <span class="operator">|</span> thread1 <span class="operator">|</span>    <span class="number">1</span>    <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>锁重入：</p><ul><li>加锁时判断锁的 filed 属性是否是当前线程，如果是将 value 加 1</li><li>解锁时判断锁的 filed 属性是否是当前线程，首先将 value 减一，如果 value 为 0 直接释放锁</li></ul><p>使用 Lua 脚本保证多条命令的原子性</p><hr><h4 id="不可重试"><a href="#不可重试" class="headerlink" title="不可重试"></a>不可重试</h4><p>不可重试：获取锁只尝试一次就返回 false，没有重试机制</p><ul><li>利用 Lua 脚本尝试获取锁，获取失败获取锁的剩余超时时间 ttl，或者通过参数传入线程抢锁允许等待的时间</li><li>利用订阅功能订阅锁释放的信息，然后线程挂起等待 ttl 时间</li><li>利用 Lua 脚本在释放锁时，发布一条锁释放的消息</li></ul><hr><h4 id="超时释放"><a href="#超时释放" class="headerlink" title="超时释放"></a>超时释放</h4><p>超时释放：锁超时释放可以避免死锁，但如果是业务执行耗时较长，需要进行锁续时，防止业务未执行完提前释放锁</p><p>看门狗 Watch Dog 机制：</p><ul><li>获取锁成功后，提交周期任务，每隔一段时间（Redisson 中默认为过期时间 &#x2F; 3），重置一次超时时间</li><li>如果服务宕机，Watch Dog 机制线程就停止，就不会再延长 key 的过期时间</li><li>释放锁后，终止周期任务</li></ul><hr><h4 id="主从一致"><a href="#主从一致" class="headerlink" title="主从一致"></a>主从一致</h4><p>主从一致性：集群模式下，主从同步存在延迟，当加锁后主服务器宕机时，从服务器还没同步主服务器中的锁数据，此时从服务器升级为主服务器，其他线程又可以获取到锁</p><p>将服务器升级为多主多从：</p><ul><li>获取锁需要从所有主服务器 SET 成功才算获取成功</li><li>某个 master 宕机，slave 还没有同步锁数据就升级为 master，其他线程尝试加锁会加锁失败，因为其他 master 上已经存在该锁</li></ul><hr><h2 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="主从介绍"><a href="#主从介绍" class="headerlink" title="主从介绍"></a>主从介绍</h4><p>主从复制：一个服务器去复制另一个服务器，被复制的服务器为主服务器 master，复制的服务器为从服务器 slave</p><ul><li>master 用来<strong>写数据</strong>，执行写操作时，将出现变化的数据自动同步到 slave，很少会进行读取操作</li><li>slave 用来读数据，禁止在 slave 服务器上进行读操作</li></ul><p>进行复制中的主从服务器双方的数据库将保存相同的数据，将这种现象称作<strong>数据库状态一致</strong></p><p>主从复制的特点：</p><ul><li><p><strong>薪火相传</strong>：一个 slave 可以是下一个 slave 的 master，slave 同样可以接收其他 slave 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险</p><p>注意：主机挂了，从机还是从机，无法写数据了</p></li><li><p><strong>反客为主</strong>：当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不做任何修改</p></li></ul><p>主从复制的作用：</p><ul><li><strong>读写分离</strong>：master 写、slave 读，提高服务器的读写负载能力</li><li><strong>负载均衡</strong>：基于主从结构，配合读写分离，由 slave 分担 master 负载，并根据需求的变化，改变 slave 的数量，通过多个从节点分担数据读取负载，大大提高 Redis 服务器并发量与数据吞吐量</li><li>故障恢复：当 master 出现问题时，由 slave 提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现 Redis 的高可用方案</li></ul><p><strong>三高</strong>架构：</p><ul><li><p>高并发：应用提供某一业务要能支持很多客户端同时访问的能力，称为并发</p></li><li><p>高性能：性能最直观的感受就是速度快，时间短</p></li><li><p>高可用：</p><ul><li>可用性：应用服务在全年宕机的时间加在一起就是全年应用服务不可用的时间</li><li>业界可用性目标 5 个 9，即 99.999%，即服务器年宕机时长低于 315 秒，约 5.25 分钟</li></ul></li></ul><hr><h4 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h4><p>系统状态指令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INFO replication</span><br></pre></td></tr></table></figure><p>master 和 slave 互连：</p><ul><li><p>方式一：客户端发送命令，设置 slaveof 选项，产生主从结构</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure></li><li><p>方式二：服务器带参启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server --slaveof masterip masterport</span><br></pre></td></tr></table></figure></li><li><p>方式三：服务器配置（主流方式）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure></li></ul><p>主从断开连接：</p><ul><li><p>slave 断开连接后，不会删除已有数据，只是不再接受 master 发送的数据，可以作<strong>为从服务器升级为主服务器的指令</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li></ul><p>授权访问：master 有服务端和客户端，slave 也有服务端和客户端，不仅服务端之间可以发命令，客户端也可以</p><ul><li><p>master 客户端发送命令设置密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">requirepass password</span><br></pre></td></tr></table></figure><p>master 配置文件设置密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass password</span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li><li><p>slave 客户端发送命令设置密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><p>slave 配置文件设置密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">masterauth password</span><br></pre></td></tr></table></figure><p>slave 启动服务器设置密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server –a password</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h3><h4 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h4><p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作，主从库间的复制是<strong>异步进行的</strong></p><p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态，该过程又叫全量复制：</p><ul><li>从服务器向主服务器发送 SYNC 命令来进行同步</li><li>收到 SYNC 的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个<strong>缓冲区</strong>记录从现在开始执行的所有<strong>写命令</strong></li><li>当 BGSAVE 命令执行完毕时，主服务器会将 RDB 文件发送给从服务器</li><li>从服务接收并载入 RDB 文件（从服务器会<strong>清空原有数据</strong>）</li><li>缓冲区记录了 RDB 文件所在状态后的所有写命令，主服务器将在缓冲区的所有命令发送给从服务器，从服务器执行这些写命令</li><li>至此从服务器的数据库状态和主服务器一致</li></ul><p>命令传播用于在主服务器的数据库状态被修改，导致主从数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态</p><ul><li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器</li><li>从服务器接受命令并执行，主从服务器将再次回到一致状态</li></ul><hr><h4 id="功能缺陷"><a href="#功能缺陷" class="headerlink" title="功能缺陷"></a>功能缺陷</h4><p>SYNC 本身就是一个非常消耗资源的操作，每次执行 SYNC 命令，都需要执行以下动作：</p><ul><li>生成 RDB 文件，耗费主服务器大量 CPU 、内存和磁盘 I&#x2F;O 资源</li><li>RDB 文件发送给从服务器，耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li><li>从服务器载入 RDB 文件，期间会因为阻塞而没办法处理命令请求</li></ul><p>SYNC 命令下的从服务器对主服务器的复制分为两种情况：</p><ul><li>初次复制：从服务器没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</li><li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，自动重连后并继续复制主服务器</li></ul><p>旧版复制在断线后重复制时，也会创建 RDB 文件进行<strong>全量复制</strong>，但是从服务器只需要断线时间内的这部分数据，所以旧版复制的实现方式非常浪费资源</p><hr><h4 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h4><p>Redis 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的<strong>同步操作</strong>（命令传播阶段相同），解决了旧版复制在处理断线重复制情况的低效问题</p><p>PSYNC 命令具有完整重同步（full resynchronization）和<strong>部分重同步</strong>（partial resynchronization）两种模式：</p><ul><li>完整重同步：处理初次复制情况，执行步骤和 SYNC命令基本一样</li><li>部分重同步：处理断线后重复制情况，主服务器可以将主从连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态，该过程又叫<strong>部分复制</strong></li></ul><hr><h3 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h3><p>部分重同步功能由以下三个部分构成：</p><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行 ID (run ID)</li></ul><h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><p>主服务器和从服务器会分别维护一个复制偏移量：</p><ul><li><p>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p></li><li><p>从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p></li></ul><p>通过对比主从服务器的复制偏移量，可以判断主从服务器是否处于一致状态</p><ul><li>主从服务器的偏移量是相同的，说明主从服务器处于一致状态</li><li>主从服务器的偏移量是不同的，说明主从服务器处于不一致状态</li></ul><hr><h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为 1MB</p><ul><li>出队规则跟普通的先进先出队列一样</li><li>入队规则是当入队元素的数量大于队列长度时，最先入队的元素会被弹出，然后新元素才会被放入队列</li></ul><p>当主服务器进行<strong>命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区</strong>，缓冲区会保存着一部分最近传播的写命令，并且缓冲区会为队列中的每个字节记录相应的复制偏移量</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%A4%8D%E5%88%B6%E7%A7%AF%E5%8E%8B%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p><p>从服务器会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p><ul><li>offset 之后的数据（即 offset+1）仍然存在于复制积压缓冲区里，那么主服务器将对从服务器执行部分重同步操作</li><li>offset 之后的数据已经不在复制积压缓冲区，说明部分数据已经丢失，那么主服务器将对从服务器执行完整重同步操作</li></ul><p>复制缓冲区大小设定不合理，会导致<strong>数据溢出</strong>。比如主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间较长，导致缓冲区中的数据已经丢失，则必须进行完整重同步</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-backlog-size ?mb</span><br></pre></td></tr></table></figure><p>建议设置如下，这样可以保证绝大部分断线情况都能用部分重同步来处理：</p><ul><li>从服务器断线后重新连接上主服务器所需的平均时间 second</li><li>获取 master 平均每秒产生写命令数据总量 write_size_per_second</li><li>最优复制缓冲区空间 &#x3D; 2 * second * write_size_per_second</li></ul><hr><h4 id="运行ID"><a href="#运行ID" class="headerlink" title="运行ID"></a>运行ID</h4><p>服务器运行 ID（run ID）：是每一台服务器每次运行的身份识别码，在服务器启动时自动生成，由 40 位随机的十六进制字符组成，一台服务器多次运行可以生成多个运行 ID</p><p>作用：服务器间进行传输识别身份，如果想两次操作均对同一台服务器进行，<strong>每次必须操作携带对应的运行 ID</strong>，用于对方识别</p><p>从服务器对主服务器进行初次复制时，主服务器将自己的运行 ID 传送给从服务器，然后从服务器会将该运行 ID 保存。当从服务器断线并重新连上一个主服务器时，会向当前连接的主服务器发送之前保存的运行 ID：</p><ul><li>如果运行 ID 和当前连接的主服务器的运行 ID 相同，说明从服务器断线之前复制的就是当前连接的这个主服务器，执行部分重同步</li><li>如果不同，需要执行完整重同步操作</li></ul><hr><h4 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h4><p>PSYNC 命令的调用方法有两种</p><ul><li>如果从服务器之前没有复制过任何主服务器，或者执行了 <code>SLAVEOF no one</code>，开始一次新的复制时将向主服务器发送 <code>PSYNC ? -1</code> 命令，主动请求主服务器进行完整重同步</li><li>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令，runid 是上一次复制的主服务器的运行 ID，offset 是复制的偏移量</li></ul><p>接收到 PSYNC 命令的主服务器会向从服务器返回以下三种回复的其中一种：</p><ul><li>执行完整重同步操作：返回 <code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，runid 是主服务器的运行 ID，offset 是主服务器的复制偏移量</li><li>执行部分重同步操作：返回 <code>+CONTINUE</code>，从服务器收到该回复说明只需要等待主服务器发送缺失的部分数据即可</li><li>主服务器的版本低于 Redis2.8：返回 <code>-ERR</code>，版本过低识别不了 PSYNC，从服务器将向主服务器发送 SYNC 命令</li></ul><hr><h3 id="复制实现"><a href="#复制实现" class="headerlink" title="复制实现"></a>复制实现</h3><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>通过向从服务器发送 SLAVEOF 命令，可以让从服务器去复制一个主服务器</p><ul><li><p>设置主服务器的地址和端口：将 SLAVEOF 命令指定的 ip 和 port 保存到服务器状态 redisServer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// 主服务器的地址 </span></span><br><span class="line">    <span class="type">char</span> *masterhost; </span><br><span class="line"> <span class="comment">//主服务器的端口 </span></span><br><span class="line">    <span class="type">int</span> masterport; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SLAVEOF 命令是一个<strong>异步命令</strong>，在完成属性的设置后服务器直接返回 OK，而实际的复制工作将在 OK 返回之后才真正开始执行</p></li><li><p>建立套接字连接：</p><ul><li>从服务器 connect 主服务器建立套接字连接，成功后从服务器将为这个套接字关联一个用于复制工作的文件事件处理器，负责执行后续的复制工作，如接收 RDB 文件、接收主服务器传播来的写命令等</li><li>主服务器在接受 accept 从务器的套接字连接后，将为该套接字创建相应的客户端状态，将从服务器看作一个客户端，从服务器将同时具有 server 和 client（可以发命令）两个身份</li></ul></li><li><p>发送 PING 命令：从服务器向主服务器发送一个 PING 命令，检查主从之间的通信是否正常、主服务器处理命令的能力是否正常</p><ul><li>返回错误，表示主服务器无法处理从服务器的命令请求（忙碌），从服务器断开并重新创建连向主服务器的套接字</li><li>返回命令回复，但从服务器不能在规定的时间内读取出命令回复的内容，表示主从之间的网络状态不佳，需要断开重连</li><li>读取到 PONG，表示一切状态正常，可以执行复制</li></ul></li><li><p>身份验证：如果从服务器设置了 masterauth 选项就进行身份验证，将向主服务器发送一条 AUTH 命令，命令参数为从服务器 masterauth 选项的值，如果主从设置的密码不相同，那么主将返回一个 invalid password 错误</p></li><li><p>发送端口信息：身份验证后</p><ul><li>从服务器执行命令 <code>REPLCONF listening-port &lt;port­number&gt;</code>， 向主服务器发送从服务器的监听端口号</li><li>主服务器在接收到这个命令后，会将端口号记录在对应的客户端状态 redisClient.slave_listening_port 属性中：</li></ul></li><li><p>同步：从服务器将向主服务器发送 PSYNC 命令，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，可以相互发送命令</p><ul><li><p>完整重同步：主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行</p></li><li><p>部分重同步：主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</p></li></ul></li><li><p>命令传播：主服务器将写命令发送给从服务器，保持数据库的状态一致</p></li></ul><hr><h4 id="复制图示"><a href="#复制图示" class="headerlink" title="复制图示"></a>复制图示</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E6%9B%B4%E6%96%B0.png"></p><hr><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>心跳机制：进入命令传播阶段，<strong>从服务器</strong>默认会以每秒一次的频率，<strong>向主服务器发送命令</strong>：<code>REPLCONF ACK &lt;replication_offset&gt;</code>，replication_offset 是从服务器当前的复制偏移量</p><p>心跳的作用：</p><ul><li>检测主从服务器的网络连接状态</li><li>辅助实现 min-slaves 选项</li><li>检测命令丢失</li></ul><hr><h4 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h4><p>如果主服务器超过一秒钟没有收到从服务器发来的 REPLCONF ACK 命令，主服务就认为主从服务器之间的连接出现问题</p><p>向主服务器发送 <code>INFO replication</code> 命令，lag 一栏表示从服务器最后一次向主服务器发送 ACK 命令距离现在多少秒：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO replication </span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">connected_slaves:2 </span><br><span class="line">slave0: ip=127.0.0.1,port=11111,state=online,offset=123,lag=0 <span class="comment"># 刚刚发送过 REPLCONF ACK </span></span><br><span class="line">slavel: ip=127.0.0.1,port=22222,state=online,offset=456,lag=3 <span class="comment"># 3秒之前发送过REPLCONF ACK </span></span><br></pre></td></tr></table></figure><p>在一般情况下，lag 的值应该在 0 或者 1 秒之间跳动，如果超过 1 秒说明主从服务器之间的连接出现了故障</p><hr><h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><p>Redis 的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在<strong>不安全的情况下</strong>拒绝执行写命令</p><p>比如向主服务器设置：</p><ul><li>min-slaves-to-write：主库最少有 N 个健康的从库存活才能执行写命令，没有足够的从库直接拒绝写入</li><li>min-slaves-max-lag：从库和主库进行数据复制时的 ACK 消息延迟的最大时间</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 5</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>那么在从服务器的数少于 5 个，或者 5 个从服务器的延迟（lag）值都大于或等于10 秒时，主服务器将拒绝执行写命令</p><hr><h4 id="命令丢失"><a href="#命令丢失" class="headerlink" title="命令丢失"></a>命令丢失</h4><p>检测命令丢失：由于网络或者其他原因，主服务器传播给从服务器的写命令丢失，那么当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器会检查从服务器的复制偏移量是否小于自己的，然后在复制积压缓冲区里找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p><p>说明：REPLCONF ACK 命令和复制积压缓冲区都是 Redis 2.8 版本新增的，在 Redis 2.8 版本以前，即使命令在传播过程中丢失，主从服务器都不会注意到，也不会向从服务器补发丢失的数据，所以为了保证<strong>主从复制的数据一致性</strong>，最好使用 2.8 或以上版本的 Redis</p><hr><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="重启恢复"><a href="#重启恢复" class="headerlink" title="重启恢复"></a>重启恢复</h4><p>系统不断运行，master 的数据量会越来越大，一旦 <strong>master 重启</strong>，runid 将发生变化，会导致全部 slave 的全量复制操作</p><p>解决方法：本机保存上次 runid，重启后恢复该值，使所有 slave 认为还是之前的 master</p><p>优化方案：</p><ul><li><p>master 内部创建 master_replid 变量，使用 runid 相同的策略生成，并发送给所有 slave</p></li><li><p>在 master 关闭时执行命令 <code>shutdown save</code>，进行 RDB 持久化，将 runid 与 offset 保存到 RDB 文件中</p><p><code>redis-check-rdb dump.rdb</code> 命令可以查看该信息，保存为 repl-id 和 repl-offset</p></li><li><p>master 重启后加载 RDB 文件，恢复数据，将 RDB 文件中保存的 repl-id 与 repl-offset 加载到内存中，master_repl_id &#x3D; repl-id，master_repl_offset &#x3D; repl-offset</p></li><li><p>通过 info 命令可以查看该信息</p></li></ul><hr><h4 id="网络中断"><a href="#网络中断" class="headerlink" title="网络中断"></a>网络中断</h4><p>master 的 CPU 占用过高或 slave 频繁断开连接</p><ul><li><p>出现的原因：</p><ul><li>slave 每 1 秒发送 REPLCONF ACK 命令到 master</li><li>当 slave 接到了慢查询时（keys * ，hgetall 等），会大量占用 CPU 性能</li><li>master 每 1 秒调用复制定时函数 replicationCron()，比对 slave 发现长时间没有进行响应</li></ul><p>最终导致 master 各种资源（输出缓冲区、带宽、连接等）被严重占用</p></li><li><p>解决方法：通过设置合理的超时时间，确认是否释放 slave</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-timeout<span class="comment"># 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</span></span><br></pre></td></tr></table></figure></li></ul><p>slave 与 master 连接断开</p><ul><li><p>出现的原因：</p><ul><li>master 发送 ping 指令频度较低</li><li>master 设定超时时间较短</li><li>ping 指令在网络中存在丢包</li></ul></li><li><p>解决方法：提高 ping 指令发送的频度</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure><p>超时时间 repl-time 的时间至少是 ping 指令频度的5到10倍，否则 slave 很容易判定超时</p></li></ul><hr><h4 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h4><p>网络信息不同步，数据发送有延迟，导致多个 slave 获取相同数据不同步</p><p>解决方案：</p><ul><li><p><strong>优化主从间的网络环境</strong>，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p></li><li><p>监控主从节点延迟（通过offset）判断，如果 slave 延迟过大，<strong>暂时屏蔽程序对该 slave 的数据访问</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure><p>开启后仅响应 info、slaveof 等少数命令（慎用，除非对数据一致性要求很高）</p></li><li><p>多个 slave 同时对 master 请求数据同步，master 发送的 RDB 文件增多，会对带宽造成巨大冲击，造成 master 带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li></ul><hr><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="哨兵概述"><a href="#哨兵概述" class="headerlink" title="哨兵概述"></a>哨兵概述</h3><p>Sentinel（哨兵）是 Redis 的高可用性（high availability）解决方案，由一个或多个 Sentinel 实例 instance 组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器下线时进行故障转移</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哨兵系统.png" style="zoom:67%;"><ul><li>双环图案表示主服务器</li><li>单环图案表示三个从服务器</li></ul><p>哨兵的作用：</p><ul><li><p>监控：监控 master 和 slave，不断的检查 master 和 slave 是否正常运行，master 存活检测、master 与 slave 运行情况检测</p></li><li><p>通知：当被监控的服务器出现问题时，向其他哨兵发送通知</p></li><li><p>自动故障转移：断开 master 与 slave 连接，选取一个 slave 作为 master，将其他 slave 连接新的 master，并告知客户端新的服务器地址</p></li></ul><hr><h3 id="启用哨兵"><a href="#启用哨兵" class="headerlink" title="启用哨兵"></a>启用哨兵</h3><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>配置三个哨兵 sentinel.conf：一般多个哨兵配置相同、端口不同，特殊需求可以配置不同的属性</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 26401</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6401 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 20000</span><br><span class="line">sentinel parallel-sync mymaster 1</span><br><span class="line">sentinel deny-scripts-reconfig <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li><p>设置哨兵监听的主服务器信息，判断主观下线所需要的票数</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;master_ip&gt; &lt;master_port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定哨兵在监控 Redis 服务时，设置判定服务器宕机的时长，该设置控制是否进行主从切换</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure></li><li><p>出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认 3 分钟</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel failover-timeout &lt;master_name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure></li><li><p>故障转移时，同时进行主从同步的 slave 数量，数值越大，要求网络资源越高</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel parallel-syncs &lt;master_name&gt; &lt;sync_slave_number&gt;</span><br></pre></td></tr></table></figure></li></ul><p>启动哨兵：服务端命令（Linux 命令）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-sentinel filename</span><br></pre></td></tr></table></figure><hr><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器，当一个 Sentinel 启动时，首先初始化 Redis 服务器，但是初始化过程和普通 Redis 服务器的初始化过程并不完全相同，哨兵<strong>不提供数据相关服务</strong>，所以不会载入 RDB、AOF 文件</p><p>整体流程：</p><ul><li><p>初始化服务器</p></li><li><p>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</p></li><li><p>初始化 Sentinel 状态</p></li><li><p>根据给定的配置文件，初始化 Sentinel 的监视主服务器列表</p></li><li><p>创建连向主服务器的网络连接</p></li></ul><hr><h4 id="代码替换"><a href="#代码替换" class="headerlink" title="代码替换"></a>代码替换</h4><p>将一部分普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</p><p>Redis 服务器端口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SERVERPORT 6379 <span class="comment">// 普通服务器端口</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SENTINEL_PORT 26379 <span class="comment">// 哨兵端口</span></span></span><br></pre></td></tr></table></figure><p>服务器的命令表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通 Redis 服务器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>, getCommand, <span class="number">2</span>, <span class="string">&quot;r&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, noPreloadGetKeys, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 哨兵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;ping&quot;</span>, pingCommand, <span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sentinel&quot;</span>, sentinelCommand, <span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;subscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;unsubscribe&quot;</span>,...O&#125;, &#123;<span class="string">&quot;psubscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;punsubscribe&quot;</span>,...&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>,...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述表是哨兵模式下客户端可以执行的命令，所以对于 GET、SET 等命令，服务器根本就没有载入</p><hr><h4 id="哨兵状态"><a href="#哨兵状态" class="headerlink" title="哨兵状态"></a>哨兵状态</h4><p>服务器会初始化一个 sentinelState 结构，又叫 Sentinel 状态，结构保存了服务器中所有和 Sentinel 功能有关的状态（服务器的一般状态仍然由 redisServer 结构保存）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【保存了所有被这个sentinel监视的主服务器】</span></span><br><span class="line">    dict *masters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否进入了 TILT 模式</span></span><br><span class="line">    <span class="type">int</span> tilt;</span><br><span class="line">    <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> tilt_start_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次执行时间处理的事件</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目前正在执行的脚本数量</span></span><br><span class="line">    <span class="type">int</span> running_scripts;</span><br><span class="line">    <span class="comment">// 一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">    </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure><hr><h4 id="监控列表"><a href="#监控列表" class="headerlink" title="监控列表"></a>监控列表</h4><p>Sentinel 状态的初始化将 masters 字典的初始化，根据被载入的 Sentinel 配置文件 conf 来进行属性赋值</p><p>Sentinel 状态中的 masters 字典记录了所有被 Sentinel 监视的<strong>主服务器的相关信息</strong>，字典的键是被监视主服务器的名字，值是主服务器对应的实例结构</p><p>实例结构是一个 sentinelRedisinstance 数据类型，代表被 Sentinel 监视的实例，这个实例可以是主、从服务器，或者其他 Sentinel</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisinstance</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例的名字，主服务器的名字由用户在配置文件中设置，</span></span><br><span class="line">    <span class="comment">// 从服务器和哨兵的名字由 Sentinel 自动设置，格式为 ip:port，例如 127.0.0.1:6379</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例运行的 ID</span></span><br><span class="line">    <span class="type">char</span> *runid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例地址</span></span><br><span class="line">    sentinelAddr *addr; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前实例时主服务器，该字段保存从服务器信息，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *slaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有监视当前服务器的 Sentinel 实例，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *sentinels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel down-after-milliseconds 的值，表示实例无响应多少毫秒后会被判断为主观下线(subjectively down) </span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel monitor 选项中的quorum参数，判断这个实例为客观下线(objectively down)所需的支持投票数量</span></span><br><span class="line">    <span class="type">int</span> quorum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel parallel-syncs 的值，在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="type">int</span> parallel-syncs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel failover-timeout的值，刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addr 属性是一个指向 sentinelAddr 的指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelAddr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ip;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>初始化 Sentinel 的最后一步是创建连向被监视主服务器的网络连接，Sentinel 将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息</p><p>每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的<strong>异步网络连接</strong>：</p><ul><li>命令连接：用于向主服务器发送命令，并接收命令回复</li><li>订阅连接：用于订阅主服务器的 <code>_sentinel_:hello</code> 频道</li></ul><p>建立两个连接的原因：</p><ul><li><p>在 Redis 目前的发布与订阅功能中，被发送的信息都不会保存在 Redis 服务器里， 如果在信息发送时接收信息的客户端离线或断线，那么这个客户端就会丢失这条信息，为了不丢失 hello 频道的任何信息，Sentinel 必须用一个订阅连接来接收该频道的信息</p></li><li><p>Sentinel 还必须向主服务器发送命令，以此来与主服务器进行通信，所以 Sentinel 还必须向主服务器创建命令连接</p></li></ul><p>说明：断线的意思就是网络连接断开</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png"></p><hr><h3 id="信息交互"><a href="#信息交互" class="headerlink" title="信息交互"></a>信息交互</h3><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><h5 id="主服务器"><a href="#主服务器" class="headerlink" title="主服务器"></a>主服务器</h5><p>Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，来获取主服务器的信息</p><ul><li>一部分是主服务器本身的信息，包括 runid 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li><li>另一部分是服务器属下所有从服务器的信息，每个从服务器都由一个 slave 字符串开头的行记录，根据这些 IP 地址和端口号，Sentinel 无须用户提供从服务器的地址信息，就可以<strong>自动发现从服务器</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">...</span><br><span class="line">slave0: ip=l27.0.0.1, port=11111, state=online, offset=22, lag=0</span><br><span class="line">slave1: ip=l27.0.0.1, port=22222, state=online, offset=22, lag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据 run_id 和 role 记录的信息 Sentinel 将对主服务器的实例结构进行更新，比如主服务器重启之后，运行 ID 就会和实例结构之前保存的运行 ID 不同，哨兵检测到这一情况之后就会对实例结构的运行 ID 进行更新</p><p>对于主服务器返回的从服务器信息，用实例结构的 slaves 字典记录了从服务器的信息：</p><ul><li>如果从服务器对应的实例结构已经存在，那么 Sentinel 对从服务器的实例结构进行更新</li><li>如果不存在，为这个从服务器新创建一个实例结构加入字典，字典键为 <code>ip:port</code></li></ul><hr><h5 id="从服务器"><a href="#从服务器" class="headerlink" title="从服务器"></a>从服务器</h5><p>当 Sentinel 发现主服务器有新的从服务器出现时，会为这个新的从服务器创建相应的实例结构，还会<strong>创建到从服务器的命令连接和订阅连接</strong>，所以 Sentinel 对所有的从服务器之间都可以进行命令操作</p><p>Sentinel 默认会以每十秒一次的频率，向从服务器发送 INFO 命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c<span class="comment">#从服务器的运行 id</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:slave <span class="comment"># 从服务器角色</span></span><br><span class="line">...</span><br><span class="line">master_host:127.0.0.1 <span class="comment"># 主服务器的 ip</span></span><br><span class="line">master_port:6379 <span class="comment"># 主服务器的 port</span></span><br><span class="line">master_link_status:up <span class="comment"># 主从服务器的连接状态</span></span><br><span class="line">slave_repl_offset:11111<span class="comment"># 从服务器的复制偏移蜇</span></span><br><span class="line">slave_priority:100 <span class="comment"># 从服务器的优先级</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><strong>优先级属性</strong>在故障转移时会用到</li></ul><p>根据这些信息，Sentinel 会对从服务器的实例结构进行更新</p><hr><h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h4><p>Sentinel 在默认情况下，会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello <span class="string">&quot;&lt;s_ip&gt;, &lt;s_port&gt;, &lt;s_runid&gt;, &lt;s_epoch&gt;, &lt;m_name&gt;, &lt;m_ip&gt;, &lt;m_port&gt;, &lt;m_epoch&gt;</span></span><br></pre></td></tr></table></figure><p>这条命令向服务器的 <code>_sentinel_:hello</code> 频道发送了一条信息，信息的内容由多个参数组成：</p><ul><li>以 s_ 开头的参数记录的是 Sentinel 本身的信息</li><li>以 m_ 开头的参数记录的则是主服务器的信息</li></ul><p>说明：<strong>通过命令连接发送的频道信息</strong></p><hr><h4 id="接受信息"><a href="#接受信息" class="headerlink" title="接受信息"></a>接受信息</h4><h5 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h5><p>Sentinel 与一个主或从服务器建立起订阅连接之后，就会通过订阅连接向服务器发送订阅命令，频道的订阅会一直持续到 Sentinel 与服务器的连接断开为止</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE _sentinel_:hello</span><br></pre></td></tr></table></figure><p>订阅成功后，Sentinel 就可以通过订阅连接从服务器的 <code>_sentinel_:hello</code> 频道接收信息，对消息分析：</p><ul><li>如果信息中记录的 Sentinel 运行 ID 与自己的相同，不做进一步处理</li><li>如果不同，将根据信息中的各个参数，对相应主服务器的实例结构进行更新</li></ul><p>Sentinel 为主服务器创建的实例结构的 sentinels 字典保存所有同样监视这个<strong>主服务器的 Sentinel 信息</strong>（包括 Sentinel 自己），字典的键是 Sentinel 的名字，格式为 <code>ip:port</code>，值是键所对应 Sentinel 的实例结构</p><p>监视同一个服务器的 Sentinel 订阅的频道相同，Sentinel 发送的信息会被其他 Sentinel 接收到（发送信息的为源 Sentinel，接收信息的为目标 Sentinel），目标 Sentinel 在自己的 sentinelState.masters 中查找源 Sentinel 服务器的实例结构进行添加或更新</p><p>因为 Sentinel 可以接收到的频道信息来感知其他 Sentinel 的存在，并通过发送频道信息来让其他 Sentinel 知道自己的存在，所以用户在使用 Sentinel 时并不需要提供各个 Sentinel 的地址信息，<strong>监视同一个主服务器的多个 Sentinel 可以相互发现对方</strong></p><p>哨兵实例之间可以相互发现，要归功于 Redis 提供发布订阅机制</p><hr><h5 id="命令连接"><a href="#命令连接" class="headerlink" title="命令连接"></a>命令连接</h5><p>Sentinel 通过频道信息发现新的 Sentinel，除了创建实例结构，还会创建一个连向新 Sentinel 的命令连接，而新 Sentinel 也同样会创建连向这个 Sentinel 的命令连接，最终监视同一主服务器的多个 Sentinel 将形成相互连接的网络</p><p>作用：<strong>通过命令连接相连的各个 Sentinel</strong> 可以向其他 Sentinel 发送命令请求来进行信息交换</p><p>Sentinel 之间不会创建订阅连接：</p><ul><li>Sentinel 需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新 Sentinel，所以才创建订阅连接</li><li>相互已知的 Sentinel 只要使用命令连接来进行通信就足够了</li></ul><hr><h3 id="下线检测"><a href="#下线检测" class="headerlink" title="下线检测"></a>下线检测</h3><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>Sentinel 在默认情况下会以每秒一次的频率向所有与它创建了命令连接的实例（包括主从服务器、其他 Sentinel）发送 PING 命令，通过实例返回的 PING 命令回复来判断实例是否在线</p><ul><li>有效回复：实例返回 +PONG、-LOADING、-MASTERDOWN 三种回复的其中一种</li><li>无效回复：实例返回除上述三种以外的任何数据</li></ul><p>Sentinel 配置文件中 down-after-milliseconds 选项指定了判断实例进入主观下线所需的时长，如果主服务器在该时间内一直向 Sentinel 返回无效回复，Sentinel 就会在该服务器对应实例结构的 flags 属性打开 SRI_S_DOWN 标识，表示该主服务器进入主观下线状态</p><p>配置的 down-after-milliseconds 值不仅适用于主服务器，还会被用于当前 Sentinel 判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他 Sentinel 的主观下线状态</p><p>注意：对于监视同一个主服务器的多个 Sentinel 来说，设置的 down-after-milliseconds 选项的值可能不同，所以当一个 Sentinel 将主服务器判断为主观下线时，其他 Sentinel 可能仍然会认为主服务器处于在线状态</p><hr><h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当 Sentinel 将一个主服务器判断为主观下线之后，会向同样监视这一主服务器的其他 Sentinel 进行询问</p><p>Sentinel 使用命令询问其他 Sentinel 是否同意主服务器已下线：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure><ul><li>ip：被 Sentinel 判断为主观下线的主服务器的 IP 地址</li><li>port：被 Sentinel 判断为主观下线的主服务器的端口号</li><li>current_epoch：Sentinel 当前的配置纪元，用于选举领头 Sentinel</li><li>runid：取值为 * 符号代表命令仅仅用于检测主服务器的客观下线状态；取值为 Sentinel 的运行 ID 则用于选举领头 Sentinel</li></ul><p>目标 Sentinel 接收到源 Sentinel 的命令时，会根据参数的 lP 和端口号，检查主服务器是否已下线，然后返回一条包含三个参数的 Multi Bulk 回复：</p><ul><li>down_state：返回目标 Sentinel 对服务器的检查结果，1 代表主服务器已下线，0 代表未下线</li><li>leader_runid：取值为 * 符号代表命令仅用于检测服务器的下线状态；而局部领头 Sentinel 的运行 ID 则用于选举领头 Sentinel</li><li>leader_epoch：目标 Sentinel 的局部领头 Sentinel 的配置纪元</li></ul><p>源 Sentinel 将统计其他 Sentinel 同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量（quorum）时，Sentinel 会将主服务器对应实例结构 flags 属性的 SRI_O_DOWN 标识打开，代表客观下线，并对主服务器执行故障转移操作</p><p>注意：<strong>不同 Sentinel 判断客观下线的条件可能不同</strong>，因为载入的配置文件中的属性 quorum 可能不同</p><hr><h3 id="领头选举"><a href="#领头选举" class="headerlink" title="领头选举"></a>领头选举</h3><p>主服务器被判断为客观下线时，<strong>监视该主服务器的各个 Sentinel 会进行协商</strong>，选举出一个领头 Sentinel 对下线服务器执行故障转移</p><p>Redis 选举领头 Sentinel 的规则：</p><ul><li><p>所有在线的 Sentinel 都有被选为领头 Sentinel 的资格</p></li><li><p>每个发现主服务器进入客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头 Sentinel</p></li><li><p>在一个配置纪元里，所有 Sentinel 都只有一次将某个 Sentinel 设置为局部领头 Sentinel 的机会，并且局部领头一旦设置，在这个配置纪元里就不能再更改</p></li><li><p>Sentinel 设置局部领头 Sentinel 的规则是先到先得，最先向目标 Sentinel 发送设置要求的源 Sentinel 将成为目标 Sentinel 的局部领头 Sentinel，之后接收到的所有设置要求都会被目标 Sentinel 拒绝</p></li><li><p>领头 Sentinel 的产生<strong>需要半数以上 Sentinel 的支持</strong>，并且每个 Sentinel 只有一票，所以一个配置纪元只会出现一个领头 Sentinel，比如 10 个 Sentinel 的系统中，至少需要 <code>10/2 + 1 = 6</code> 票</p></li></ul><p>选举过程：</p><ul><li>一个 Sentinel 向目标 Sentinel 发送 <code>SENTINEL is-master-down-by-addr</code> 命令，命令中的 runid 参数不是＊符号而是源 Sentinel 的运行 ID，表示源 Sentinel 要求目标 Sentinel 将自己设置为它的局部领头 Sentinel</li><li>目标 Sentinel 接受命令处理完成后，将返回一条命令回复，回复中的 leader_runid 和 leader_epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 ID 和配置纪元</li><li>源 Sentinel 接收目标 Sentinel 命令回复之后，会判断 leader_epoch 是否和自己的相同，相同就继续判断 leader_runid 是否和自己的运行 ID 一致，成立表示目标 Sentinel 将源 Sentinel 设置成了局部领头 Sentinel，即获得一票</li><li>如果某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 成为领头 Sentinel</li><li>如果在给定时限内，没有一个 Sentinel 被选举为领头 Sentinel，那么各个 Sentinel 将在一段时间后<strong>再次选举</strong>，直到选出领头</li><li>每次进行领头 Sentinel 选举之后，不论选举是否成功，所有 Sentinel 的配置纪元（configuration epoch）都要自增一次</li></ul><p>Sentinel 集群至少 3 个节点的原因：</p><ul><li>如果 Sentinel 集群只有 2 个 Sentinel 节点，则领头选举需要 <code>2/2 + 1 = 2</code> 票，如果一个节点挂了，那就永远选不出领头</li><li>Sentinel 集群允许 1 个 Sentinel 节点故障则需要 3 个节点的集群，允许 2 个节点故障则需要 5 个节点集群</li></ul><p><strong>如何获取哨兵节点的半数数量</strong>？</p><ul><li>客观下线是通过配置文件获取的数量，达到  quorum 就客观下线</li><li>哨兵数量是通过主节点是实例结构中，保存着监视该主节点的所有哨兵信息，从而获取得到</li></ul><hr><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h4><p>领头 Sentinel 将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤</p><ul><li><p>从下线主服务器属下的所有从服务器里面，挑选出一个从服务器，执行 <code>SLAVEOF no one</code>，将从服务器升级为主服务器</p><p>在发送 SLAVEOF no one 命令后，领头 Sentinel 会以<strong>每秒一次的频率</strong>（一般是 10s&#x2F;次）向被升级的从服务器发送 INFO 命令，观察命令回复中的角色信息，当被升级服务器的 role 从 slave 变为 master 时，说明从服务器已经顺利升级为主服务器</p></li><li><p>将已下线的主服务器的所有从服务器改为复制新的主服务器，通过向从服务器发送 SLAVEOF 命令实现</p></li><li><p>将已经下线的主服务器设置为新的主服务器的从服务器，设置是保存在服务器对应的实例结构中，当旧的主服务器重新上线时，Sentinel 就会向它发送 SLAVEOF 命令，成为新的主服务器的从服务器</p></li></ul><p>示例：sever1 是主，sever2、sever3、sever4 是从服务器，sever1 故障后选中 sever2 升级</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png"></p><hr><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><p>领头 Sentinel 会将已下线主服务器的所有从服务器保存到一个列表里，然后按照以下规则对列表进行过滤，最后挑选出一个<strong>状态良好、数据完整</strong>的从服务器</p><ul><li><p>删除列表中所有处于下线或者断线状态的从服务器，保证列表中的从服务器都是正常在线的</p></li><li><p>删除列表中所有最近五秒内没有回复过领头 Sentinel 的 INFO 命令的从服务器，保证列表中的从服务器最近成功进行过通信</p></li><li><p>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds * 10</code> 毫秒的从服务器，保证列表中剩余的从服务器都没有过早地与主服务器断开连接，保存的数据都是比较新的</p><p>down-after-milliseconds 时间用来判断是否主观下线，其余的时间完全可以完成客观下线和领头选举</p></li><li><p>根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中<strong>优先级最高</strong>的从服务器</p></li><li><p>如果有多个具有相同最高优先级的从服务器，领头 Sentinel 将对这些相同优先级的服务器按照复制偏移量进行排序，选出其中偏移量最大的从服务器，也就是保存着最新数据的从服务器</p></li><li><p>如果还没选出来，就按照运行 ID 对这些从服务器进行排序，并选出其中运行 ID 最小的从服务器</p></li></ul><hr><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><h4 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h4><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享， 并提供复制和故障转移功能，一个 Redis 集群通常由多个节点（node）组成，将各个独立的节点连接起来，构成一个包含多节点的集群</p><p>一个节点就是一个<strong>运行在集群模式下的 Redis 服务器</strong>，Redis 在启动时会根据配置文件中的 <code>cluster-enabled</code> 配置选项是否为 yes 来决定是否开启服务器的集群模式</p><p>节点会继续使用所有在单机模式中使用的服务器组件，使用 redisServer 结构来保存服务器的状态，使用 redisClient 结构来保存客户端的状态，也有集群特有的数据结构</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png"></p><hr><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个节点都保存着一个集群状态 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">clusterNode *myself;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line"><span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 集群当前的状态，是在线还是下线</span></span><br><span class="line"><span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 集群中至少处理着一个槽的（主）节点的数量，为0表示集群目前没有任何节点在处理槽</span></span><br><span class="line">    <span class="comment">// 【选举时投票数量超过半数，从这里获取的】</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点），字典的键为节点的名字，字典的值为节点对应的clusterNode结构 </span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个节点都会使用 clusterNode 结构记录当前状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构，以此来记录其他节点的状态</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="type">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点标识，使用各种不同的标识值记录节点的角色（比如主节点或者从节点）以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的IP地址</span></span><br><span class="line">    <span class="type">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clusterNode 结构的 link 属性是一个 clusterLink 结构，该结构保存了连接节点所需的有关信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接的创建时间 </span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// TCP套接字描述符</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息(message)。 </span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">sds rcvbuf;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>redisClient 结构中的套接宇和缓冲区是用于连接客户端的</li><li>clusterLink 结构中的套接宇和缓冲区则是用于连接节点的</li></ul><hr><h4 id="MEET"><a href="#MEET" class="headerlink" title="MEET"></a>MEET</h4><p>CLUSTER MEET 命令用来将 ip 和 port 所指定的节点添加到接受命令的节点所在的集群中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; </span><br></pre></td></tr></table></figure><p>假设向节点 A 发送 CLUSTER MEET 命令，让节点 A 将另一个节点 B 添加到节点 A 当前所在的集群里，收到命令的节点 A 将与根据 ip 和 port 向节点 B 进行握手（handshake）：</p><ul><li>节点 A 会为节点 B 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，然后节点 A 向节点 B <strong>发送 MEET 消息</strong>（message）</li><li>节点 B 收到 MEET 消息后，节点 B 会为节点 A 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，之后节点 B 将向节点 A <strong>返回一条 PONG 消息</strong></li><li>节点 A 收到 PONG 消息后，代表节点 A 可以知道节点 B 已经成功地接收到了自已发送的 MEET 消息，此时节点 A 将向节点 B <strong>返回一条 PING 消息</strong></li><li>节点 B 收到 PING 消息后， 代表节点 B 可以知道节点 A 已经成功地接收到了自己返回的 PONG 消息，握手完成</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B.png"></p><p>节点 A 会将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点也与节点 B 进行握手，最终经过一段时间之后，节点 B 会被集群中的所有节点认识</p><hr><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><p>Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于 16384 个槽中的一个，集群中的每个节点可以处理 0 个或最多 16384 个槽（<strong>每个主节点存储的数据并不一样</strong>）</p><ul><li>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）</li><li>如果数据库中有任何一个槽得到处理，那么集群处于下线状态（fail）</li></ul><p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽指派（assign）给节点负责</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ... ] </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000 <span class="comment"># 将槽0至槽5000指派给节点7000负责</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure><p>命令执行细节：</p><ul><li>如果命令参数中有一个槽已经被指派给了某个节点，那么会向客户端返回错误，并终止命令执行</li><li>将 slots 数组中的索引 i 上的二进制位设置为 1，就代表指派成功</li></ul><hr><h4 id="节点指派"><a href="#节点指派" class="headerlink" title="节点指派"></a>节点指派</h4><p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理信息，一字节等于 8 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[l6384/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 记录节点负责处理的槽的数量，就是 slots 数组中值为 1 的二进制位数量</span></span><br><span class="line">    <span class="type">int</span> numslots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slots 是一个二进制位数组（bit array），长度为 <code>16384/8 = 2048</code> 个字节，包含 16384 个二进制位，Redis 以 0 为起始索引，16383 为终止索引，对 slots 数组的 16384 个二进制位进行编号，并根据索引 i 上的二进制位的值来判断节点是否负责处理槽 i：</p><ul><li>在索引 i 上的二进制位的值为 1，那么表示节点负责处理槽 i</li><li>在索引 i 上的二进制位的值为 0，那么表示节点不负责处理槽 i</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A7%BD%E6%8C%87%E6%B4%BE%E4%BF%A1%E6%81%AF.png"></p><p>取出和设置 slots 数组中的任意一个二进制位的值的**复杂度仅为 O(1)**，所以对于一个给定节点的 slots 数组来说，检查节点是否负责处理某个槽或者将某个槽指派给节点负责，这两个动作的复杂度都是 O(1)</p><p><strong>传播节点的槽指派信息</strong>：一个节点除了会将自己负责处理的槽记录在 clusterNode 中，还会将自己的 slots 数组通过消息发送给集群中的其他节点，每个接收到 slots 数组的节点都会将数组保存到相应节点的 clusterNode 结构里面，因此集群中的<strong>每个节点</strong>都会知道数据库中的 16384 个槽分别被指派给了集群中的哪些节点</p><hr><h4 id="集群指派"><a href="#集群指派" class="headerlink" title="集群指派"></a>集群指派</h4><p>集群状态 clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息，数组每一项都是一个指向 clusterNode 的指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 slots[i] 指针指向 NULL，那么表示槽 i 尚未指派给任何节点</li><li>如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给该节点所代表的节点</li></ul><p>通过该节点，程序检查槽 i 是否已经被指派或者取得负责处理槽 i 的节点，只需要访问 clusterState. slots[i] 即可，时间复杂度仅为 O(1)</p><hr><h4 id="集群数据"><a href="#集群数据" class="headerlink" title="集群数据"></a>集群数据</h4><p>集群节点保存键值对以及键值对过期时间的方式，与单机 Redis 服务器保存键值对以及键值对过期时间的方式完全相同，但是<strong>集群节点只能使用 0 号数据库</strong>，单机服务器可以任意使用</p><p>除了将键值对保存在数据库里面之外，节点还会用 clusterState 结构中的 slots_to_keys 跳跃表来<strong>保存槽和键之间的关系</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slots_to_keys 跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键（按槽号升序）</p><ul><li>当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 slots_to_keys 跳跃表</li><li>当节点删除数据库中的某个键值对时，节点就会在 slots_to_keys 跳跃表解除被删除键与槽号的关联</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%A7%BD%E5%92%8C%E9%94%AE%E8%B7%B3%E8%B7%83%E8%A1%A8.png"></p><p>通过在 slots_to_keys 跳跃表中记录各个数据库键所属的槽，可以很方便地对属于某个或某些槽的所有数据库键进行批量操作，比如 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令返回最多 count 个属于槽 slot 的数据库键，就是通过该跳表实现</p><hr><h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>集群处于上线状态，客户端就可以向集群中的节点发送命令（16384 个槽全部指派就进入上线状态）</p><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令该键属于哪个槽，并检查这个槽是否指派给了自己</p><ul><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li><li>反之，节点会向客户端返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，再次发送该命令</li></ul><p>计算键归属哪个槽的<strong>寻址算法</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span>: <span class="comment">// CRC16(key) 语句计算键 key 的 CRC-16 校验和</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">CRC16</span><span class="params">(key)</span> &amp; 16383;<span class="comment">// 取模，十进制对16384的取余</span></span><br></pre></td></tr></table></figure><p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽，底层实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">CLUSTER_KEYSLOT</span><span class="params">(key)</span>:</span><br><span class="line"><span class="comment">// 计算槽号</span></span><br><span class="line">slot = slot_number(key);</span><br><span class="line"><span class="comment">// 将槽号返回给客户端</span></span><br><span class="line">reply_client(slot);</span><br></pre></td></tr></table></figure><p>判断槽是否由当前节点负责处理：如果 clusterState.slots[i] 不等于 clusterState.myself，那么说明槽 i 并非由当前节点负责，节点会根据 clusterState.slots[i] 指向的 clusterNode 结构所记录的节点 IP 和端口号，向客户端返回 MOVED 错误</p><hr><h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><p>MOVED 错误的格式为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port＞</span><br></pre></td></tr></table></figure><p>参数 slot 为键所在的槽，ip 和 port 是负责处理槽 slot 的节点的 ip 地址和端口号</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED 12345 127.0.0.1:6380 <span class="comment"># 表示槽 12345 正由 IP地址为 127.0.0.1, 端口号为 6380 的节点负责</span></span><br></pre></td></tr></table></figure><p>当客户端接收到节点返回的 MOVED 错误时，客户端会根据 MOVED 错误中提供的 IP 地址和端口号，转至负责处理槽 slot 的节点重新发送执行的命令</p><ul><li><p>一个集群客户端通常会与集群中的多个节点创建套接字连接，节点转向实际上就是换一个套接字来发送命令</p></li><li><p>如果客户端尚未与转向的节点创建套接字连接，那么客户端会先根据 IP 地址和端口号来连接节点，然后再进行转向</p></li></ul><p>集群模式的 redis-cli 在接收到 MOVED 错误时，并不会打印出 MOVED 错误，而是根据错误<strong>自动进行节点转向</strong>，并打印出转向信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 <span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1:6380</span><br><span class="line">OK </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>使用单机（stand alone）模式的 redis-cli 会打印错误，因为单机模式客户端不清楚 MOVED 错误的作用，不会进行自动转向：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 <span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">(error) MOVED 6257 127.0.0.1:6380</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽的键值对也会从源节点被移动到目标节点，该操作是可以在线（online）进行，在重新分片的过程中源节点和目标节点都可以处理命令请求</p><p>Redis 的集群管理软件 redis-trib 负责执行重新分片操作，redis-trib 通过向源节点和目标节点发送命令来进行重新分片操作</p><ul><li>向目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，准备好从源节点导入属于槽 slot 的键值对</li><li>向源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让源节点准备好将属于槽 slot 的键值对迁移</li><li>redis-trib 向源节点发送 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 count 个属于槽 slot 的键值对的键名</li><li>对于每个 key，redis-trib 都向源节点发送一个 <code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout＞</code> 命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点</li><li>重复上述步骤，直到源节点保存的所有槽 slot 的键值对都被迁移至目标节点为止</li><li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target _id&gt;</code> 命令，将槽 slot 指派给目标节点，这一指派信息会通过消息传播至整个集群，最终集群中的所有节点都直到槽 slot 已经指派给了目标节点</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E9%87%8D%E6%96%B0%E5%88%86%E7%89%87.png"></p><p>如果重新分片涉及多个槽，那么 redis-trib 将对每个给定的槽分别执行上面给出的步骤</p><hr><h4 id="命令原理"><a href="#命令原理" class="headerlink" title="命令原理"></a>命令原理</h4><p>clusterState 结构的 importing_slots_from 数组记录了当前节点正在从其他节点导入的槽，migrating_slots_to 数组记录了当前节点正在迁移至其他节点的槽：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果 importing_slots_from[i] 的值不为 NULL，而是指向一个 clusterNode 结构，</span></span><br><span class="line">    <span class="comment">// 那么表示当前节点正在从 clusterNode 所代表的节点导入槽 i</span></span><br><span class="line">    clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点正在将槽 i 迁移至 clusterNode 所代表的节点</span></span><br><span class="line">    clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令：将目标节点 <code>clusterState.importing_slots_from[slot]</code> 的值设置为  source_id 所代表节点的 clusterNode 结构</p><p><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令：将源节点 <code>clusterState.migrating_slots_to[slot]</code> 的值设置为target_id 所代表节点的 clusterNode 结构</p><hr><h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>重新分片期间，源节点向目标节点迁移一个槽的过程中，可能出现被迁移槽的一部分键值对保存在源节点，另一部分保存在目标节点</p><p>客户端向源节点发送命令请求，并且命令要处理的数据库键属于被迁移的槽：</p><ul><li><p>源节点会先在数据库里面查找指定键，如果找到的话，就直接执行客户端发送的命令</p></li><li><p>未找到会检查 clusterState.migrating_slots_to[slot]，看键 key 所属的槽 slot 是否正在进行迁移</p></li><li><p>槽 slot 正在迁移则源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ASK &lt;slot&gt; &lt;ip:port&gt;</span><br></pre></td></tr></table></figure></li><li><p>接到 ASK 错误的客户端，会根据错误提供的 IP 地址和端口号转向目标节点，首先向目标节点发送一个 ASKING 命令，再重新发送原本想要执行的命令</p></li></ul><p>和 MOVED 错误情况类似，集群模式的 redis-cli 在接到 ASK 错误时不会打印错误进行自动转向；单机模式的 redis-cli 会打印错误</p><p>对比 MOVED 错误：</p><ul><li><p>MOVED 错误代表槽的负责权已经从一个节点转移到了另一个节点，转向是一种持久性的转向</p></li><li><p>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施，ASK 的转向不会对客户端今后发送关于槽 slot 的命令请求产生任何影响，客户端仍然会将槽 slot 的命令请求发送至目前负责处理槽 slot 的节点，除非 ASK 错误再次出现</p></li></ul><hr><h4 id="ASKING"><a href="#ASKING" class="headerlink" title="ASKING"></a>ASKING</h4><p>客户端不发送 ASKING 命令，而是直接发送执行的命令，那么客户端发送的命令将被节点拒绝执行，并返回 MOVED 错误</p><p>ASKING 命令作用是打开发送该命令的客户端的 REDIS_ASKING 标识，该命令的伪代码实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">ASKING</span> <span class="params">()</span>:</span><br><span class="line">    <span class="comment">// 打开标识</span></span><br><span class="line">    client.flags |= REDIS_ASKING </span><br><span class="line">    <span class="comment">// 向客户端返回OK回复</span></span><br><span class="line">    reply(<span class="string">&quot;OK&quot;</span>) </span><br></pre></td></tr></table></figure><p>当前节点正在导入槽 slot，并且发送命令的客户端带有 REDIS_ASKING 标识，那么节点将破例执行这个关于槽 slot 的命令一次</p><p>客户端的 REDIS_ASKING 标识是一次性标识，当节点执行了一个带有 REDIS_ASKING 标识的客户端发送的命令之后，该客户端的 REDIS_ASKING 标识就会被移除</p><hr><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="节点复制"><a href="#节点复制" class="headerlink" title="节点复制"></a>节点复制</h4><p>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt; </span><br></pre></td></tr></table></figure><p>向一个节点发送命令可以让接收命令的节点成为 node_id 所指定节点的从节点，并开始对主节点进行复制</p><ul><li><p>接受命令的节点首先会在的 clusterState.nodes 字典中找到 node_id 所对应节点的 clusterNode 结构，并将自己的节点中的 clusterState.myself.slaveof 指针指向这个结构，记录这个节点正在复制的主节点</p></li><li><p>节点会修改 clusterState.myself.flags 中的属性，关闭 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识</p></li><li><p>节点会调用复制代码，对主节点进行复制（节点的复制功能和单机 Redis 服务器的使用了相同的代码）</p></li></ul><p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点</p><p>主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的从节点名单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="type">int</span> numslaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，来检测对方是否在线，如果接收 PING 的节点没有在规定的时间内返回 PONG 消息，那么发送消息节点就会将接收节点标记为<strong>疑似下线</strong>（probable fail）</p><p>集群中的节点会互相发送消息，来<strong>交换集群中各个节点的状态信息</strong>，当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入了疑似下线状态时，主节点 A 会在 clusterState.nodes 字典中找到主节点 C 所对应的节点，并将主节点 B 的下线报告（failure report）添加到 clusterNode.fail_reports 链表里面</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，记录了所有其他节点对该节点的下线报告 </span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个下线报告由一个 clusterNodeFailReport 结构表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="comment">// 报告目标节点巳经下线的节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">// 程序使用这个时间戳来检查下线报告是否过期，与当前时间相差太久的下线报告会被删除 </span></span><br><span class="line">    <span class="type">mstime_t</span> time; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>集群里<strong>半数以上</strong>负责处理槽的主节点都将某个主节点 X 报告为疑似下线，那么 X 将被标记为<strong>已下线</strong>（FAIL），将 X 标记为已下线的节点会向集群广播一条关于主节点 X 的 FAIL 消息，所有收到消息的节点都会将 X 标记为已下线</p><hr><h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个从节点发现所属的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，执行步骤：</p><ul><li>下属的从节点通过选举产生一个节点</li><li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点</li><li>新的主节点会<strong>撤销所有对已下线主节点的槽指派</strong>，并将这些槽全部指派给自己</li><li>新的主节点向集群广播一条 PONG 消息，让集群中的其他节点知道当前节点变成了主节点，并且接管了下线节点负责处理的槽</li><li>新的主节点开始接收有关的命令请求，故障转移完成</li></ul><hr><h4 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h4><p>集群选举新的主节点的规则：</p><ul><li>集群的配置纪元是一个自增的计数器，初始值为 0</li><li>当集群里某个节点开始一次故障转移，集群的配置纪元就是增加一</li><li>每个配置纪元里，集群中每个主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得该主节点的投票</li><li>具有投票权的主节点是必须具有正在处理的槽</li><li>集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 <code>N/2+1</code> 张支持票时，从节点就会当选</li><li>每个配置纪元里，具有投票权的主节点只能投一次票，所以获得一半以上票的节点只会有一个</li></ul><p>选举流程：</p><ul><li>当某个从节点发现正在复制的主节点进入已下线状态时，会向集群广播一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code> 消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票</li><li>如果主节点尚未投票给其他从节点，将向要求投票的从节点返回一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code> 消息，表示这个主节点支持从节点成为新的主节点</li><li>如果从节点获取到了半数以上的选票，则会当选新的主节点</li><li>如果一个配置纪元里没有从节点能收集到足够多的支待票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点</li></ul><p>选举新主节点的方法和选举领头 Sentinel 的方法非常相似，两者都是基于 Raft 算法的领头选举（leader election）方法实现的</p><hr><h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><p>集群中的各个节点通过发送和接收消息（message）来进行通信，将发送消息的节点称为发送者（sender），接收消息的节点称为接收者（receiver）</p><p>节点发送的消息主要有：</p><ul><li><p>MEET 消息：当发送者接到客户端发送的 CLUSTER MEET 命令时，会向接收者发送 MEET 消息，请求接收者加入到发送者当前所处的集群里</p></li><li><p>PING 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING，以此来<strong>随机检测</strong>被选中的节点是否在线</p><p>如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间，距离当前已经超过了节点 A 的 cluster-node­-timeout 设置时长的一半，那么 A 也会向 B 发送 PING 消息，防止 A 因为长时间没有随机选中 B 发送 PING，而导致对节点 B 的信息更新滞后</p></li><li><p>PONG 消息：当接收者收到 MEET 消息或者 PING 消息时，为了让发送者确认已经成功接收消息，会向发送者返回一条 PONG；节点也可以通过向集群广播 PONG 消息来让集群中的其他节点立即刷新关于这个节点的认识（从升级为主）</p></li><li><p>FAIL 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条 B 节点的 FAIL 信息</p></li><li><p>PUBLISH 消息：当节点接收到一个 PUBLISH 命令时，节点会执行这个命令并向集群广播一条 PUBLISH 消息，接收到 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令</p></li></ul><hr><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息</p><p>消息头：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsg</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息的长度（包括这个消息头的长度和消息正文的长度）</span></span><br><span class="line"><span class="type">uint32_t</span> totlen;</span><br><span class="line"><span class="comment">// 消息的类型</span></span><br><span class="line"><span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="comment">// 消息正文包含的节点信息数量，只在发送MEET、PING、PONG这三种Gossip协议消息时使用 </span></span><br><span class="line">    <span class="type">uint16_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者所处的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者的名字(ID)</span></span><br><span class="line"><span class="type">char</span> sender[REDIS CLUSTER NAMELEN];</span><br><span class="line"><span class="comment">// 发送者目前的槽指派信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> myslots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是 REDIS_NODE_NULL_NAME，一个 40 宇节长值全为 0 的字节数组</span></span><br><span class="line">    <span class="type">char</span> slaveof[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 发送者的端口号</span></span><br><span class="line"><span class="type">uint16_t</span> port;</span><br><span class="line"><span class="comment">// 发送者的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags; </span><br><span class="line"><span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"><span class="comment">// 消息的正文（或者说， 内容） </span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clusterMsg 结构的 currentEpoch、sender、myslots 等属性记录了发送者的节点信息，接收者会根据这些信息在 clusterState.nodes 字典里找到发送者对应的 clusterNode 结构，并对结构进行更新，比如<strong>传播节点的槽指派信息</strong></p><p>消息正文：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line">    <span class="comment">// MEET、PING、PONG 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FAIL 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PUBLISH 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他消息正文...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><p>Redis 集群中的各个节点通过 Gossip 协议来交换各自关于不同节点的状态信息，其中 Gossip 协议由 MEET、PING、PONG 消息实现，三种消息使用相同的消息正文，所以节点通过消息头的 type 属性来判断消息的具体类型</p><p>发送者发送这三种消息时，会从已知节点列表中<strong>随机选出两个节点</strong>（主从都可以），将两个被选中节点信息保存到两个 Gossip 结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataGossip</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节点的名字</span></span><br><span class="line"><span class="type">char</span> nodename[REDIS CLUSTER NAMELEN];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 最后一次向该节点发送PING消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> ping_sent;</span><br><span class="line"><span class="comment">// 最后一次从该节点接收到PONG消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> pong_received;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 节点的IP地址</span></span><br><span class="line"><span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line"><span class="comment">// 节点的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收者收到消息时，会访问消息正文中的两个数据结构，来进行相关操作</p><ul><li>如果被选中节点不存在于接收者的已知节点列表，接收者将根据结构中记录的 IP 地址和端口号，与节点进行握手</li><li>如果存在，根据 Gossip 结构记录的信息对节点所对应的 clusterNode 结构进行更新</li></ul><hr><h4 id="FAIL"><a href="#FAIL" class="headerlink" title="FAIL"></a>FAIL</h4><p>在集群的节点数量比较大的情况下，使用 Gossip 协议来传播节点的已下线信息会带来一定延迟，因为 Gossip 协议消息通常需要一段时间才能传播至整个集群，所以通过发送 FAIL消息可以让集群里的所有节点立即知道某个主节点已下线，从而尽快进行其他操作</p><p>FAIL 消息的正文由 clusterMsgDataFail 结构表示，该结构只有一个属性，记录了已下线节点的名字</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataFail</span> &#123;</span></span><br><span class="line"><span class="type">char</span> nodename[REDIS_CLUSTER_NAMELEN)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为传播下线信息不需要其他属性，所以节省了传播的资源</p><hr><h4 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h4><p>当客户端向集群中的某个节点发送命令，接收到 PUBLISH 命令的节点不仅会向 channel 频道发送消息 message，还会向集群广播一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会向 channel 频道发送 message 消息，最终集群中所有节点都发了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt; </span><br></pre></td></tr></table></figure><p>PUBLISH 消息的正文由 clusterMsgDataPublish 结构表示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataPublish</span> &#123;</span></span><br><span class="line">    <span class="comment">// channel参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> channel_len;</span><br><span class="line">    <span class="comment">// message参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> message_len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义为8字节只是为了对齐其他消息结构，实际的长度由保存的内容决定</span></span><br><span class="line">    <span class="comment">// bulk_data 的 0 至 channel_len-1 字节保存的是channel参数</span></span><br><span class="line">    <span class="comment">// bulk_data的 channel_len 字节至 channel_len + message_len-1 字节保存的则是message参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bulk_data[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让集群的所有节点执行相同的 PUBLISH 命令，最简单的方法就是向所有节点广播相同的 PUBLISH 命令，这也是 Redis 复制 PUBLISH 命令时所使用的，但是这种做法并不符合 Redis 集群的各<strong>个节点通过发送和接收消息来进行通信</strong>的规则</p><hr><h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><p>脑裂指在主从集群中，同时有两个相同的主节点能接收写请求，导致客户端不知道应该往哪个主节点写入数据，最后 不同客户端往不同的主节点上写入数据</p><ul><li>原主节点并没有真的发生故障，由于某些原因无法处理请求（CPU 利用率很高、自身阻塞），无法按时响应心跳请求，被哨兵&#x2F;集群主节点错误的判断为下线</li><li>在被判断下线之后，原主库又重新开始处理请求了，哨兵&#x2F;集群主节点还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据，造成脑裂问题</li></ul><p>数据丢失问题：从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，所以原主库在主从切换期间保存的新写数据就丢失了</p><p>预防脑裂：在主从集群部署时，合理地配置参数 min-slaves-to-write 和 min-slaves-max-lag</p><ul><li>假设从库有 K 个，可以将 min-slaves-to-write 设置为 K&#x2F;2+1（如果 K 等于 1，就设为 1）</li><li>将 min-slaves-max-lag 设置为十几秒（例如 10～20s）</li><li>在假故障期间无法响应哨兵发出的心跳测试，无法和从库进行 ACK 确认，并且没有足够的从库，<strong>拒绝客户端的写入</strong></li></ul><hr><h3 id="结构搭建"><a href="#结构搭建" class="headerlink" title="结构搭建"></a>结构搭建</h3><p>整体框架：</p><ul><li>配置服务器（3 主 3 从）</li><li>建立通信（Meet）</li><li>分槽（Slot）</li><li>搭建主从（master-slave）</li></ul><p>创建集群 conf 配置文件：</p><ul><li><p>redis-6501.conf</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 6501</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6501.rdb&quot;</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file <span class="string">&quot;cluster-6501.conf&quot;</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他配置文件参照上面的修改端口即可，内容完全一样</span></span><br></pre></td></tr></table></figure></li><li><p>服务端启动：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br></pre></td></tr></table></figure></li><li><p>客户端启动：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6504 -c</span><br></pre></td></tr></table></figure></li></ul><p><strong>cluster 配置：</strong></p><ul><li><p>是否启用 cluster，加入 cluster 节点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-enabled <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure></li><li><p>cluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-config-file filename</span><br></pre></td></tr></table></figure></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout milliseconds</span><br></pre></td></tr></table></figure></li><li><p>master 连接的 slave 最小数量</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-migration-barrier min_slave_number</span><br></pre></td></tr></table></figure></li></ul><p>客户端启动命令：</p><p><strong>cluster 节点操作命令（客户端命令）：</strong></p><ul><li><p>查看集群节点信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li><li><p>更改 slave 指向新的 master</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster replicate master-id</span><br></pre></td></tr></table></figure></li><li><p>发现一个新节点，新增 master</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure></li><li><p>忽略一个没有 solt 的节点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster forget server_id</span><br></pre></td></tr></table></figure></li><li><p>手动故障转移</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li></ul><p><strong>集群操作命令（Linux）：</strong></p><ul><li><p>创建集群</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli –-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span><br></pre></td></tr></table></figure><p>注意：master 与 slave 的数量要匹配，一个 master 对应 n 个 slave，由最后的参数 n 决定。master 与 slave 的匹配顺序为第一个 master 与前 n 个 slave 分为一组，形成主从结构</p></li><li><p>添加 master 到当前集群中，连接时可以指定任意现有节点地址与端口</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port</span><br></pre></td></tr></table></figure></li><li><p>添加 slave</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span><br></pre></td></tr></table></figure></li><li><p>删除节点，如果删除的节点是 master，必须保障其中没有槽 slot</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id</span><br></pre></td></tr></table></figure></li><li><p>重新分槽，分槽是从具有槽的 master 中划分一部分给其他 master，过程中不创建新的槽</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span><br></pre></td></tr></table></figure><p>注意：将需要参与分槽的所有 masterid 不分先后顺序添加到参数中，使用 <code>,</code> 分隔，指定目标得到的槽的数量，所有的槽将平均从每个来源的 master 处获取</p></li><li><p>重新分配槽，从具有槽的 master 中分配指定数量的槽到另一个 master 中，常用于清空指定 master 中的槽</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="基本指令-1"><a href="#基本指令-1" class="headerlink" title="基本指令"></a>基本指令</h4><p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p><p>Redis 客户端可以订阅任意数量的频道，每当有客户端向被订阅的频道发送消息（message）时，频道的<strong>所有订阅者都会收到消息</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p><p>操作过程：</p><ul><li><p>打开一个客户端订阅 channel1：<code>SUBSCRIBE channel1</code></p></li><li><p>打开另一个客户端，给 channel1 发布消息 hello：<code>PUBLISH channel1 hello</code></p></li><li><p>第一个客户端可以看到发送的消息</p></li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-发布订阅指令操作.png" style="zoom:67%;"><p>客户端还可以通过 PSUBSCRIBE 命令订阅一个或多个模式，每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，还会被<strong>发送给所有与这个频道相匹配的模式的订阅者</strong>，比如 <code>PSUBSCRIBE channel*</code> 订阅模式，与 channel1 匹配</p><p>注意：发布的消息没有持久化，所以订阅的客户端只能收到订阅后发布的消息</p><hr><h4 id="频道操作"><a href="#频道操作" class="headerlink" title="频道操作"></a>频道操作</h4><p>Redis 将所有频道的订阅关系都保存在服务器状态的 pubsub_channels 字典里，键是某个被订阅的频道，值是一个记录所有订阅这个频道的客户端链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// 保存所有频道的订阅关系，</span></span><br><span class="line">dict *pubsub_channels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端执行 SUBSCRIBE 命令订阅某个或某些频道，服务器会将客户端与频道进行关联：</p><ul><li>频道已经存在，直接将客户端添加到链表末尾</li><li>频道还未有任何订阅者，在字典中为频道创建一个键值对，再将客户端添加到链表</li></ul><p>UNSUBSCRIBE 命令用来退订某个频道，服务器将从 pubsub_channels 中解除客户端与被退订频道之间的关联</p><hr><h4 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h4><p>Redis 服务器将所有模式的订阅关系都保存在服务器状态的 pubsub_patterns 属性里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// 保存所有模式订阅关系，链表中每个节点是一个 pubsubPattern</span></span><br><span class="line"><span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    <span class="comment">// 订阅的客户端</span></span><br><span class="line">    redisClient *client;</span><br><span class="line"><span class="comment">// 被订阅的模式，比如  channel*</span></span><br><span class="line">    robj *pattern; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端执行 PSUBSCRIBE 命令订阅某个模式，服务器会新建一个 pubsubPattern 结构并赋值，放入 pubsub_patterns 链表结尾</p><p>模式的退订命令 PUNSUBSCRIBE 是订阅命令的反操作，服务器在 pubsub_patterns 链表中查找并删除对应的结构</p><hr><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Redis 客户端执行 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code> 命令将消息 message发送给频道 channel，服务器会执行：</p><ul><li>在 pubsub_channels 字典里找到频道 channel 的订阅者名单，将消息 message 发送给所有订阅者</li><li>遍历整个 pubsub_patterns 链表，查找与 channel 频道相<strong>匹配的模式</strong>，并将消息发送给所有订阅了这些模式的客户端</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果频道和模式相匹配</span></span><br><span class="line"><span class="keyword">if</span> <span class="title function_">match</span><span class="params">(channel, pubsubPattern.pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息发送给订阅该模式的客户端</span></span><br><span class="line">    send_message(pubsubPattern.client, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><p>PUBSUB 命令用来查看频道或者模式的相关信息</p><p><code>PUBSUB CHANNELS [pattern]</code> 返回服务器当前被订阅的频道，其中 pattern 参数是可选的</p><ul><li>如果不给定 pattern  参数，那么命令返回服务器当前被订阅的所有频道</li><li>如果给定 pattern 参数，那么命令返回服务器当前被订阅的频道中与 pattern 模式相匹配的频道</li></ul><p><code>PUBSUB NUMSUB [channel-1 channel-2 ... channel-n]</code>  命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p><p><code>PUBSUB NUMPAT</code> 命令用于返回服务器当前被订阅模式的数量</p><hr><h3 id="ACL-指令"><a href="#ACL-指令" class="headerlink" title="ACL 指令"></a>ACL 指令</h3><p>Redis ACL 是 Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-ACL%E6%8C%87%E4%BB%A4.png"></p><ul><li><p>acl cat：查看添加权限指令类别</p></li><li><p>acl whoami：查看当前用户</p></li><li><p>acl setuser username on &gt;password ~cached:* +get：设置有用户名、密码、ACL 权限（只能 get）</p></li></ul><hr><h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>MONITOR 命令，可以将客户端变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现原理</span></span><br><span class="line">def <span class="title function_">MONITOR</span><span class="params">()</span>:</span><br><span class="line"><span class="comment">// 打开客户端的监视器标志</span></span><br><span class="line">client.flags |= REDIS_MONITOR</span><br><span class="line">        </span><br><span class="line">  <span class="comment">// 将客户端添加到服务器状态的 redisServer.monitors链表的末尾</span></span><br><span class="line">   server.monitors.append(client)</span><br><span class="line">  <span class="comment">// 向客户端返回 ok</span></span><br><span class="line">send_reply(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure><p>服务器每次处理命令请求都会调用 replicationFeedMonitors 函数，函数将被处理的命令请求的相关信息<strong>发送给各个监视器</strong></p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-监视器.png" style="zoom:50%;"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MONITOR </span><br><span class="line">OK </span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">&quot;PING&quot;</span> </span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;hello world&quot;</span> </span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;number&quot;</span> <span class="string">&quot;123&quot;</span> </span><br><span class="line">1378822140.649496 (0 127.0.0.1:56604] <span class="string">&quot;SADD&quot;</span> <span class="string">&quot;fruits&quot;</span> <span class="string">&quot;Apple&quot;</span> <span class="string">&quot;Banana&quot;</span> <span class="string">&quot;Cherry&quot;</span> </span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">&quot;EXPIRE&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;10086&quot;</span> </span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">&quot;KEYS&quot;</span> <span class="string">&quot;*&quot;</span> </span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">&quot;DBSIZE&quot;</span> </span><br></pre></td></tr></table></figure><hr><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>Redis 的管道 Pipeline 机制可以一次处理多条指令</p><ul><li>Pipeline 中的多条命令非原子性，因为在向管道内添加命令时，其他客户端的发送的命令仍然在执行</li><li>原生批命令（MSET 等）是服务端实现，而 Pipeline 需要服务端与客户端共同完成</li></ul><p>使用 Pipeline 封装的命令数量不能太多，数据量过大会增加客户端的等待时间，造成网络阻塞，Jedis 中的 Pipeline 使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 放入命令到管道</span></span><br><span class="line">    pipeline.set(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">        pipeline.sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群下模式下，批处理命令的多个 key 必须落在一个插槽中，否则就会导致执行失败，N 条批处理命令的优化方式：</p><ul><li>串行命令：for 循环遍历，依次执行每个命令</li><li>串行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，串行执行各组命令</li><li>并行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，<strong>并行执行各组命令</strong></li><li>hash_tag：将所有 key 设置相同的 hash_tag，则所有 key 的 slot 一定相同</li></ul><table><thead><tr><th></th><th>耗时</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>串行命令</td><td>N 次网络耗时 + N 次命令耗时</td><td>实现简单</td><td>耗时久</td></tr><tr><td>串行 slot</td><td>m 次网络耗时 + N 次命令耗时，m &#x3D; key 的 slot 个数</td><td>耗时较短</td><td>实现稍复杂</td></tr><tr><td>并行 slot</td><td>1 次网络耗时 + N 次命令耗时</td><td>耗时非常短</td><td>实现复杂</td></tr><tr><td>hash_tag</td><td>1 次网络耗时 + N 次命令耗时</td><td>耗时非常短、实现简单</td><td>容易出现<strong>数据倾斜</strong></td></tr></tbody></table><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h3><h4 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h4><h5 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h5><p>缓存本质：弥补 CPU 的高算力和 IO 的慢读写之间巨大的鸿沟</p><p>旁路缓存模式 Cache Aside Pattern 是平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景</p><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准</p><ul><li>写操作：先更新 DB，然后直接删除 cache</li><li>读操作：从 cache 中读取数据，读取到就直接返回；读取不到就从 DB 中读取数据返回，并放到 cache</li></ul><p>时序导致的不一致问题：</p><ul><li><p>在写数据的过程中，不能先删除 cache 再更新 DB，因为会造成缓存的不一致。比如请求 1 先写数据 A，请求 2 随后读数据 A，当请求 1 删除 cache 后，请求 2 直接读取了 DB，此时请求 1 还没写入 DB（延迟双删）</p></li><li><p>在写数据的过程中，先更新 DB 再删除 cache 也会出现问题，但是概率很小，因为缓存的写入速度非常快</p></li></ul><p>旁路缓存的缺点：</p><ul><li>首次请求数据一定不在 cache 的问题，一般采用缓存预热的方法，将热点数据可以提前放入 cache 中</li><li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，影响缓存命中率</li></ul><p><strong>删除缓存而不是更新缓存的原因</strong>：每次更新数据库都更新缓存，造成无效写操作较多（懒惰加载，需要的时候再放入缓存）</p><hr><h5 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h5><p>读写穿透模式 Read&#x2F;Write Through Pattern：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中，cache 负责将此数据同步写入 DB，从而减轻了应用程序的职责</p><ul><li><p>写操作：先查 cache，cache 中不存在，直接更新 DB；cache 中存在则先更新 cache，然后 cache 服务更新 DB（同步更新 cache 和 DB）</p></li><li><p>读操作：从 cache 中读取数据，读取到就直接返回 ；读取不到先从 DB 加载，写入到 cache 后返回响应</p><p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，对客户端是透明的</p></li></ul><p>Read-Through Pattern 也存在首次不命中的问题，采用缓存预热解决</p><hr><h5 id="异步缓存"><a href="#异步缓存" class="headerlink" title="异步缓存"></a>异步缓存</h5><p>异步缓存写入 Write Behind Pattern 由 cache 服务来负责 cache 和 DB 的读写，对比读写穿透不同的是 Write Behind Caching 是只更新缓存，不直接更新 DB，改为<strong>异步批量</strong>的方式来更新 DB，可以减小写的成本</p><p>缺点：这种模式对数据一致性没有高要求，可能出现 cache 还没异步更新 DB，服务就挂掉了</p><p>应用：</p><ul><li><p>DB 的写性能非常高，适合一些数据经常变化又对数据一致性要求不高的场景，比如浏览量、点赞量</p></li><li><p>MySQL 的 InnoDB Buffer Pool 机制用到了这种策略</p></li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>使用缓存代表不需要强一致性，只需要最终一致性</p><p>缓存不一致的方法：</p><ul><li><p>数据库和缓存数据强一致场景：</p><ul><li><p>同步双写：更新 DB 时同样更新 cache，保证在一个事务中，通过加锁来保证更新 cache 时不存在线程安全问题</p></li><li><p>延迟双删：先淘汰缓存再写数据库，休眠 1 秒再次淘汰缓存，可以将 1 秒内造成的缓存脏数据再次删除</p></li><li><p>异步通知：</p><ul><li>基于 MQ 的异步通知：对数据的修改后，代码需要发送一条消息到 MQ 中，缓存服务监听 MQ 消息</li><li>Canal 订阅 MySQL binlog 的变更上报给 Kafka，系统监听 Kafka 消息触发缓存失效，或者直接将变更发送到处理服务，<strong>没有任何代码侵入</strong></li></ul><p>低耦合，可以同时通知多个缓存服务，但是时效性一般，可能存在中间不一致状态</p></li></ul></li><li><p>低一致性场景：</p><ul><li>更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样就可以保证即使数据不一致影响也比较小</li><li>使用 Redis 自带的内存淘汰机制</li></ul></li></ul><hr><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><h5 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h5><p>场景：宕机，服务器启动后迅速宕机</p><p>问题排查：</p><ol><li><p>请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对 redis 的高强度操作从而导致问题</p></li><li><p>主从之间数据吞吐量较大，数据同步操作频度较高</p></li></ol><p>解决方案：</p><ul><li><p>前置准备工作：</p><ol><li><p>日常例行统计数据访问记录，统计访问频度较高的热点数据</p></li><li><p>利用 LRU 数据删除策略，构建数据留存队列例如：storm 与 kafka 配合</p></li></ol></li><li><p>准备工作：</p><ol><li><p>将统计结果中的数据分类，根据级别，redis 优先加载级别较高的热点数据</p></li><li><p>利用分布式多服务器同时进行数据读取，提速数据加载过程</p></li><li><p>热点数据主从同时预热</p></li></ol></li><li><p>实施：</p><ol start="4"><li><p>使用脚本程序固定触发数据预热过程</p></li><li><p>如果条件允许，使用了 CDN（内容分发网络），效果会更好</p></li></ol></li></ul><p>总的来说：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据</p><hr><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>场景：数据库服务器崩溃，一连串的问题会随之而来</p><p>问题排查：在一个较短的时间内，<strong>缓存中较多的 key 集中过期</strong>，此周期内请求访问过期的数据 Redis 未命中，Redis 向数据库获取数据，数据库同时收到大量的请求无法及时处理。</p><p>解决方案：</p><ol><li>加锁，慎用</li><li>设置热点数据永远不过期，如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</li><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>构建<strong>多级缓存</strong>架构，Nginx 缓存 + Redis 缓存 + ehcache 缓存</li><li>灾难预警机制，监控 Redis 服务器性能指标，CPU 使用率、内存容量、平均响应时间、线程数</li><li><strong>限流、降级</strong>：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol><p>总的来说：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约 40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><hr><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿也叫热点 Key 问题</p><ol><li><p><strong>Redis 中某个 key 过期，该 key 访问量巨大</strong></p></li><li><p>多个数据请求从服务器直接压到 Redis 后，均未命中</p></li><li><p>Redis 在短时间内发起了大量对数据库中同一数据的访问</p></li></ol><p>解决方案：</p><ol><li><p>预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息 key 的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整：监控访问量，对自然流量激增的数据<strong>延长过期时间或设置为永久性 key</strong></p></li><li><p>后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p></li><li><p><strong>二级缓存</strong>：设置不同的失效时间，保障不会被同时淘汰就行</p></li><li><p>加锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重</p></li></ol><p>总的来说：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中 Redis 后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个 key 的过期监控难度较高，配合雪崩处理策略即可</p><hr><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>场景：系统平稳运行过程中，应用服务器流量随时间增量较大，Redis 服务器命中率随时间逐步降低，Redis 内存平稳，内存无压力，Redis 服务器 CPU 占用激增，数据库服务器压力激增，数据库崩溃</p><p>问题排查：</p><ol><li><p>Redis 中大面积出现未命中</p></li><li><p>出现非正常 URL 访问</p></li></ol><p>问题分析：</p><ul><li>访问了不存在的数据，跳过了 Redis 缓存，数据库页查询不到对应数据</li><li>Redis 获取到 null 数据未进行持久化，直接返回</li><li>出现黑客攻击服务器</li></ul><p>解决方案：</p><ol><li><p>缓存 null：对查询结果为 null 的数据进行缓存，设定短时限，例如 30-60 秒，最高 5 分钟</p></li><li><p>白名单策略：提前预热各种分类<strong>数据 id 对应的 bitmaps</strong>，id 作为 bitmaps 的 offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低），也可以使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p></li><li><p>实时监控：实时监控 Redis 命中率（业务正常范围时，通常会有一个波动值）与 null 数据的占比</p><ul><li>非活动时段波动：通常检测 3-5 倍，超过 5 倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50 倍，超过 50 倍纳入重点排查对象</li></ul><p>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控</p></li><li><p>key 加密：临时启动防灾业务 key，对 key 进行业务层传输加密服务，设定校验程序，过来的 key 校验；例如每天随机分配 60 个加密串，挑选 2 到 3 个，混淆到页面数据 id 中，发现访问 key 不满足规则，驳回数据访问</p></li></ol><p>总的来说：缓存击穿是指访问了不存在的数据，跳过了合法数据的 Redis 数据缓存阶段，<strong>每次访问数据库</strong>，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p><p><a href="https://www.bilibili.com/video/BV15y4y1r7X3">参考视频</a></p><hr><h3 id="Key-设计"><a href="#Key-设计" class="headerlink" title="Key 设计"></a>Key 设计</h3><p>大 Key：通常以 Key 的大小和 Key 中成员的数量来综合判定，引发的问题：</p><ul><li>客户端执行命令的时长变慢</li><li>Redis 内存达到 maxmemory 定义的上限引发操作阻塞或重要的 Key 被逐出，甚至引发内存溢出（OOM）</li><li>集群架构下，某个数据分片的内存使用率远超其他数据分片，使<strong>数据分片的内存资源不均衡</strong></li><li>对大 Key 执行读请求，会使 Redis 实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务</li><li>对大 Key 执行删除操作，会造成主库较长时间的阻塞，进而可能引发同步中断或主从切换</li></ul><p>热 Key：通常以其接收到的 Key 被请求频率来判定，引发的问题：</p><ul><li>占用大量的 CPU 资源，影响其他请求并导致整体性能降低</li><li>分布式集群架构下，产生<strong>访问倾斜</strong>，即某个数据分片被大量访问，而其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝等问题</li><li>在抢购或秒杀场景下，可能因商品对应库存 Key 的请求量过大，超出 Redis 处理能力造成超卖</li><li>热 Key 的请求压力数量超出 Redis 的承受能力易造成缓存击穿，即大量请求将被直接指向后端的存储层，导致存储访问量激增甚至宕机，从而影响其他业务</li></ul><p>热 Key 分类两种，治理方式如下：</p><ul><li>一种是单一数据，比如秒杀场景，假设总量 10000 可以拆为多个 Key 进行访问，每次对请求进行路由到不同的 Key 访问，保证最终一致性，但是会出现访问不同 Key 产生的剩余量是不同的，这时可以通过前端进行 Mock 假数据</li><li>一种是多数据集合，比如进行 ID 过滤，这时可以添加本地 LRU 缓存，减少对热 Key 的访问</li></ul><p><a href="https://help.aliyun.com/document_detail/353223.html">参考文档</a></p><hr><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>确认服务和 Redis 之间的链路是否正常，排除网络原因后进行 Redis 的排查：</p><ul><li>使用复杂度过高的命令</li><li>操作大 key，分配内存和释放内存会比较耗时</li><li>key 集中过期，导致定时任务需要更长的时间去清理</li><li>实例内存达到上限，每次写入新的数据之前，Redis 必须先从实例中踢出一部分数据</li></ul><p><a href="https://www.cnblogs.com/traditional/p/15633919.html">参考文章</a>（非常好）</p><hr><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>JDBC（Java DataBase Connectivity，Java 数据库连接）是一种用于执行 SQL 语句的 Java API，可以为多种关系型数据库提供统一访问，是由一组用 Java 语言编写的类和接口组成的。</p><p>JDBC 是 Java 官方提供的一套规范（接口），用于帮助开发人员快速实现不同关系型数据库的连接</p><hr><h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><p>DriverManager：驱动管理对象</p><ul><li><p>注册驱动：</p><ul><li><p>注册给定的驱动：<code>public static void registerDriver(Driver driver)</code></p></li><li><p>代码实现语法：<code>Class.forName(&quot;com.mysql.jdbc.Driver)</code></p></li><li><p>com.mysql.jdbc.Driver 中存在静态代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不需要通过 DriverManager 调用静态方法 registerDriver，因为 Driver 类被使用，则自动执行静态代码块完成注册驱动</p></li><li><p>jar 包中 META-INF 目录下存在一个 java.sql.Driver 配置文件，文件中指定了 com.mysql.jdbc.Driver</p></li></ul></li><li><p>获取数据库连接并返回连接对象：</p><p>方法：<code>public static Connection getConnection(String url, String user, String password)</code></p><ul><li>url：指定连接的路径，语法为 <code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li><li>user：用户名</li><li>password：密码</li></ul></li></ul><hr><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection：数据库连接对象</p><ul><li>获取执行者对象<ul><li>获取普通执行者对象：<code>Statement createStatement()</code></li><li>获取预编译执行者对象：<code>PreparedStatement prepareStatement(String sql)</code></li></ul></li><li>管理事务<ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，false 开启事务，true 自动提交模式（默认）</li><li>提交事务：<code>void commit()</code></li><li>回滚事务：<code>void rollback()</code></li></ul></li><li>释放资源<ul><li>释放此 Connection 对象的数据库和 JDBC 资源：<code>void close()</code></li></ul></li></ul><hr><h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>Statement：执行 sql 语句的对象</p><ul><li>执行 DML 语句：<code>int executeUpdate(String sql)</code><ul><li>返回值 int：返回影响的行数</li><li>参数 sql：可以执行 insert、update、delete 语句</li></ul></li><li>执行 DQL 语句：<code>ResultSet executeQuery(String sql)</code><ul><li>返回值 ResultSet：封装查询的结果</li><li>参数 sql：可以执行 select 语句</li></ul></li><li>释放资源<ul><li>释放此 Statement 对象的数据库和 JDBC 资源：<code>void close()</code></li></ul></li></ul><hr><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>ResultSet：结果集对象，ResultSet 对象维护了一个游标，指向当前的数据行，初始在第一行</p><ul><li>判断结果集中是否有数据：<code>boolean next()</code><ul><li>有数据返回 true，并将索引<strong>向下移动一行</strong></li><li>没有数据返回 false</li></ul></li><li>获取结果集中<strong>当前行</strong>的数据：<code>XXX getXxx(&quot;列名&quot;)</code><ul><li>XXX 代表数据类型（要获取某列数据，这一列的数据类型）</li><li>例如：String getString(“name”);   int getInt(“age”);</li></ul></li><li>释放资源<ul><li>释放 ResultSet 对象的数据库和 JDBC 资源：<code>void close()</code></li></ul></li></ul><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>数据准备</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db14数据库</span><br><span class="line">CREATE DATABASE db14;</span><br><span class="line"></span><br><span class="line">-- 使用db14数据库</span><br><span class="line">USE db14;</span><br><span class="line"></span><br><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,-- 学生id</span><br><span class="line">NAME VARCHAR(20),-- 学生姓名</span><br><span class="line">age INT,-- 学生年龄</span><br><span class="line">birthday DATE,-- 学生生日</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;1999-09-23&#x27;),(NULL,&#x27;李四&#x27;,24,&#x27;1998-08-10&#x27;),</span><br><span class="line">(NULL,&#x27;王五&#x27;,25,&#x27;1996-06-06&#x27;),(NULL,&#x27;赵六&#x27;,26,&#x27;1994-10-20&#x27;);</span><br></pre></td></tr></table></figure><p>JDBC 连接代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://192.168.2.184:3306/db2&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取执行者对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行sql语句，并且接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stat.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        con.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><h4 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h4><p>SQL 注入攻击演示</p><ul><li><p>在登录界面，输入一个错误的用户名或密码，也可以登录成功 </p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA.png"></p></li><li><p>原理：我们在密码处输入的所有内容，都应该认为是密码的组成，但是 Statement 对象在执行 SQL 语句时，将一部分内容当做查询条件来执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE loginname=&#x27;aaa&#x27; AND password=&#x27;aaa&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="攻击解决"><a href="#攻击解决" class="headerlink" title="攻击解决"></a>攻击解决</h4><p>PreparedStatement：预编译 sql 语句的执行者对象，继承 <code>PreparedStatement extends Statement</code></p><ul><li>在执行 sql 语句之前，将 sql 语句进行提前编译，<strong>明确 sql 语句的格式</strong>，剩余的内容都会认为是参数</li><li>sql 语句中的参数使用 ? 作为<strong>占位符</strong></li></ul><p>为 ? 占位符赋值的方法：<code>setXxx(int parameterIndex, xxx data)</code></p><ul><li><p>参数1：? 的位置编号（编号从 1 开始）</p></li><li><p>参数2：? 的实际参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE loginname=? AND password=?&quot;</span>;</span><br><span class="line">pst = con.prepareStatement(sql);</span><br><span class="line">pst.setString(<span class="number">1</span>,loginName);</span><br><span class="line">pst.setString(<span class="number">2</span>,password);</span><br></pre></td></tr></table></figure></li></ul><p>执行 sql 语句的方法</p><ul><li>执行 insert、update、delete 语句：<code>int executeUpdate()</code></li><li>执行 select 语句：<code>ResultSet executeQuery()</code></li></ul><hr><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>数据库连接背景：数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</p><p>数据库连接池：<strong>数据库连接池负责分配、管理和释放数据库连接</strong>，它允许应用程序<strong>重复使用</strong>一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。</p><p>数据库连接池原理</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png"></p><hr><h4 id="归还连接"><a href="#归还连接" class="headerlink" title="归还连接"></a>归还连接</h4><p>使用动态代理的方式来改进</p><p>自定义数据库连接池类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="comment">//1.准备一个容器。用于保存多个数据库连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义静态代码块,获取多个连接对象保存到容器中</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">            pool.add(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供一个获取连接池大小的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//动态代理方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">proxyCon</span> <span class="operator">=</span> (Connection) Proxy.newProxyInstance(</span><br><span class="line">                con.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Connection.class&#125;, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    执行Connection实现类连接对象所有的方法都会经过invoke</span></span><br><span class="line"><span class="comment">                    如果是close方法，归还连接</span></span><br><span class="line"><span class="comment">                    如果不是，直接执行连接对象原有的功能即可</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;close&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//归还连接</span></span><br><span class="line">                        pool.add(con);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(con,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> proxyCon;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><h5 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h5><p>使用 C3P0 连接池：</p><ul><li><p>配置文件名称：c3p0-config.xml，必须放在 src 目录下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://192.168.2.184:3306/db14<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--超时时间 3000ms--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;otherc3p0&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建c3p0的数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过连接池对象获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>Druid 连接池：</p><ul><li><p>配置文件：druid.properties，必须放在 src 目录下</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db14</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取配置文件的流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidTest1.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.通过Properties集合，加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过Druid连接池工厂类获取数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过连接池对象获取数据库连接进行使用</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Jedis 用于 Java 语言连接 Redis 服务，并提供对应的操作 API</p><ul><li><p>jar 包导入</p><p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p><p>基于 maven：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>客户端连接 Redis：API 文档 <a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p><p>连接 redis：<code>Jedis jedis = new Jedis(&quot;192.168.0.185&quot;, 6379)</code></p><p>操作 redis：<code>jedis.set(&quot;name&quot;, &quot;seazean&quot;);  jedis.get(&quot;name&quot;)</code></p><p>关闭 redis：<code>jedis.close()</code></p></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.2.185&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;39&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list1 ) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;poi&quot;</span>,<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">len</span> <span class="operator">=</span> jedis.scard(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//3.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>连接池对象：</p><ul><li>JedisPool：Jedis 提供的连接池技术</li><li>poolConfig：连接池配置对象 </li><li>host：Redis 服务地址</li><li>port：Redis 服务端口号</li></ul><p>JedisPool 的构造器如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (String)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建配置文件 redis.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis.maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">redis.maxIdel</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">redis.host</span>=<span class="string">192.168.2.185</span></span><br><span class="line"><span class="attr">redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure></li><li><p>工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxIdel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jpc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        maxTotal = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        <span class="comment">//活动连接数</span></span><br><span class="line">        maxIdel = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxIdel&quot;</span>));</span><br><span class="line">        host = bundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        port = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Jedis连接配置</span></span><br><span class="line">        jpc = <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jpc.setMaxTotal(maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdel);</span><br><span class="line">        <span class="comment">//连接池对象</span></span><br><span class="line">        jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc, host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外访问接口，提供jedis连接对象，连接从连接池获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jp.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的leetcode刷题记录</title>
      <link href="/2023/03/29/myleetcode/myleetcode/"/>
      <url>/2023/03/29/myleetcode/myleetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="①-二分查找"><a href="#①-二分查找" class="headerlink" title="① 二分查找"></a>① 二分查找</h2><h3 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h3><ol><li>有序数组</li><li>无重复元素(有重复元素时的返回值不唯一，需要深思)</li></ol><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li><p>左闭右开</p><blockquote><p>区间【left,right),对应代码：while(left &lt; right)<br>  右指针没意义，即right &#x3D; nums.length</p></blockquote></li><li><p>左闭右闭</p><blockquote><p>区间【left,right】,对应代码：while(left &lt;&#x3D; right)<br>  右指针有意义，即right &#x3D; nums.length - 1;</p></blockquote></li></ul><h3 id="题目1：二分查找（力扣704）"><a href="#题目1：二分查找（力扣704）" class="headerlink" title="题目1：二分查找（力扣704）"></a><font color="red">题目1：二分查找（力扣704）</font></h3><p>给定一个 n 个元素<strong>有序</strong>的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1 </p><p>提示：</p><p>你可以假设 nums 中的<strong>所有元素是不重复的</strong>。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p><p><a href="https://leetcode.cn/problems/binary-search">题目地址</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>暴力法(次)<br>直接遍历数组，判断是否等于target,等于就返回当前索引值，否则继续。</li><li>二分法<br>由题目知该数组的元素为有序且无重复的，适合二分法。<br>① 首先选择数组中间的数字和需要查找的目标值比较<br>② 如果相等最好，就可以直接返回答案了<br>③ 如果不相等<ul><li>如果中间的数字大于目标值，则中间数字向右的所有数字都大于目标值，全部排除</li><li>如果中间的数字小于目标值，则中间数字向左的所有数字都小于目标值，全部排除</li></ul></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [-1,0,3,5,9,12], target = 8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;      <span class="comment">//指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;      <span class="comment">//中间值的索引</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;                 <span class="comment">//目标值大于中间值,则中间值左边的值去掉，即左指针右移</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;           <span class="comment">//目标值小于中间值，则去除右边的值，即右指针左移</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;                         <span class="comment">//相等，返回索引值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                  <span class="comment">//目标值不在数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题目2-搜索插入位置（力扣35）"><a href="#题目2-搜索插入位置（力扣35）" class="headerlink" title="题目2:搜索插入位置（力扣35）"></a><font color="red">题目2:搜索插入位置（力扣35）</font></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4 </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 为 无重复元素 的 升序 排列数组<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p><a href="https://leetcode.cn/problems/search-insert-position">题目地址</a></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题目中<strong>排序数组</strong>，适合用二分法<br>分析情况：</p><ol><li>目标值在数组里，且是数组中的元素<ul><li>套模板就能够找到目标值</li></ul></li><li>目标值在数组范围内，但不是数组中的元素<ul><li>思考：在终止条件时，即右指针right在左指针的前面，会发现右指针对应的值总是小于目标值，左指针的对应的值总是大于目标值，因此在right+1处即为插入的位置。</li></ul></li><li>目标值在数组范围两边，即小于数组的第一个或大于最后一个元素。<ul><li>同上面思考一样，右指针总是在左指针的左边，插入位置依然为right+1;</li></ul></li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;     <span class="comment">//情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;       <span class="comment">//其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"><a href="#题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）" class="headerlink" title="题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）"></a><font color="red">题目3：在排序数组中查找元素的第一个和最后一个位置（力扣34）</font></h3><p>给定一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ </p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>nums 是一个非递减数组<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">题目地址</a></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>分析:</p><ol><li>非递减顺序的数组即<strong>升序但可以有重复元素的数组</strong></li><li>情况①：target 在数组范围的右边或者左边，返回[-1,-1]</li><li>情况②：target 在数组范围中，且数组中不存在target，返回[-1,-1]</li><li>情况③：target 在数组范围中，且数组中存在target</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment">// nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> searchLeftBorder(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> searchRightBorder(nums, target);</span><br><span class="line">        <span class="comment">// 情况一</span></span><br><span class="line">        <span class="keyword">if</span> (leftBorder == -<span class="number">2</span> || rightBorder == -<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">if</span> (rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 情况二</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchLeftBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchRightBorder</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：x的平方根（力扣69）"><a href="#题目4：x的平方根（力扣69）" class="headerlink" title="题目4：x的平方根（力扣69）"></a><font color="red">题目4：x的平方根（力扣69）</font></h3><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p> </p><p>示例 1：</p><p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p><p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 </p><p>提示：</p><p>0 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/sqrtx/">题目地址</a></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>暴力法<br>直接从0开始遍历，当该平方的数小于等于x的值时，记录当前的值。否则跳出循环。</li><li>二分法<br>使用二分法，左指针为0，右指针为x值。当中间值的平方小于等于x的值时，记录中间值，此时需要往后移动指针判断下一个值是否满足条件。注意：中间值平方过后可能造成溢出，需要强转为long类型的数据进行判断</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ol><li>暴力法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= x/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)i*i &lt;= x)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二分法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( (<span class="type">long</span>)mid*mid &lt;= x)&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="题目5：有效的完全平方数（力扣367）"><a href="#题目5：有效的完全平方数（力扣367）" class="headerlink" title="题目5：有效的完全平方数（力扣367）"></a><font color="red">题目5：有效的完全平方数（力扣367）</font></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p><p> </p><p>示例 1：</p><p>输入：num &#x3D; 16<br>输出：true<br>示例 2：</p><p>输入：num &#x3D; 14<br>输出：false </p><p>提示：</p><p>1 &lt;&#x3D; num &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/valid-perfect-square">题目地址</a></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>与题目4思路是一致的，这里仅写二分法的代码</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid*mid == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid*mid &lt; num)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：山脉数组的峰顶索引（力扣852）"><a href="#题目6：山脉数组的峰顶索引（力扣852）" class="headerlink" title="题目6：山脉数组的峰顶索引（力扣852）"></a><font color="red">题目6：山脉数组的峰顶索引（力扣852）</font></h3><p>符合下列属性的数组 arr 称为 山脉数组 ：<br>arr.length &gt;&#x3D; 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p><p> </p><p>示例 1：</p><p>输入：arr &#x3D; [0,1,0]<br>输出：1<br>示例 2：</p><p>输入：arr &#x3D; [0,2,1,0]<br>输出：1<br>示例 3：</p><p>输入：arr &#x3D; [0,10,5,2]<br>输出：1<br>示例 4：</p><p>输入：arr &#x3D; [3,4,5,1]<br>输出：2<br>示例 5：</p><p>输入：arr &#x3D; [24,69,100,99,79,78,67,36,26,19]<br>输出：2 </p><p>提示：</p><p>3 &lt;&#x3D; arr.length &lt;&#x3D; 10^4<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10^6<br>题目数据保证 arr 是一个山脉数组 </p><p>进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？</p><p><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array">题目地址</a></p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>分析题目：<br>使用二分法解决该问题，可知满足的条件为中间索引对应的值大于前一个索引对应的值同时大于后一个索引对应的值</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="number">1</span>])&#123;         <span class="comment">//当前值小于前面的值而大于后面的值，峰顶在左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; arr[mid-<span class="number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid+<span class="number">1</span>])&#123;   <span class="comment">//当前值大于前面值而小于后面值，峰顶在右边</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//比前、后值都大,即为峰顶</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//无意义，本题中必定能找到峰顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：寻找比目标字母大的最小字母（力扣744）"><a href="#题目7：寻找比目标字母大的最小字母（力扣744）" class="headerlink" title="题目7：寻找比目标字母大的最小字母（力扣744）"></a><font color="red">题目7：寻找比目标字母大的最小字母（力扣744）</font></h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p><p>在比较时，字母是依序循环出现的。举个例子：</p><p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’ </p><p>示例 1：</p><p>输入: letters &#x3D; [“c”, “f”, “j”]，target &#x3D; “a”<br>输出: “c”<br>示例 2:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “c”<br>输出: “f”<br>示例 3:</p><p>输入: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “d”<br>输出: “f” </p><p>提示：</p><p>2 &lt;&#x3D; letters.length &lt;&#x3D; 104<br>letters[i] 是一个小写字母<br>letters 按非递减顺序排序<br>letters 最少包含两个不同的字母<br>target 是一个小写字母</p><p><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target">题目地址</a></p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><pre><code>分析：        情况①：目标值在列表左边或者在列表的右边（可以等于最右的那个值），返回letters[0];        情况②：目标值在列表里，可以不等于列表的值。        思考：用二分法时，在终止条件是，左指针指向的值总是大于目标值，右指针指向的值总是小于目标值。利用该特性与本题结合，可知返回值为letters[left]</code></pre><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//情况①</span></span><br><span class="line">        <span class="keyword">if</span>(letters[<span class="number">0</span>] &gt; target || letters[letters.length-<span class="number">1</span>] &lt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况②</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> letters.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②移除元素之双指针法"><a href="#②移除元素之双指针法" class="headerlink" title="②移除元素之双指针法"></a>②移除元素之双指针法</h2><h3 id="题目1：移除元素（力扣27）"><a href="#题目1：移除元素（力扣27）" class="headerlink" title="题目1：移除元素（力扣27）"></a><font color="red">题目1：移除元素（力扣27）</font></h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p> </p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);</p><p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>} </p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/remove-element">题目地址</a></p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>须知：在数组内“移除”元素只能是覆盖。<br>移除所有等于val的元素，相当于用不等于val的元素去覆盖等于val的元素。<br>本题中使用双指针法，快指针fast指向不等于val的值就覆盖前一个值，慢指针指向的就是前一个值。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;      <span class="comment">//快指针指向的值不等于val</span></span><br><span class="line">                nums[slow] = nums[fast];    <span class="comment">//覆盖</span></span><br><span class="line">                slow++;                     <span class="comment">//慢指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;                        <span class="comment">//此时慢指针的值就是不等于val的数组新长度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：删除有序数组中的重复项（力扣26）"><a href="#题目2：删除有序数组中的重复项（力扣26）" class="headerlink" title="题目2：删除有序数组中的重复项（力扣26）"></a><font color="red">题目2：删除有序数组中的重复项（力扣26）</font></h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p><p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p><p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 升序 排列</p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">题目地址</a></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>无</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：移动零（力扣283）"><a href="#题目3：移动零（力扣283）" class="headerlink" title="题目3：移动零（力扣283）"></a><font color="red">题目3：移动零（力扣283）</font></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums &#x3D; [0]<br>输出: [0] </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/move-zeroes">题目地址</a></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>无</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,slow,fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> slow,<span class="type">int</span> fast)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：比较含退格的字符串（力扣844）"><a href="#题目4：比较含退格的字符串（力扣844）" class="headerlink" title="题目4：比较含退格的字符串（力扣844）"></a><font color="red">题目4：比较含退格的字符串（力扣844）</font></h3><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>示例 1：</p><p>输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。<br>示例 2：</p><p>输入：s &#x3D; “ab##”, t &#x3D; “c#d#”<br>输出：true<br>解释：s 和 t 都会变成 “”。<br>示例 3：</p><p>输入：s &#x3D; “a#c”, t &#x3D; “b”<br>输出：false<br>解释：s 会变成 “c”，但 t 仍然是 “b”。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 200<br>s 和 t 只含有小写字母以及字符 ‘#’ </p><p>进阶：</p><p>你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？</p><p><a href="https://leetcode.cn/problems/backspace-string-compare">题目地址</a></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>没理清</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipS</span> <span class="operator">=</span> <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先找到 s 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS ++;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipS --;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再找到 t 中第一个需要比较的字符（即去除 # 影响后的第一个待比较字符）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT ++;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    skipT --;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后开始比较,注意有下面这个 if 条件的原因是：如果 index = 0 位置上为 &#x27;#&#x27;，则 i, j 会为 -1</span></span><br><span class="line">            <span class="comment">// 而 index = -1 的情况应当处理。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果待比较字符不同，return false</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (i &gt;= 0 &amp;&amp; j &gt;= 0) 为 false 情况为</span></span><br><span class="line">            <span class="comment">// 1. i &lt; 0 &amp;&amp; j &gt;= 0</span></span><br><span class="line">            <span class="comment">// 2. j &lt; 0 &amp;&amp; i &gt;= 0</span></span><br><span class="line">            <span class="comment">// 3. i &lt; 0 &amp;&amp; j &lt; 0</span></span><br><span class="line">            <span class="comment">// 其中，第 3 种情况为符合题意情况，因为这种情况下 s 和 t 都是 index = 0 的位置为 &#x27;#&#x27; 而这种情况下</span></span><br><span class="line">            <span class="comment">// 退格空字符即为空字符，也符合题意，应当返回 True。</span></span><br><span class="line">            <span class="comment">// 但是，情况 1 和 2 不符合题意，因为 s 和 t 其中一个是在 index &gt;= 0 处找到了待比较字符，另一个没有找到</span></span><br><span class="line">            <span class="comment">// 这种情况显然不符合题意，应当返回 False，下式便处理这种情况。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：有序数组的平方（力扣977）"><a href="#题目5：有序数组的平方（力扣977）" class="headerlink" title="题目5：有序数组的平方（力扣977）"></a><font color="red">题目5：有序数组的平方（力扣977）</font></h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p><p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 已按 非递减顺序 排序 </p><p>进阶：</p><p>请你设计时间复杂度为 O(n) 的算法解决本问题</p><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array">题目地址</a></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>题目中的数组是非递减顺序排序，可知数值平方后的最大值是在左右两边产生的。<br>需要双指针分别指向左，右。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &gt; nums[right] * nums[right])&#123;</span><br><span class="line">                res[index] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：验证回文串（力扣125）"><a href="#题目6：验证回文串（力扣125）" class="headerlink" title="题目6：验证回文串（力扣125）"></a><font color="red">题目6：验证回文串（力扣125）</font></h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入: s &#x3D; “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p><p>输入：s &#x3D; “race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p><p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 10^5<br>s 仅由可打印的 ASCII 字符组成</p><p><a href="https://leetcode.cn/problems/valid-palindrome">题目地址</a></p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[i]) &amp;&amp; i&lt;j)&#123;   <span class="comment">//非数字字母</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!isValid(c[j]) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c[i] != c[j])&#123;       <span class="comment">//数字字母，判断是否相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是小写字母或数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③子数组、子串之滑动窗口"><a href="#③子数组、子串之滑动窗口" class="headerlink" title="③子数组、子串之滑动窗口"></a>③子数组、子串之滑动窗口</h2><h3 id="题目1：长度最小的子数组（力扣209）"><a href="#题目1：长度最小的子数组（力扣209）" class="headerlink" title="题目1：长度最小的子数组（力扣209）"></a><font color="red">题目1：长度最小的子数组（力扣209）</font></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p> </p><p>示例 1：</p><p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p><p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：</p><p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0 </p><p>提示：</p><p>1 &lt;&#x3D; target &lt;&#x3D; 10^9<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum">题目地址</a></p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];             <span class="comment">//求和</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;      <span class="comment">//计算满足条件的数组子长度</span></span><br><span class="line">                res = res &lt; subLength ? res : subLength;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若res为整型的最大值，说明数组的所有数加起来都比target小，返回0；</span></span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：水果成篮（力扣904）"><a href="#题目2：水果成篮（力扣904）" class="headerlink" title="题目2：水果成篮（力扣904）"></a><font color="red">题目2：水果成篮（力扣904）</font></h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p> </p><p>示例 1：</p><p>输入：fruits &#x3D; [1,2,1]<br>输出：3<br>解释：可以采摘全部 3 棵树。<br>示例 2：</p><p>输入：fruits &#x3D; [0,1,2,2]<br>输出：3<br>解释：可以采摘 [1,2,2] 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。<br>示例 3：</p><p>输入：fruits &#x3D; [1,2,3,2,2]<br>输出：4<br>解释：可以采摘 [2,3,2,2] 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。<br>示例 4：</p><p>输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：可以采摘 [1,2,1,1,2] 这五棵树。</p><p><a href="https://leetcode.cn/problems/fruit-into-baskets">题目地址</a></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>题目分析：<br>    从某一棵树开始采摘，且必须连续采摘而不多于2种类型（值相同为同类型）的果树。如fruits &#x3D; [1,2,3,2,2]，若从1开始采摘，则只能采摘到2，因为3与前面的都不是同一类型的果树。从2开始的话，能够采摘到2,3,2,2。题目中需要返回的是子数组的最大长度。<br>思考：<br>    如果从头遍历数组，在遍历到该元素时，也就从该元素开始采摘。如何记录果树的类型不大于2 ??<br>    解决完果树类型不大于2时，同时记录子数组的长度，再返回即可。</p><p>现需要记录当前遍历的左右果树，分别用ln表示左果树类型、rn表示右果树类型。同时左（慢）指针，右（快）指针开始寻找能够装下篮子（果树类型）的水果，若右指针指向的果树类型与ln或者rn相同，记下此时能够装下的最大长度，右指针继续移动。若右指针指向的果树类型不同于ln、rn，即当前有3中类型的果树，因此需要左指针右移到右指针的前一个位置（不能是left++,参考示例4），再更新左、右果树类型。由于开始时左、右果树类型都是一样，此时需要进行判断，因为左指针移到右指针的前一个位置，但可能出现与左果树类型相同的情况。记录长度，返回即可。</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = <span class="number">0</span>;                  <span class="comment">//左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;                            <span class="comment">//记录长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> fruits[left],rn = fruits[right];   <span class="comment">//篮子一号和二号（左、右果树类型，此时果树类型相同）</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right] == rn || fruits[right] == ln)&#123;<span class="comment">//属于篮子某个种类</span></span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);  <span class="comment">//更新结果，每次取一个数就更新一下</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果遇到第三种，把慢指针移动到快指针前一步，该步的水果种类必然不同于快指针，此时慢指针慢慢回退齐所有的连续同类。</span></span><br><span class="line">                left = right - <span class="number">1</span>;  <span class="comment">//取到第三种则移动左标到right -1</span></span><br><span class="line">                ln = fruits[left]; <span class="comment">//更新第一个篮子</span></span><br><span class="line">                <span class="keyword">while</span>(left &gt;= <span class="number">1</span> &amp;&amp; fruits[left - <span class="number">1</span>] == ln) &#123;    <span class="comment">//左果树更新后回退至相同种类的开始位置</span></span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                rn = fruits[right];</span><br><span class="line">                ans = Math.max(ans,right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="题目1：移除链表元素（力扣203）"><a href="#题目1：移除链表元素（力扣203）" class="headerlink" title="题目1：移除链表元素（力扣203）"></a><font color="red">题目1：移除链表元素（力扣203）</font></h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]</p><p>示例 2：</p><p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[] </p><p>提示：</p><p>列表中的节点数目在范围 [0, 10^4] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p><p><a href="https://leetcode.cn/problems/remove-linked-list-elements">题目地址</a></p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);    <span class="comment">//虚拟结点：仅仅是串起整条链，统一操作链表</span></span><br><span class="line">        node.next = head;                   <span class="comment">//虚拟结点指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;                <span class="comment">//当前结点指向虚拟结点（node）</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val )&#123;</span><br><span class="line">                cur.next = cur.next.next;       <span class="comment">//删除等于val的结点并后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;                  <span class="comment">//后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：设计链表（力扣707）"><a href="#题目2：设计链表（力扣707）" class="headerlink" title="题目2：设计链表（力扣707）"></a><font color="red">题目2：设计链表（力扣707）</font></h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 </p><p>示例：</p><p>MyLinkedList linkedList &#x3D; new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回2<br>linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回3 </p><p>提示：</p><p>所有val值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。</p><p><a href="https://leetcode.cn/problems/design-linked-list">题目地址</a></p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode dummy;     <span class="comment">//虚拟头结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;     <span class="comment">//初始化</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123; <span class="comment">//超出索引位置</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; index;i++)&#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);   <span class="comment">//添加</span></span><br><span class="line">        add.next = pre.next;</span><br><span class="line">        pre.next = add;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;   <span class="comment">//找 index-1 的结点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next,prev;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="comment">// ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;            <span class="comment">//从head开始</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;                                  <span class="comment">//从tail开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123; </span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;   </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：反转链表（力扣206）"><a href="#题目3：反转链表（力扣206）" class="headerlink" title="题目3：反转链表（力扣206）"></a><font color="red">题目3：反转链表（力扣206）</font></h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[] </p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000 </p><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p><a href="https://leetcode.cn/problems/reverse-linked-list">题目地址</a></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针、迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;    </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//保存下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;<span class="comment">// 先保存下一个节点</span></span><br><span class="line">        cur.next = prev;<span class="comment">// 反转</span></span><br><span class="line">        <span class="comment">// 更新prev、cur位置</span></span><br><span class="line">        <span class="comment">// prev = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力，构建新链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> head; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x.val,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：两两交换链表中的节点（力扣24）"><a href="#题目4：两两交换链表中的节点（力扣24）" class="headerlink" title="题目4：两两交换链表中的节点（力扣24）"></a><font color="red">题目4：两两交换链表中的节点（力扣24）</font></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p><p>输入：head &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [1]<br>输出：[1] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs">题目地址</a></p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑：</span></span><br><span class="line"><span class="comment">// 保存第二个节点，第一个节点指向第二层的返回值，再两两交换。</span></span><br><span class="line"><span class="comment">// 例子：1-&gt;2-&gt;3-&gt;4 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一层：  </span></span><br><span class="line"><span class="comment">// 定义指针-&gt;2    1-&gt;??(第二层返回值)                    1-&gt;4-&gt;3</span></span><br><span class="line"><span class="comment">//                                                     当前层又进行交互：</span></span><br><span class="line"><span class="comment">//                                                     2-&gt;1-&gt;4-&gt;3,返回定义的指针，即新的head</span></span><br><span class="line">    ||</span><br><span class="line">    \/</span><br><span class="line"><span class="comment">// 进入第二层：</span></span><br><span class="line">    ||</span><br><span class="line">    \/                                                      /\</span><br><span class="line">                                                            ||</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">// 定义指针指向-&gt;4</span></span><br><span class="line"><span class="comment">// 3-&gt;??(进入第三层)                                    交换：4-&gt;3,返回</span></span><br><span class="line">                                                            /\</span><br><span class="line">                                                            ||</span><br><span class="line"><span class="comment">//     --&gt;                  ----&gt;                       第三层为空，返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//假设链表是 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//这句就先保存节点2</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="comment">//继续递归，处理节点3-&gt;4</span></span><br><span class="line"><span class="comment">//当递归结束返回后，就变成了4-&gt;3</span></span><br><span class="line"><span class="comment">//于是head节点就指向了4，变成1-&gt;4-&gt;3</span></span><br><span class="line">head.next = swapPairs(tmp.next);</span><br><span class="line"><span class="comment">//将2节点指向1</span></span><br><span class="line">tmp.next = head;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：删除链表的倒数第N个结点（力扣19）"><a href="#题目5：删除链表的倒数第N个结点（力扣19）" class="headerlink" title="题目5：删除链表的倒数第N个结点（力扣19）"></a><font color="red">题目5：删除链表的倒数第N个结点（力扣19）</font></h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p><p>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]<br> <br>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">题目地址</a></p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：计算链表长度，找到要删除的前一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);           <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; length -n +<span class="number">1</span>;i++)&#123;    <span class="comment">//要删除的前一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = cur.next.next;           <span class="comment">//删除倒数第n的节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法二：前后双指针（你走一步，我走一步）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;       <span class="comment">//first指针比second指针多n步</span></span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="literal">null</span>)&#123;           <span class="comment">//你一步我一步，结束时second在要删除节点的前一个节点</span></span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;     <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">//法三：递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFormEnd</span><span class="params">(ListNode head,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;   <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = removeNthFormEnd(head.next,n);</span><br><span class="line">        cur++;          <span class="comment">//递归返回时都会执行，即寻找要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(n == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;       <span class="comment">//直接抛弃要删除的节点，返回下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：面试题02-07-链表相交-lt-力扣同题160-gt"><a href="#题目6：面试题02-07-链表相交-lt-力扣同题160-gt" class="headerlink" title="题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;"></a><font color="red">题目6：面试题02.07. 链表相交&lt;力扣同题160&gt;</font></h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p> </p><p>示例 1：</p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br> <br>提示：</p><p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 10^4<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA + 1] &#x3D;&#x3D; listB[skipB + 1] </p><p>进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">题目地址</a></p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>思考：两链表长度不一，如何进行遍历？<br>可以计算出两链表的长度，进行差值，即有一个链表先移动（差值）步，再开始比较。分别用两指针指向当前该判断的位置。判断是否指针相等，若相等，则返回当前指针。若不等，则同时移动两个指针到下一个位置。</p><h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;    <span class="comment">//计算headA的长度</span></span><br><span class="line">            lengthA++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;      <span class="comment">//计算headB的长度</span></span><br><span class="line">            lengthB++;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;          <span class="comment">//判断长度的差值，使得指针在不同链表中的同一步</span></span><br><span class="line">            lengthA = lengthA - lengthB;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     <span class="comment">//指针先移动lengthA步</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lengthA = lengthB - lengthA;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; lengthA;i++)&#123;     </span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;            <span class="comment">//判断当前指针是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;           <span class="comment">//相等</span></span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;                    <span class="comment">//不相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：环形链表-lt-力扣142-gt"><a href="#题目7：环形链表-lt-力扣142-gt" class="headerlink" title="题目7：环形链表||&lt;力扣142&gt;"></a><font color="red">题目7：环形链表||&lt;力扣142&gt;</font></h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。<br> <br>提示：</p><p>链表中节点的数目范围在范围 [0, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>pos 的值为 -1 或者链表中的一个有效索引 </p><p>进阶：你是否可以使用 O(1) 空间解决此题？</p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii">题目地址</a></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.add(a);</span><br><span class="line">            a = a.next;</span><br><span class="line">            <span class="keyword">while</span>(temp.contains(a))&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="题目1：有效的字母异位词（力扣242）"><a href="#题目1：有效的字母异位词（力扣242）" class="headerlink" title="题目1：有效的字母异位词（力扣242）"></a><font color="red">题目1：有效的字母异位词（力扣242）</font></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true</p><p>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false<br> <br>提示:</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 10^4<br>s 和 t 仅包含小写字母 </p><p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p><a href="https://leetcode.cn/problems/valid-anagram">题目地址</a></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通哈希,不符合unicode字符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : record)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">var</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================================</span><br><span class="line"><span class="comment">//进阶哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; t.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(ch) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：两个数组的交集（力扣349）"><a href="#题目2：两个数组的交集（力扣349）" class="headerlink" title="题目2：两个数组的交集（力扣349）"></a><font color="red">题目2：两个数组的交集（力扣349）</font></h3><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p><p>示例 2：</p><p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的<br> <br>提示：</p><p>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays">题目地址</a></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums1)&#123;</span><br><span class="line">            set.add(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(<span class="keyword">var</span>))&#123;</span><br><span class="line">                res.add(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] str = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">var</span> : res)&#123;</span><br><span class="line">            str[i++] = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">// return res.stream().mapToInt(x -&gt; x).toArray();  //流操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：快乐数（力扣202）"><a href="#题目3：快乐数（力扣202）" class="headerlink" title="题目3：快乐数（力扣202）"></a><font color="red">题目3：快乐数（力扣202）</font></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><p>示例 1：</p><p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 2<br>输出：false<br> <br>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/happy-number">题目地址</a></p><h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;  <span class="comment">//前一个条件用于循环，后一个条件用于判断不重复</span></span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;          <span class="comment">//计算当前数的每一个位数的平方和，用total保存</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n;</span><br><span class="line">                temp = temp%<span class="number">10</span>;</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">                total += temp * temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total == <span class="number">1</span>)&#123;         <span class="comment">//位数的平方和为1，符号条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = total;          <span class="comment">//赋值重新进入循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：两数之和（力扣1）"><a href="#题目4：两数之和（力扣1）" class="headerlink" title="题目4：两数之和（力扣1）"></a><font color="red">题目4：两数之和（力扣1）</font></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p><p>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1] </p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-109 &lt;&#x3D; target &lt;&#x3D; 10^9<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？</p><p><a href="https://leetcode.cn/problems/two-sum">题目地址</a></p><h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map&lt;Integer,Integer&gt; set = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     int n = target - nums[i];</span></span><br><span class="line">        <span class="comment">//     if(set.containsKey(n))&#123;</span></span><br><span class="line">        <span class="comment">//         return new int[]&#123;set.get(n),i&#125;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     set.put(nums[i],i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return new int[0];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：四数相加-（力扣454）"><a href="#题目5：四数相加-（力扣454）" class="headerlink" title="题目5：四数相加||（力扣454）"></a><font color="red">题目5：四数相加||（力扣454）</font></h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<br> <br>示例 1：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p><ol><li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ol><p>示例 2：</p><p>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1 </p><p>提示：</p><p>n &#x3D;&#x3D; nums1.length<br>n &#x3D;&#x3D; nums2.length<br>n &#x3D;&#x3D; nums3.length<br>n &#x3D;&#x3D; nums4.length<br>1 &lt;&#x3D; n &lt;&#x3D; 200<br>-2^28 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 2^28</p><p><a href="https://leetcode.cn/problems/4sum-ii">题目地址</a></p><h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：赎金信（力扣383）"><a href="#题目6：赎金信（力扣383）" class="headerlink" title="题目6：赎金信（力扣383）"></a><font color="red">题目6：赎金信（力扣383）</font></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p>示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p><p>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p><p>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true<br> <br>提示：<br>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 10^5<br>ransomNote 和 magazine 由小写英文字母组成</p><p><a href="https://leetcode.cn/problems/ransom-note">题目地址</a></p><h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> magazine.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.put(c,map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ransomNote.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(c,map.get(c)-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">============================================================</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote,String magazine)</span>&#123;</span><br><span class="line">        <span class="comment">//记录杂志字符串出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            temp = magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            arr[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            temp = ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//对于金信中的每一个字符都在数组中查找</span></span><br><span class="line">            <span class="comment">//找到相应位减一，否则找不到返回false</span></span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：三数之和（力扣15）"><a href="#题目7：三数之和（力扣15）" class="headerlink" title="题目7：三数之和（力扣15）"></a><font color="red">题目7：三数之和（力扣15）</font></h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p><p>示例 2：</p><p>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。</p><p>示例 3：</p><p>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。 </p><p>提示：</p><p>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/3sum">题目地址</a></p><h4 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h4><p>大概懂</p><h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums); <span class="comment">// O(nlogn)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; <span class="comment">// O(n^2)</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 第一个数大于 0，后面的数都比它大，肯定不成立了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去掉重复情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                    ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3</span></span><br><span class="line">                    left++; right--; <span class="comment">// 首先无论如何先要进行加减操作</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// nums[left] + nums[right] &gt; target</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目8：四数之和（力扣18）"><a href="#题目8：四数之和（力扣18）" class="headerlink" title="题目8：四数之和（力扣18）"></a><font color="red">题目8：四数之和（力扣18）</font></h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p><p><a href="https://leetcode.cn/problems/4sum">题目地址</a></p><h4 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= nums.length -<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;  <span class="comment">//排序后的数组第一个正数都比target大。</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt;= nums.length -<span class="number">3</span>;j++)&#123;      <span class="comment">//第二个指针j</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;  <span class="comment">//排除前后数值相同</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i] + nums[j];            <span class="comment">//前2个指针的数值之和</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;                       <span class="comment">//第三个指针</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;             <span class="comment">//第四个指针</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> temp + nums[left] + nums[right]; </span><br><span class="line">                    <span class="keyword">if</span>(total &gt; target)&#123;         <span class="comment">//目标值小</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(total &lt; target)&#123;   <span class="comment">//目标值大</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//相等</span></span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i],nums[j],nums[left],nums[right])));</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;   <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; </span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])&#123;  <span class="comment">//排除前后数值相同 </span></span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++; <span class="comment">//继续看其他情况是否符合</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="题目1：反转字符串（力扣344）"><a href="#题目1：反转字符串（力扣344）" class="headerlink" title="题目1：反转字符串（力扣344）"></a><font color="red">题目1：反转字符串（力扣344）</font></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”] </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5<br>s[i] 都是 ASCII 码表中的可打印字符</p><p><a href="https://leetcode.cn/problems/reverse-string">题目地址</a></p><h4 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">                s[right] ^= s[left];</span><br><span class="line">                s[left] ^= s[right];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="comment">//其他精简写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span> - i;</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">            s[j] ^= s[i];</span><br><span class="line">            s[i] ^= s[j];</span><br><span class="line">        &#125;</span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：反转字符串-（力扣541）"><a href="#题目2：反转字符串-（力扣541）" class="headerlink" title="题目2：反转字符串||（力扣541）"></a><font color="red">题目2：反转字符串||（力扣541）</font></h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br> <br>示例 1：</p><p>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：</p><p>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由小写英文组成<br>1 &lt;&#x3D; k &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/reverse-string-ii">题目地址</a></p><h4 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h4><p>题目理解：每隔2k个反转前k个，尾数不够k个时候全部反转</p><h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);<span class="comment">//字符串长度可能小于k，则尾指针使用总长度-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：剑指Offer-05-替换空格（力扣？？？）"><a href="#题目3：剑指Offer-05-替换空格（力扣？？？）" class="headerlink" title="题目3：剑指Offer 05.替换空格（力扣？？？）"></a><font color="red">题目3：剑指Offer 05.替换空格（力扣？？？）</font></h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”<br> <br>限制：</p><p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">题目地址</a></p><h4 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//选用 StringBuilder 单线程使用，比较快，选不选都行</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">        <span class="comment">//if (&quot; &quot;.equals(String.valueOf(str.charAt(i))))&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：反转字符串中的单词（力扣151）"><a href="#题目4：反转字符串中的单词（力扣151）" class="headerlink" title="题目4：反转字符串中的单词（力扣151）"></a><font color="red">题目4：反转字符串中的单词（力扣151）</font></h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p>示例 1：</p><p>输入：s &#x3D; “the sky is blue”<br>输出：”blue is sky the”</p><p>示例 2：</p><p>输入：s &#x3D; “  hello world  “<br>输出：”world hello”<br>解释：反转后的字符串中不能存在前导空格和尾随空格。</p><p>示例 3：</p><p>输入：s &#x3D; “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 包含英文大小写字母、数字和空格 ‘ ‘<br>s 中 至少存在一个 单词</p><p>进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。</p><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string">题目地址</a></p><h4 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();                           <span class="comment">//去除前后空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;               <span class="comment">//单词的尾指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;                        <span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span>)&#123;                      <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;                     <span class="comment">//当start为0时，直接加</span></span><br><span class="line">                sb.append(s,start,end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != <span class="string">&#x27; &#x27;</span>)&#123;         <span class="comment">//当前字符不为&#x27; &#x27;,头指针找单词的头</span></span><br><span class="line">                start--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// sb.append(s.substring(start + 1 , end+1)).append(&#x27; &#x27;);</span></span><br><span class="line">                sb.append(s,start + <span class="number">1</span>,end + <span class="number">1</span>).append(<span class="string">&#x27; &#x27;</span>);     <span class="comment">//当前字符为&#x27; &#x27;,start指针此时在单词头的前一个索引位置，添加到sb中。</span></span><br><span class="line">                end = start - <span class="number">1</span>;                                <span class="comment">//移动尾指针</span></span><br><span class="line">                <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;                   <span class="comment">//两单词之间多空格的情况，找尾指针不为空字符的时候，即尾指针指向第二个单词的尾部</span></span><br><span class="line">                    end--;                                      </span><br><span class="line">                &#125;</span><br><span class="line">                start = end;                                    <span class="comment">//头指针与尾指针都指向第二个单词的尾部，重复如此</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：剑指Offer-58-左旋转字符串（力扣？？？）"><a href="#题目5：剑指Offer-58-左旋转字符串（力扣？？？）" class="headerlink" title="题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）"></a><font color="red">题目5：剑指Offer 58 - ||.左旋转字符串（力扣？？？）</font></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：</p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p><p>示例 2：</p><p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”<br> <br>限制：</p><p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">题目地址</a></p><h4 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">// sb.append(s,n,s.length());</span></span><br><span class="line">        <span class="comment">// sb.append(s,0,n);</span></span><br><span class="line">        <span class="comment">// return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：找出字符串中第一个匹配的下标（力扣28）"><a href="#题目6：找出字符串中第一个匹配的下标（力扣28）" class="headerlink" title="题目6：找出字符串中第一个匹配的下标（力扣28）"></a><font color="red">题目6：找出字符串中第一个匹配的下标（力扣28）</font></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>示例 1：</p><p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p><p>示例 2：</p><p>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。</p><p>提示：</p><p>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 10^4<br>haystack 和 needle 仅由小写英文字符组成</p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">题目地址</a></p><h4 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h4><p>未理清kmp</p><h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="type">char</span>[] s = haystack.toCharArray(), p = needle.toCharArray();</span><br><span class="line">        <span class="comment">// 枚举原串的「发起点」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从原串的「发起点」和匹配串的「首位」开始，尝试匹配</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; m &amp;&amp; s[a] == p[b]) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果能够完全匹配，返回原串的「发起点」下标</span></span><br><span class="line">            <span class="keyword">if</span> (b == m) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack,String needle)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;        <span class="comment">//构造next数组（pi）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;          <span class="comment">//匹配</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：重复的子字符串（力扣459）"><a href="#题目7：重复的子字符串（力扣459）" class="headerlink" title="题目7：重复的子字符串（力扣459）"></a><font color="red">题目7：重复的子字符串（力扣459）</font></h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p>示例 1:</p><p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p><p>输入: s &#x3D; “aba”<br>输出: false<br>示例 3:</p><p>输入: s &#x3D; “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)<br> <br>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 由小写英文字母组成</p><p><a href="https://leetcode.cn/problems/repeated-substring-pattern">题目地址</a></p><h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= m/<span class="number">2</span>;i++)&#123;        <span class="comment">//能够由子字符串构成的字符串，子字符串的长度必定是字符串长度的一半以内</span></span><br><span class="line">            <span class="keyword">if</span>(m % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ;j &lt; m; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="题目1：用栈实现队列-力扣232"><a href="#题目1：用栈实现队列-力扣232" class="headerlink" title="题目1：用栈实现队列(力扣232)"></a><font color="red">题目1：用栈实现队列(力扣232)</font></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>示例 1：</p><p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p><p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false<br> <br>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用 100 次 push、pop、peek 和 empty<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）<br> <br>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks">题目地址</a></p><h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>根据队列FIFO的特性，用两个栈(LIFO特性)模拟。栈1负责元素进栈，栈2负责接收栈1的元素，并做出栈等操作。</p><h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//用栈模拟队列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;  <span class="comment">//栈1(元素进栈)</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;  <span class="comment">//栈2(栈1的元素出栈，该栈负责元素出栈及获取栈顶元素)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();       <span class="comment">//将栈1的元素弹出并进栈2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// while(!stack1.isEmpty())&#123;</span></span><br><span class="line">            <span class="comment">//     stack2.push(stack1.pop());</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            outStack1_AndInStack2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队空?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty()&amp;&amp;stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈1元素出栈到栈2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outStack1_AndInStack2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：用队列实现栈-力扣225"><a href="#题目2：用队列实现栈-力扣225" class="headerlink" title="题目2：用队列实现栈(力扣225)"></a><font color="red">题目2：用队列实现栈(力扣225)</font></h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br> <br>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False<br> <br>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空<br> <br>进阶：你能否仅用一个队列来实现栈。</p><p><a href="https://leetcode.cn/problems/implement-stack-using-queues">题目地址</a></p><h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><p>根据栈的特性LIFO，以及队列的特性FIFO,使用两个队列实现栈。首先队列1负责元素进出队，队列2负责临时存储元素。在元素进入队列1时，为达到LIFO的特性，用上临时存储队列2，先将队列2中所有的元素全部进队到队列1中，再交换队列，即交换存储空间（队列交换）达到队列1始终为空.</p><h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; a;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        a.offer(x);             <span class="comment">//元素进入队列1</span></span><br><span class="line">        <span class="keyword">while</span>(!b.isEmpty())&#123;    <span class="comment">//将队列2中的所有元素入队1</span></span><br><span class="line">            a.offer(b.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换保证a始终为空</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"><span class="comment">//一个队列实现栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：有效的括号-力扣20"><a href="#题目3：有效的括号-力扣20" class="headerlink" title="题目3：有效的括号(力扣20)"></a><font color="red">题目3：有效的括号(力扣20)</font></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true</p><p>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true</p><p>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4<br>s 仅由括号 ‘()[]{}’ 组成</p><p><a href="https://leetcode.cn/problems/valid-parentheses">题目地址</a></p><h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h4><p>该题不是那种穿插的括号，直接进行判断即可</p><h4 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;[&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (stack.isEmpty() == <span class="literal">true</span> || stack.pop() != <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">//哈希快速匹配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//右括号为键，左括号为值</span></span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;    <span class="comment">//右括号进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != map.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">//左括号直接进栈</span></span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈为空，即全部匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：删除字符串中的所有相邻重复项-力扣1047"><a href="#题目4：删除字符串中的所有相邻重复项-力扣1047" class="headerlink" title="题目4：删除字符串中的所有相邻重复项(力扣1047)"></a><font color="red">题目4：删除字符串中的所有相邻重复项(力扣1047)</font></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。<br> <br>提示：<br>1 &lt;&#x3D; S.length &lt;&#x3D; 20000<br>S 仅由小写英文字母组成。</p><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">题目地址</a></p><h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈思想实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">0</span> &amp;&amp; stack.charAt(top) == ch) &#123;</span><br><span class="line">                stack.deleteCharAt(top);</span><br><span class="line">                --top;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.append(ch);</span><br><span class="line">                ++top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================================================</span><br><span class="line"><span class="comment">//数组实现（还是栈的思想）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;   <span class="comment">//栈顶指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top == -<span class="number">1</span> || ch[top] != ch[i]) &#123;    <span class="comment">//当前元素与栈顶元素不一致就进栈</span></span><br><span class="line">                ch[++top] = ch[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top--;      <span class="comment">//删除栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch, <span class="number">0</span>, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：逆波兰表达式求值-力扣150"><a href="#题目5：逆波兰表达式求值-力扣150" class="headerlink" title="题目5：逆波兰表达式求值(力扣150)"></a><font color="red">题目5：逆波兰表达式求值(力扣150)</font></h3><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p><p>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</p><p>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22 </p><p>提示：</p><p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 10^4<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">题目地址</a></p><h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h4><p>是数字就进栈，是运算符则出栈2个数进行操作后再进栈。</p><h4 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String item : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>) || item.equals(<span class="string">&quot;-&quot;</span>) || item.equals(<span class="string">&quot;*&quot;</span>) || item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1+num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2-num1);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num1*num2);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    stack.push(num2/num1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(item));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span></span><br><span class="line">                stack.push(stack.pop() + stack.pop());      <span class="comment">// 注意 - 和/ 需要特殊处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：滑动窗口最大值-力扣239"><a href="#题目6：滑动窗口最大值-力扣239" class="headerlink" title="题目6：滑动窗口最大值(力扣239)"></a><font color="red">题目6：滑动窗口最大值(力扣239)</font></h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                  最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><p>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]<br> <br>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p><a href="https://leetcode.cn/problems/sliding-window-maximum">题目地址</a></p><h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h4><p>难啊</p><h4 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加元素时，如果要添加的元素大于队尾处的元素，就将队尾元素弹出（保证对首元素始终大于队尾元素）</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 如果队首存储的角标就是滑动窗口左边界数值，就移除队首（保证窗口大小为k）</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; (i - k) == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当i增长到第一个窗口右边界时，每滑动一步都将队首角标对应元素(窗口最大值)放入结果数组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：前K个高频元素-力扣347"><a href="#题目7：前K个高频元素-力扣347" class="headerlink" title="题目7：前K个高频元素(力扣347)"></a><font color="red">题目7：前K个高频元素(力扣347)</font></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的<br> <br>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements">题目地址</a></p><h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h4><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><h4 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    解法<span class="number">1</span>：基于大顶堆实现</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//大顶堆需要对所有元素进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//依次从队头弹出k个,就是出现频率前k高的元素</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=======================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">//解法2：基于小顶堆实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;<span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();<span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="题目1：二叉树的前序遍历-力扣144"><a href="#题目1：二叉树的前序遍历-力扣144" class="headerlink" title="题目1：二叉树的前序遍历(力扣144)"></a><font color="red">题目1：二叉树的前序遍历(力扣144)</font></h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>示例 1：<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>示例 4：</p><p>输入：root &#x3D; [1,2]<br>输出：[1,2]</p><p>示例 5：</p><p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]<br> <br>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">题目地址</a></p><h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pre(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(root.val);</span><br><span class="line">        pre(root.left,list);</span><br><span class="line">        pre(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//官方迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="comment">//morris算法(二叉搜索树)</span></span><br><span class="line"><span class="comment">//实现原则</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    1.如果cur无左孩子，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">    2.如果cur有左孩子，找到cur左子树上最右的节点，记为mostright</span></span><br><span class="line"><span class="comment">        1.如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</span></span><br><span class="line"><span class="comment">        2.如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur表示当前节点，mostRight表示cur的左孩子的最右节点</span></span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// cur有左孩子，找到cur左子树最右节点</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// mostRight的右孩子指向空，让其指向cur，cur向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// mostRight的右孩子指向cur，让其指向空，cur向右移动</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.print(cur.value + &quot; &quot;);</span></span><br><span class="line">                res.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">//二叉树的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node root; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        createTree(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        List &lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//新建一个list集合，将数据变为各个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> temp : data) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        root=list.get(<span class="number">0</span>);<span class="comment">//将第一个元素设置为根节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用构建完全二叉树的方式构建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(( i*<span class="number">2</span> + <span class="number">1</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setLeft(list.get(i*<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i*<span class="number">2</span>+<span class="number">2</span>) &lt; list.size())&#123;</span><br><span class="line">                list.get(i).setRight(list.get(i*<span class="number">2</span>+<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123; <span class="comment">// 得到根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value,Node left,Node right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(Node left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：二叉树的中序遍历-力扣94"><a href="#题目2：二叉树的中序遍历-力扣94" class="headerlink" title="题目2：二叉树的中序遍历(力扣94)"></a><font color="red">题目2：二叉树的中序遍历(力扣94)</font></h3><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">题目地址</a></p><h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：二叉树的后序遍历-力扣145"><a href="#题目3：二叉树的后序遍历-力扣145" class="headerlink" title="题目3：二叉树的后序遍历(力扣145)"></a><font color="red">题目3：二叉树的后序遍历(力扣145)</font></h3><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]<br> <br>提示：</p><p>树中节点的数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">题目地址</a></p><h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postorder(root.left,list);</span><br><span class="line">        postorder(root.right,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：二叉树的层序遍历-力扣102"><a href="#题目4：二叉树的层序遍历-力扣102" class="headerlink" title="题目4：二叉树的层序遍历(力扣102)"></a><font color="red">题目4：二叉树的层序遍历(力扣102)</font></h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">题目地址</a></p><h4 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS（breadth first search：广度优先算法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();   <span class="comment">//存放结果集</span></span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//存放结点的队列</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;  </span><br><span class="line">        que.offerLast(root);            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();                   </span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">                list.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offerLast(node.right);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目5：二叉树的层序遍历-力扣107"><a href="#题目5：二叉树的层序遍历-力扣107" class="headerlink" title="题目5：二叉树的层序遍历||(力扣107)"></a><font color="red">题目5：二叉树的层序遍历||(力扣107)</font></h3><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii">题目地址</a></p><h4 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每一层的结点数量</span></span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//存放第i层数组的值，i从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,ret);         <span class="comment">//往结果集中的第0个位置存放，使得遍历完每一层的结果都在最前面，达到从下往上遍历的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目6：二叉树的右视图-力扣199"><a href="#题目6：二叉树的右视图-力扣199" class="headerlink" title="题目6：二叉树的右视图(力扣199)"></a><font color="red">题目6：二叉树的右视图(力扣199)</font></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]</p><p>示例 2:</p><p>输入: [1,null,3]<br>输出: [1,3]</p><p>示例 3:</p><p>输入: []<br>输出: []<br> <br>提示:</p><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view">题目地址</a></p><h4 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，取最后一个节点的值即可</p><h4 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();   <span class="comment">//同一层的结点数量</span></span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7：二叉树的层平均值-力扣637"><a href="#题目7：二叉树的层平均值-力扣637" class="headerlink" title="题目7：二叉树的层平均值(力扣637)"></a><font color="red">题目7：二叉树的层平均值(力扣637)</font></h3><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。</p><p>示例 2:</p><p>输入：root &#x3D; [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p><p>提示：</p><p>树中节点数量在 [1, 10^4] 范围内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">题目地址</a></p><h4 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，遍历一层就计算出每一层的平均值。</p><h4 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> len;        <span class="comment">//每层节点数量</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;     <span class="comment">//层序遍历每一层，得到每一层的总值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(sum/count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目8：N叉树的层序遍历-力扣637"><a href="#题目8：N叉树的层序遍历-力扣637" class="headerlink" title="题目8：N叉树的层序遍历(力扣637)"></a><font color="red">题目8：N叉树的层序遍历(力扣637)</font></h3><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]</p><p>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]<br> <br>提示：</p><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal">题目地址</a></p><h4 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                ret.add(node.val);</span><br><span class="line">                <span class="keyword">for</span>(Node ch : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Iterator&lt;Node&gt; iter = node.children.iterator();</span></span><br><span class="line">                <span class="comment">// while(iter.hasNext())&#123;</span></span><br><span class="line">                <span class="comment">//     que.offer(iter.next());</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目9：在每个树中找最大值-力扣515"><a href="#题目9：在每个树中找最大值-力扣515" class="headerlink" title="题目9：在每个树中找最大值(力扣515)"></a><font color="red">题目9：在每个树中找最大值(力扣515)</font></h3><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><p>输入: root &#x3D; [1,3,2,5,3,null,9]<br>输出: [1,3,9]</p><p>示例2：</p><p>输入: root &#x3D; [1,2,3]<br>输出: [1,3]</p><p>提示：</p><p>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row">题目地址</a></p><h4 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h4><p>层序遍历</p><h4 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                max = node.val &gt; max ? node.val : max;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目10：填充每个节点的下一个右侧节点指针-力扣116"><a href="#题目10：填充每个节点的下一个右侧节点指针-力扣116" class="headerlink" title="题目10：填充每个节点的下一个右侧节点指针(力扣116)"></a><font color="red">题目10：填充每个节点的下一个右侧节点指针(力扣116)</font></h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3,4,5,6,7]</p><p>输出：[1,#,2,3,#,4,5,6,7,#]</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p><p>示例 2:</p><p>输入：root &#x3D; []<br>输出：[]<br> <br>提示：</p><p>树中节点的数量在 [0, 2^12 - 1] 范围内</p><p>-1000 &lt;&#x3D; node.val &lt;&#x3D; 1000<br> <br>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node">题目地址</a></p><h4 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//先前出队的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//当前出队的节点</span></span><br><span class="line"></span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();       <span class="comment">//每层的节点数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;             </span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();       </span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;      <span class="comment">//非最右侧节点指向先前出队的节点</span></span><br><span class="line">                    cur.next = pre;     </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;      <span class="comment">//每层的节点遵循从右往左入队</span></span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目11：填充每个节点的下一个右侧节点指针-力扣117"><a href="#题目11：填充每个节点的下一个右侧节点指针-力扣117" class="headerlink" title="题目11：填充每个节点的下一个右侧节点指针||(力扣117)"></a><font color="red">题目11：填充每个节点的下一个右侧节点指针||(力扣117)</font></h3><p>给定一个二叉树</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 </p><p>示例：</p><p>输入：root &#x3D; [1,2,3,4,5,null,7]</p><p>输出：[1,#,2,3,#,4,5,7,#]</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。 </p><p>提示：</p><p>树中的节点数小于 6000<br>-100 &lt;&#x3D; node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">题目地址</a></p><h4 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> len;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = que.poll();</span><br><span class="line">                <span class="keyword">if</span>(len != len2)&#123;</span><br><span class="line">                    cur.next = pre;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(cur.left);</span><br><span class="line">                &#125; </span><br><span class="line">                len--;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目12：二叉树的最大深度-力扣104"><a href="#题目12：二叉树的最大深度-力扣104" class="headerlink" title="题目12：二叉树的最大深度(力扣104)"></a><font color="red">题目12：二叉树的最大深度(力扣104)</font></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>返回它的最大深度 3 。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">题目地址</a></p><h4 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS(深度优先搜索)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================</span><br><span class="line"><span class="comment">//BFS(广度优先遍历)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125; </span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目13：二叉树的最小深度-力扣111"><a href="#题目13：二叉树的最小深度-力扣111" class="headerlink" title="题目13：二叉树的最小深度(力扣111)"></a><font color="red">题目13：二叉树的最小深度(力扣111)</font></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2</p><p>示例 2：</p><p>输入：root &#x3D; [2,null,3,null,4,null,5,null,6]<br>输出：5<br> <br>提示：</p><p>树中节点数的范围在 [0, 10^5] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree">题目地址</a></p><h4 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;  <span class="comment">//该层的节点若没有左右节点即为最小的深度</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目14：翻转二叉树-力扣226"><a href="#题目14：翻转二叉树-力扣226" class="headerlink" title="题目14：翻转二叉树(力扣226)"></a><font color="red">题目14：翻转二叉树(力扣226)</font></h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>示例 2：</p><p>输入：root &#x3D; [2,1,3]<br>输出：[2,3,1]</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目范围在 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/invert-binary-tree">题目地址</a></p><h4 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//前序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(rightTree);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//后序+递归</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.right = leftNode;</span><br><span class="line">        root.left = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=====================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//层序</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = rightNode;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目15：对称二叉树-力扣101"><a href="#题目15：对称二叉树-力扣101" class="headerlink" title="题目15：对称二叉树(力扣101)"></a><font color="red">题目15：对称二叉树(力扣101)</font></h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br> <br>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p><p><a href="https://leetcode.cn/problems/symmetric-tree">题目地址</a></p><h4 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode leftNode,TreeNode rightNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(leftNode.left,rightNode.right) &amp;&amp; check(leftNode.right,rightNode.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        que.offer(root.left);</span><br><span class="line">        que.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.offer(leftNode.left);</span><br><span class="line">            que.offer(rightNode.right);</span><br><span class="line"></span><br><span class="line">            que.offer(leftNode.right);</span><br><span class="line">            que.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目16：相同的树-力扣100"><a href="#题目16：相同的树-力扣100" class="headerlink" title="题目16：相同的树(力扣100)"></a><font color="red">题目16：相同的树(力扣100)</font></h3><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><p>输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]<br>输出：true</p><p>示例 2：</p><p>输入：p &#x3D; [1,2], q &#x3D; [1,null,2]<br>输出：false</p><p>示例 3：</p><p>输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]<br>输出：false<br> <br>提示：</p><p>两棵树上的节点数目都在范围 [0, 100] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/same-tree">题目地址</a></p><h4 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> check(p.left,q.left) &amp;&amp; check(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(p);</span><br><span class="line">        que.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span> || node1.val != node2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            que.offer(node1.left);</span><br><span class="line">            que.offer(node2.left);</span><br><span class="line"></span><br><span class="line">            que.offer(node1.right);</span><br><span class="line">            que.offer(node2.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目17：另一棵树的子树-力扣572"><a href="#题目17：另一棵树的子树-力扣572" class="headerlink" title="题目17：另一棵树的子树(力扣572)"></a><font color="red">题目17：另一棵树的子树(力扣572)</font></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p>示例 1：</p><p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [3,4,5,1,2,null,null,null,null,0], subRoot &#x3D; [4,1,2]<br>输出：false<br> <br>提示：</p><p>root 树上的节点数量范围是 [1, 2000]<br>subRoot 树上的节点数量范围是 [1, 1000]<br>-10^4 &lt;&#x3D; root.val &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; subRoot.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/subtree-of-another-tree">题目地址</a></p><h4 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//树的子树的结果</span></span><br><span class="line">    <span class="comment">//1.树相同</span></span><br><span class="line">    <span class="comment">//2.是该树的左子树的子树</span></span><br><span class="line">    <span class="comment">//3.是该树的右子树的子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//1.树相同</span></span><br><span class="line">        <span class="keyword">if</span>(isSameTree(root,subRoot))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子树</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || subRoot == <span class="literal">null</span> || root.val != subRoot.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(root.left,subRoot.left) &amp;&amp; isSameTree(root.right,subRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目18：N叉树的最大深度-力扣559"><a href="#题目18：N叉树的最大深度-力扣559" class="headerlink" title="题目18：N叉树的最大深度(力扣559)"></a><font color="red">题目18：N叉树的最大深度(力扣559)</font></h3><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：3</p><p>示例 2：</p><p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：5</p><p>提示：</p><p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 10^4] 之间。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree">题目地址</a></p><h4 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            depth = Math.max(depth,maxDepth(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node n : node.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n != <span class="literal">null</span>)&#123;</span><br><span class="line">                        que.offer(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; </span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目19：完全二叉树的节点个数-力扣222"><a href="#题目19：完全二叉树的节点个数-力扣222" class="headerlink" title="题目19：完全二叉树的节点个数(力扣222)"></a><font color="red">题目19：完全二叉树的节点个数(力扣222)</font></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6</p><p>示例 2：</p><p>输入：root &#x3D; []<br>输出：0</p><p>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：1<br> <br>提示：</p><p>树中节点的数目范围是[0, 5 * 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 1^04<br>题目数据保证输入的树是 完全二叉树</p><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes">题目地址</a></p><h4 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目20：完全二叉树的节点个数-力扣222"><a href="#题目20：完全二叉树的节点个数-力扣222" class="headerlink" title="题目20：完全二叉树的节点个数(力扣222)"></a><font color="red">题目20：完全二叉树的节点个数(力扣222)</font></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false</p><p>示例 3：</p><p>输入：root &#x3D; []<br>输出：true<br> <br>提示：</p><p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/balanced-binary-tree">题目地址</a></p><h4 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目21：二叉树的所有路径-力扣257"><a href="#题目21：二叉树的所有路径-力扣257" class="headerlink" title="题目21：二叉树的所有路径(力扣257)"></a><font color="red">题目21：二叉树的所有路径(力扣257)</font></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><p>叶子节点 是指没有子节点的节点。<br> <br>示例 1：</p><p>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]</p><p>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[“1”]</p><p>提示：</p><p>树中节点的数目在范围 [1, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><a href="https://leetcode.cn/problems/binary-tree-paths">题目地址</a></p><h4 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,StringBuffer s,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        s.append(root.val); <span class="comment">//根值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;    <span class="comment">//叶子节点</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res);</span><br><span class="line">        dfs(root.right,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s).append(<span class="string">&quot;-&gt;&quot;</span>),res); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目22：左子树之和-力扣404"><a href="#题目22：左子树之和-力扣404" class="headerlink" title="题目22：左子树之和(力扣404)"></a><font color="red">题目22：左子树之和(力扣404)</font></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><p>示例 1：</p><p>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p>示例 2:</p><p>输入: root &#x3D; [1]<br>输出: 0</p><p>提示:</p><p>节点数在 [1, 1000] 范围内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p><a href="https://leetcode.cn/problems/sum-of-left-leaves">题目地址</a></p><h4 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;    <span class="comment">//当前遍历的左节点不为null时，且是叶子节点</span></span><br><span class="line">            res += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目23：找树左下角的值-力扣513"><a href="#题目23：找树左下角的值-力扣513" class="headerlink" title="题目23：找树左下角的值(力扣513)"></a><font color="red">题目23：找树左下角的值(力扣513)</font></h3><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例 1:</p><p>输入: root &#x3D; [2,1,3]<br>输出: 1</p><p>示例 2:</p><p>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7<br> <br>提示:</p><p>二叉树的节点个数的范围是 [1,10^4]<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 </p><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value">题目地址</a></p><h4 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//层序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            root = que.poll();</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                que.offer(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目24：前中、中后构造二叉树-力扣xxx-不会"><a href="#题目24：前中、中后构造二叉树-力扣xxx-不会" class="headerlink" title="题目24：前中、中后构造二叉树(力扣xxx)不会"></a><font color="red">题目24：前中、中后构造二叉树(力扣xxx)不会</font></h3><h3 id="题目26：最大二叉树-力扣654"><a href="#题目26：最大二叉树-力扣654" class="headerlink" title="题目26：最大二叉树(力扣654)"></a><font color="red">题目26：最大二叉树(力扣654)</font></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p><ul><li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul><li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul><li>空数组，无子节点。</li><li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul><li>空数组，无子节点。</li><li>只有一个元素，所以子节点是一个值为 1 的节点。</li></ul></li></ul></li><li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul><li>只有一个元素，所以子节点是一个值为 0 的节点。</li><li>空数组，无子节点。</li></ul></li></ul></li></ul><p>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[3,null,2,null,1]<br> <br>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums 中的所有整数 互不相同</p><p><a href="https://leetcode.cn/problems/maximum-binary-tree">题目地址</a></p><h4 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>;i &lt;= end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[index])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[index]);</span><br><span class="line">        node.left = construct(nums, start, index - <span class="number">1</span>);</span><br><span class="line">        node.right = construct(nums, index + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目27：合并二叉树-力扣617"><a href="#题目27：合并二叉树-力扣617" class="headerlink" title="题目27：合并二叉树(力扣617)"></a><font color="red">题目27：合并二叉树(力扣617)</font></h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><p>示例 1：</p><p>输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]</p><p>示例 2：</p><p>输入：root1 &#x3D; [1], root2 &#x3D; [1,2]<br>输出：[2,2]<br> <br>提示：</p><p>两棵树中的节点数目在范围 [0, 2000] 内<br>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees">题目地址</a></p><h4 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目28：二叉搜索树的搜索-力扣700"><a href="#题目28：二叉搜索树的搜索-力扣700" class="headerlink" title="题目28：二叉搜索树的搜索(力扣700)"></a><font color="red">题目28：二叉搜索树的搜索(力扣700)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><p>示例 1:</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2<br>输出：[2,1,3]</p><p>示例 2:</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[]<br> <br>提示：</p><p>数中节点数在 [1, 5000] 范围内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^7<br>root 是二叉搜索树<br>1 &lt;&#x3D; val &lt;&#x3D; 10^7</p><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree">题目地址</a></p><h4 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> searchBST(val &lt; root.val ? root.left : root.right, val); <span class="comment">//根据二叉搜索树的性质，根的值比左边大，比右边小。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目29：验证二叉搜索树-力扣98"><a href="#题目29：验证二叉搜索树-力扣98" class="headerlink" title="题目29：验证二叉搜索树(力扣98)"></a><font color="red">题目29：验证二叉搜索树(力扣98)</font></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><p>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<br> <br>提示：</p><p>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><p><a href="https://leetcode.cn/problems/validate-binary-search-tree">题目地址</a></p><h4 id="思路-70"><a href="#思路-70" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左子树小于当前根节点，右子树大于当前根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(TreeNode root,<span class="type">long</span> min,<span class="type">long</span> max)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;       <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> validBST(root.left,min,root.val) &amp;&amp; validBST(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目30：二叉搜索树的最小绝对差-力扣530或783"><a href="#题目30：二叉搜索树的最小绝对差-力扣530或783" class="headerlink" title="题目30：二叉搜索树的最小绝对差(力扣530或783)"></a><font color="red">题目30：二叉搜索树的最小绝对差(力扣530或783)</font></h3><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,6,1,3]<br>输出：1</p><p>示例 2：</p><p>输入：root &#x3D; [1,0,48,null,null,12,49]<br>输出：1<br> <br>提示：</p><p>树中节点的数目范围是 [2, 10^4]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">题目地址</a></p><h4 id="思路-71"><a href="#思路-71" class="headerlink" title="思路"></a>思路</h4><p>利用二叉搜索树的性质（左子树小于根，根小于右），当转成数组时，二叉搜索树（中序遍历）就是一个升序的数组，<strong>即BST的中序遍历就是遍历一个有序数组</strong>，利用这个可以解决本题。</p><h4 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目31：二叉搜索树中的众数-力扣501"><a href="#题目31：二叉搜索树中的众数-力扣501" class="headerlink" title="题目31：二叉搜索树中的众数(力扣501)"></a><font color="red">题目31：二叉搜索树中的众数(力扣501)</font></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树<br> <br>示例 1：</p><p>输入：root &#x3D; [1,null,2,2]<br>输出：[2]</p><p>示例 2：</p><p>输入：root &#x3D; [0]<br>输出：[0]<br> <br>提示：</p><p>树中节点的数目在范围 [1, 10^4] 内<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree">题目地址</a></p><h4 id="思路-72"><a href="#思路-72" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curent</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示当前节点的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最大的重复数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="comment">//把集合list转化为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        inOrderTraversal(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是对当前节点的一些逻辑操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeValue</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">if</span> (nodeValue == curent) &#123;</span><br><span class="line">            <span class="comment">//如果节点值等于curent，count就加1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，就表示遇到了一个新的值，curent和count都要</span></span><br><span class="line">            <span class="comment">//重新赋值</span></span><br><span class="line">            curent = nodeValue;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            <span class="comment">//如果count == maxCount，就把当前节点加入到集合中</span></span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//否则，当前节点的值重复量是最多的，直接把list清空，然后</span></span><br><span class="line">            <span class="comment">//把当前节点的值加入到集合中</span></span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(nodeValue);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历右子树</span></span><br><span class="line">        inOrderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目32：二叉树的最近公共祖先-力扣236"><a href="#题目32：二叉树的最近公共祖先-力扣236" class="headerlink" title="题目32：二叉树的最近公共祖先(力扣236)"></a><font color="red">题目32：二叉树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><p>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p><p>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1<br> <br>提示：</p><p>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">题目地址</a></p><h4 id="思路-73"><a href="#思路-73" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="comment">//当遍历到叶结点后就会返回null</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;<span class="comment">//当找到p或者q的是时候就会返回pq</span></span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外</span></span><br><span class="line"><span class="comment">                     一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);<span class="comment">//返回的结点进行保存，可能是null</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);<span class="comment">//也可能是pq，还可能是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//如果左右都存在，就说明pq都出现了，这就是，公共祖先，此时不用考虑公共祖先是自己的情况，因为上面已经做过判断了。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;<span class="comment">//否则我们返回已经找到的那个值（存储在left，与right中），p或者q</span></span><br><span class="line">            <span class="keyword">return</span> left;<span class="comment">//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目33：二叉搜索树的最近公共祖先-力扣236"><a href="#题目33：二叉搜索树的最近公共祖先-力扣236" class="headerlink" title="题目33：二叉搜索树的最近公共祖先(力扣236)"></a><font color="red">题目33：二叉搜索树的最近公共祖先(力扣236)</font></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><p>示例 2:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">题目地址</a></p><h4 id="思路-74"><a href="#思路-74" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目34：二叉搜索树的插入操作-力扣701"><a href="#题目34：二叉搜索树的插入操作-力扣701" class="headerlink" title="题目34：二叉搜索树的插入操作(力扣701)"></a><font color="red">题目34：二叉搜索树的插入操作(力扣701)</font></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p><p>示例 2：</p><p>输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25<br>输出：[40,20,60,10,30,50,70,null,null,25]</p><p>示例 3：</p><p>输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br> <br>提示：</p><p>树中的节点数将在 [0, 10^4]的范围内。<br>-10^8 &lt;&#x3D; Node.val &lt;&#x3D; 10^8<br>所有值 Node.val 是 独一无二 的。<br>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8<br>保证 val 在原始BST中不存在。</p><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree">题目地址</a></p><h4 id="思路-75"><a href="#思路-75" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目35：刪除二叉搜索树的节点-力扣450"><a href="#题目35：刪除二叉搜索树的节点-力扣450" class="headerlink" title="题目35：刪除二叉搜索树的节点(力扣450)"></a><font color="red">题目35：刪除二叉搜索树的节点(力扣450)</font></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p><p>示例 1:</p><p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p><p>示例 2:</p><p>输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点</p><p>示例 3:</p><p>输入: root &#x3D; [], key &#x3D; 0<br>输出: []</p><p>提示:</p><p>节点数的范围 [0, 10^4].<br>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5<br>节点值唯一<br>root 是合法的二叉搜索树<br>-10^5 &lt;&#x3D; key &lt;&#x3D; 10^5</p><p>进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h4 id="思路-76"><a href="#思路-76" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 去右子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val)    </span><br><span class="line">            root.left = deleteNode(root.left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  &#123;  <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>)   <span class="keyword">return</span> root.right;      <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>)  <span class="keyword">return</span> root.left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.left!=<span class="literal">null</span> &amp;&amp; root.right !=<span class="literal">null</span>)&#123;  <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;   </span><br><span class="line">                <span class="keyword">while</span> (node.left != <span class="literal">null</span>)      <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                    node = node.left;</span><br><span class="line"></span><br><span class="line">                node.left = root.left;     <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">                root = root.right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目36：修剪二叉搜索树-力扣669"><a href="#题目36：修剪二叉搜索树-力扣669" class="headerlink" title="题目36：修剪二叉搜索树(力扣669)"></a><font color="red">题目36：修剪二叉搜索树(力扣669)</font></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p>示例 1：</p><p>输入：root &#x3D; [1,0,2], low &#x3D; 1, high &#x3D; 2<br>输出：[1,null,2]</p><p>示例 2：</p><p>输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3<br>输出：[3,2,null,1]</p><p>提示：</p><p>树中节点数在范围 [1, 10^4] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^4<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 10^4</p><h4 id="思路-77"><a href="#思路-77" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最大值大，直接返回左子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点比最小值小，直接返回右子树的trimBST</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别对左右子树进行处理</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目37：将有序数组转换为二叉搜索树-力扣108"><a href="#题目37：将有序数组转换为二叉搜索树-力扣108" class="headerlink" title="题目37：将有序数组转换为二叉搜索树(力扣108)"></a><font color="red">题目37：将有序数组转换为二叉搜索树(力扣108)</font></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p>示例 1：</p><p>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p><p>示例 2：</p><p>输入：nums &#x3D; [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 按 严格递增 顺序排列</p><h4 id="思路-78"><a href="#思路-78" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, left, mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目38：把二叉搜索树转换为累加树-力扣538"><a href="#题目38：把二叉搜索树转换为累加树-力扣538" class="headerlink" title="题目38：把二叉搜索树转换为累加树(力扣538)"></a><font color="red">题目38：把二叉搜索树转换为累加树(力扣538)</font></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">1038</a> 相同</p><p>示例 1：</p><p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>示例 2：</p><p>输入：root &#x3D; [0,null,1]<br>输出：[1,null,1]</p><p>示例 3：</p><p>输入：root &#x3D; [1,0,2]<br>输出：[3,3,2]</p><p>示例 4：</p><p>输入：root &#x3D; [3,2,4,1]<br>输出：[7,9,4,10]</p><p>提示：</p><p>树中的节点数介于 0 和 10^4 之间。<br>每个节点的值介于 -10^4 和 10^4 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p><h4 id="思路-79"><a href="#思路-79" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convertBST1(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按右中左顺序遍历，累加即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertBST1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST1(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST1(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h3 id="题目1：组合-力扣77"><a href="#题目1：组合-力扣77" class="headerlink" title="题目1：组合(力扣77)"></a><font color="red">题目1：组合(力扣77)</font></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><p>示例 1：</p><p>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><p>示例 2：</p><p>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 20<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><h4 id="思路-80"><a href="#思路-80" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTrack(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化（剪枝）</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            1.已经选择的元素个数：ret.size();</span></span><br><span class="line"><span class="comment">            2.还需要的元素个数为: k - ret.size();</span></span><br><span class="line"><span class="comment">            3.列表中可选元素（n-i） &gt;= 还需要的元素个数（k - ret.size()）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            为什么需要+1？？（限制最大搜索起点）</span></span><br><span class="line"><span class="comment">                举个例子，n = 4，k = 3， 目前已经选取的元素为0（ret.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。即+1后，【2，3，,4】这个组合都是可以成立的</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt;= n - (k-ret.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            backTrack(n,k,i+<span class="number">1</span>);</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：组合-力扣216"><a href="#题目2：组合-力扣216" class="headerlink" title="题目2：组合|||(力扣216)"></a><font color="red">题目2：组合|||(力扣216)</font></h3><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>示例 1:</p><p>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。</p><p>示例 2:</p><p>输入: k &#x3D; 3, n &#x3D; 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>没有其他符合的组合了。</p><p>示例 3:</p><p>输入: k &#x3D; 4, n &#x3D; 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 &#x3D; 10，因为10 &gt; 1，没有有效的组合。</p><p>提示:</p><p>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60</p><h4 id="思路-81"><a href="#思路-81" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backTrack(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == n &amp;&amp; ret.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">            ret.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTrack(k,n,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            ret.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">backTracking(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line"><span class="comment">// 减枝</span></span><br><span class="line"><span class="keyword">if</span> (sum &gt; targetSum) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == targetSum) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减枝 9 - (k - path.size()) + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">path.add(i);</span><br><span class="line">sum += i;</span><br><span class="line">backTracking(targetSum, k, i + <span class="number">1</span>, sum);</span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line">path.removeLast();</span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line">sum -= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：电话号码的字母组合-力扣17"><a href="#题目3：电话号码的字母组合-力扣17" class="headerlink" title="题目3：电话号码的字母组合(力扣17)"></a><font color="red">题目3：电话号码的字母组合(力扣17)</font></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]</p><p>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h4 id="思路-82"><a href="#思路-82" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目4：组合总和-力扣39"><a href="#题目4：组合总和-力扣39" class="headerlink" title="题目4：组合总和(力扣39)"></a><font color="red">题目4：组合总和(力扣39)</font></h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><p>示例 2：</p><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：</p><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><p>提示：</p><p>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>2 &lt;&#x3D; candidates[i] &lt;&#x3D; 40<br>candidates 的所有元素 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 40</p><h4 id="思路-83"><a href="#思路-83" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要先进行排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ret));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝操作：若 sum + candidates[i] &gt; target, 则不进入循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            ret.add(candidates[i]);</span><br><span class="line">            backtrack(i, candidates, target);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            ret.remove(ret.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc-JMM</title>
      <link href="/2023/03/28/juc/juc-h/"/>
      <url>/2023/03/28/juc/juc-h/</url>
      
        <content type="html"><![CDATA[<h1 id="juc高级"><a href="#juc高级" class="headerlink" title="juc高级"></a>juc高级</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>规定了线程和内存之间的一些关系</li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><p>主内存和工作内存：</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li><li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-内存交互.png" style="zoom: 67%;"><ul><li>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</li><li>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</li><li>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</li><li>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</li><li>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</li><li>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</li><li>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//添加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BE%8B%E5%AD%90.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响 </p><p>定义原子操作的使用规则：</p><ol><li>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</li><li>不允许一个线程丢弃 assign 操作，必须同步回主存</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li><li>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li><li>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li><li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li></ul><p>补充知识：</p><ul><li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li><li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li><li>振荡周期指周期性信号作周期性重复变化的时间间隔</li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-CPU缓存结构.png" style="zoom: 50%;"><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-内存伪共享.png" style="zoom: 67%;"><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></li><li>内存地址格式：[高位组标记] [低位索引] [偏移量]</li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-缓存一致性.png" style="zoom:80%;"><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p><p>当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p></li><li><p>E：独享的（Exclusive）</p><p>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p></li><li><p>I：无效的（Invalid）</p><p>该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li><li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>保证有序性（禁止指令重排）</li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li><li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</li></ul><hr><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySort</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>;<span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//语句2  谁先执行效果一样</span></span><br><span class="line">x = x + <span class="number">5</span>;<span class="comment">//语句3</span></span><br><span class="line">y = x * x;<span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</p><p>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</p></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况一：线程 1 先执行，ready &#x3D; false，结果为 r.r1 &#x3D; 1</p><p>情况二：线程 2 先执行 num &#x3D; 2，但还没执行 ready &#x3D; true，线程 1 执行，结果为 r.r1 &#x3D; 1</p><p>情况三：线程 2 先执行 ready &#x3D; true，线程 1 执行，进入 if 分支结果为 r.r1 &#x3D; 4</p><p>情况四：线程 2 执行 ready &#x3D; true，切换到线程 1，进入 if 分支为 r.r1 &#x3D; 0，再切回线程 2 执行 num &#x3D; 2，发生指令重排</p></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><p>内存屏障有三个作用：</p><ul><li>确保对内存的读-改-写操作原子执行</li><li>阻止屏障两侧的指令重排序</li><li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li></ul><hr><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;"></li><li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p>保证<strong>有序性</strong>：</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i++&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i--&#125;);</span><br></pre></td></tr></table></figure><p>i++ 反编译后的指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1<span class="comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span></span><br><span class="line"><span class="number">1</span>: istore_1<span class="comment">// 将操作数栈顶数据弹出，存入局部变量表的 slot 1</span></span><br><span class="line"><span class="number">2</span>: iinc<span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;"></li></ul><hr><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li><li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li><li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2，这里的判断不是线程安全的</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li>INSTANCE 要重新赋值</li><li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li></ul><p>实现特点： </p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><ul><li>17 表示创建对象，将对象引用入栈 </li><li>20 表示复制一份对象引用，引用地址</li><li>21 表示利用一个对象引用，调用构造方法初始化对象</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonDemo</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong>  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//线程 start 前对变量的写，对该线程开始后对该变量的读可见</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;System.out.println(x);&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                    System.out.println(thread.getName() + <span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;被打断，退出睡眠&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitor.interrupt();<span class="comment">// 让线程尽快退出Timed Waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">    tpt.start();</span><br><span class="line">    Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">    tpt.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</li><li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    doInit();</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：<br><img src="/../../images/juc/2023-03-29-15-23-21.png"></p><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li><li>CAS 是基于乐观锁的思想</li></ul><p>CAS 缺点：</p><ul><li>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</li><li>只能保证一个共享变量的原子操作<ul><li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li></ul></li><li>引出来 ABA 问题</li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li><li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值 （i++,返回i后在加1）</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值(++i)</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回<br>实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁  + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li>当旧的预期值 A &#x3D;&#x3D; 内存值 V   此时可以修改，将 V 改为 B</li><li>当旧的预期值 A !&#x3D;  内存值 V   此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">//调用本地方法   --&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field var1)</span>;</span><br></pre></td></tr></table></figure></li><li><p>unsafe 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5: 用 var1 和 var2 找到的内存中的真实值</span></span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value</span><br></pre></td></tr></table></figure><p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();<span class="comment">//当前值，cas的期望值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//期望值更新到该值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口：可以自定义操作逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>compareAndSet：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * expect:期望的值</span></span><br><span class="line"><span class="comment">    * update: 更新的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li><li><code>public final void set(V newValue)</code>：将值设置为 newValue </li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">33</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;Student&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置主内存共享变量为s1</span></span><br><span class="line">        atomicReference.set(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">44</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   ithe index</span></span><br><span class="line"><span class="comment">* expect the expected value</span></span><br><span class="line"><span class="comment">* update the new value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li><li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span> AtomicIntegerFieldUpdater</span><br><span class="line">            .newUpdater(UpdateDemo.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">UpdateDemo</span> <span class="variable">updateDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateDemo</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(updateDemo, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(updateDemo.field);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator </p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li><li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x) </p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul></li></ul><hr><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li><li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li><li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><hr><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Striped64.Cell</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB1.png"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB2.png"></p><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前计算机CPU数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors()</span><br><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>工作流程：</p><ul><li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p></li><li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p></li><li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p></li><li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</p></li></ul><p>方法分析：</p><ul><li><p>LongAdder#add：累加方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值</span></span><br><span class="line">    <span class="comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位</span></span><br><span class="line">    <span class="comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 为 true 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组</span></span><br><span class="line">        <span class="comment">//  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加</span></span><br><span class="line">        <span class="comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性</span></span><br><span class="line">        <span class="comment">//   true 说明当前线程对应下标的 cell 为空，需要创建 cell</span></span><br><span class="line">        <span class="comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】</span></span><br><span class="line">        <span class="comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        <span class="comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Striped64#longAccumulate：cell 数组创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x  null false | true</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe，获取 hash 值</span></span><br><span class="line">        ThreadLocalRandom.current(); </span><br><span class="line">        h = getProbe();</span><br><span class="line">        <span class="comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争</span></span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值</span></span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断 cellsBusy 是否被锁</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;   </span><br><span class="line">                    <span class="comment">// 创建 cell, 初始累加值为 x</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);  </span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="comment">// 创建成功标记，进入【创建 cell 逻辑】</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 把当前 cells 数组赋值给 rs，并且不为 null</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                <span class="comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失</span></span><br><span class="line">                                <span class="comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响</span></span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 把新创建的 cell 填充至当前位置</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;<span class="comment">// 表示创建完成</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;<span class="comment">// 解锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)<span class="comment">// true 表示创建完成，可以推出循环了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>; <span class="comment">// 扩容意向改为false，【表示不能扩容了】</span></span><br><span class="line">            <span class="comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.6: 【扩容逻辑】，进行加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 线程安全的检查，防止期间被其他线程扩容了</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;     </span><br><span class="line">                        <span class="comment">// 扩容为以前的 2 倍</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 遍历移动值</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        <span class="comment">// 把扩容后的引用给 cells</span></span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;<span class="comment">// 解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;<span class="comment">// 扩容意向改为 false，表示不扩容了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null</span></span><br><span class="line">        <span class="comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁</span></span><br><span class="line">        <span class="comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 初始化标志，开始 【初始化 cells 数组】</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">               <span class="comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据</span></span><br><span class="line">                <span class="comment">// 因为这里是【线程安全的，重新检查，经典 DCL】</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];<span class="comment">// 初始化数组大小为2</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);<span class="comment">// 填充线程对应的cell</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;<span class="comment">// 初始化成功，标记置为 true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;<span class="comment">// 解锁啊</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 初始化成功直接跳出自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sum：获取最终结果通过 sum 整合，<strong>保证最终一致性，不保证强一致性</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li><p>构造方法：</p><ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li><p>常用API：</p><ul><li><code> public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</li><li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li><li><code>public V getReference()</code>：返回引用的值</li><li><code>public int getStamp()</code>：返回当前版本号</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">startStamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        stamp = atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, startStamp, startStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(atomicReference.getReference());<span class="comment">//100</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyAtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.compareAndSwap(<span class="number">20</span>)) &#123;</span><br><span class="line">        System.out.println(atomicInteger.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> VALUE_OFFSET;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值</span></span><br><span class="line">            VALUE_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                   MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAtomicInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> update;</span><br><span class="line">            <span class="comment">//当前对象  内存偏移量    期望值 更新值</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CAS成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：<br><img src="/../../images/juc/2023-03-30-21-01-33.png"></p><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span><span class="comment">// 将值直接放入栈中</span></span><br><span class="line"><span class="number">7</span>: putfield #<span class="number">2</span> <span class="comment">// Field a:I</span></span><br><span class="line">&lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量</p><ul><li><strong>复制一份放入栈中</strong>直接访问，效率高</li><li>大于 short 最大值会将其复制到类的常量池，访问时从常量池获取</li></ul><hr><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li><li><p>无写入方法（set）确保外部不能对内部属性进行修改</p></li><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p></li></ul><hr><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><hr><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li><p>线程并发：应用在多线程并发的场景下</p></li><li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p></li><li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p></li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><hr><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程绑定的变量</span></span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="comment">// 变量content绑定到当前线程</span></span><br><span class="line">        tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置数据</span></span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul><p>ThreadLocal 方案有两个突出的优势： </p><ol><li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</li><li>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadLocal对象，将connection绑定在当前线程中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    <span class="comment">// c3p0 数据库连接池对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//取出当前线程绑定的connection对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有，则从连接池中取出</span></span><br><span class="line">            conn = ds.getConnection();</span><br><span class="line">            <span class="comment">//再将connection对象绑定到当前线程中，非常重要的操作</span></span><br><span class="line">            tl.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().parse(dateStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%89%8D.png"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></li><li>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</li><li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%90%8E.png"></p><p>JDK8 前后对比：</p><ul><li>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</li><li>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></li></ul><hr><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li><p>计算 ThreadLocal 对象的哈希值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode()</span><br></pre></td></tr></table></figure><p>使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p></li><li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>()</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li><p>initialValue()：返回该线程局部变量的初始值</p><ul><li>延迟调用的方法，在执行 get 方法时才执行</li><li>该方法缺省（默认）实现直接返回一个 null</li><li>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希值自增一个 HASH_INCREMENT 数值</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 调用 threadLocalMap.set 方法进行重写或者添加</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap </span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对 e 进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span></span><br><span class="line">    <span class="comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回线程与当前 threadLocal 关联的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化当前 map 内部散列表数组的初始长度 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放数据的table，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure><p>存储结构 Entry：</p><ul><li>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</li><li>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">// this.referent = referent = key;</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table，创建一个长度为16的Entry数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 【寻址算法】计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建 entry 对象，存放到指定位置的 slot 中</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 数据总量是 1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p><ul><li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p><p>假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[]  table 看成一个<strong>环形数组</strong></p></li><li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p></li><li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取当前元素 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】</span></span><br><span class="line">            <span class="comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 数量 + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取【环形数组】的下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 索引越界后从 0 开始继续获取</span></span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入指定的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"><span class="comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值</span></span><br><span class="line">    <span class="comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 条件成立说明是【替换逻辑】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致</span></span><br><span class="line">            <span class="comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry</span></span><br><span class="line">            <span class="comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            <span class="comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】</span></span><br><span class="line">    <span class="comment">// 删除原有的数据引用，防止内存泄露</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-replaceStaleEntry%E6%B5%81%E7%A8%8B.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 形成一个环绕式的访问，头索引越界后置为尾索引</span></span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 访问散列表中指定指定位置的 slot </span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 进行线性探测</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线性探测寻址</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历，碰到 slot == null 的情况，搜索结束</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取当前 slot 中 entry 对象的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 条件成立说明找到了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">             <span class="comment">// 过期数据，【探测式过期数据回收】</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 更新 index 继续向后走</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取下一个槽位中的 entry</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明当前区段没有找到相应数据</span></span><br><span class="line">    <span class="comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 清楚当前散列表内的【所有】过期的数据</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 【遍历所有的槽位，清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="comment">// 新数组的长度是老数组的二倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="comment">// 统计新table中的entry数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历老表，进行【数据迁移】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="comment">// 访问老表的指定位置的 entry</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">// 过期数据</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非过期数据，在新表中进行哈希寻址</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 【线程探测】</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                <span class="comment">// 将数据存放到新表合适的 slot 中</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    <span class="comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()：删除 Entry</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 找到了对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 设置 key 为 null</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 探测式清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表和数组长度</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 数量-1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 当前 entry 是过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// help gc</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前 entry 不是过期数据的逻辑，【rehash】</span></span><br><span class="line">            <span class="comment">// 重新计算当前 entry 对应的 index</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 当前位置置空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                <span class="comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal探测式清理1.png" style="zoom:67%;"><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal探测式清理2.png" style="zoom:67%;"></li><li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示启发式清理工作是否清除了过期数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前 map 的散列表引用</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取下一个索引，因为探测式返回的 slot 为 null</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 条件成立说明是过期的数据，key 被 gc 了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【发现过期数据重置 n 为数组的长度】</span></span><br><span class="line">            n = len;</span><br><span class="line">            <span class="comment">// 表示清理过过期数据</span></span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设 table 长度为 16</span></span><br><span class="line">        <span class="comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0</span></span><br><span class="line">        <span class="comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回清除标记</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://space.bilibili.com/457326371/">参考视频</a></p><hr><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal内存泄漏强引用.png" style="zoom:67%;"></li><li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal内存泄漏弱引用.png" style="zoom:67%;"></li><li><p>两个主要原因：</p><ul><li>没有手动删除这个 Entry</li><li>CurrentThread 依然运行</li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><hr><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：创建子线程的线程是父线程，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想<strong>实现线程间局部变量传递</strong>可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;父线程设置的值&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子线程输出：父线程设置的值</span></span><br></pre></td></tr></table></figure><hr><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  // 该参数默认是 <span class="literal">true</span></span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享</span></span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取父线程的哈希表</span></span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line"><span class="comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 线性探测</span></span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/feichitianxia/article/details/110495764">参考文章</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc_多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/2023/03/27/juc/juc/"/>
      <url>/2023/03/27/juc/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC基础"><a href="#JUC基础" class="headerlink" title="JUC基础"></a>JUC基础</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源。</li><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的</li><li>并发性：任何进程都可以同其他进行一起并发执行</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位</li><li>结构性：进程由程序，数据和进程控制块三部分组成</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。</li><li>线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,(新建)</span><br><span class="line">    RUNNABLE,（准备就绪）</span><br><span class="line">    BLOCKED,（阻塞）</span><br><span class="line">    WAITING,（不见不散）</span><br><span class="line">    TIMED_WAITING,（过时不候）</span><br><span class="line">    TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程几个状态的介绍：</p><ul><li>New：表示刚刚创建的线程，这种线程还没有开始执行</li><li>RUNNABLE：运行状态，线程的start()方法调用后，线程会处于这种状态</li><li>BLOCKED：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE）</li><li>WAITING：等待状态。和TIME_WAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIME_WAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。</li><li>TERMINATED：表示结束状态，线程执行完毕之后进入结束状态。<br><font color="red">注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态</font></li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行(多核执行多任务)</li><li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行（单核执行多任务）</li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li><li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li><li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong><ul><li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li><li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li></ul></li><li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：<ul><li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li></ul></li></ul><p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p><strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>Monitor(监视器)，也就是我们平时所说的锁.后面介绍。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</span></span><br><span class="line"><span class="comment">// JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="comment">// Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</span></span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV16J411h7Rd">参考视频</a></p><h1 id="JUC进阶"><a href="#JUC进阶" class="headerlink" title="JUC进阶"></a>JUC进阶</h1><h2 id="创建线程-3种-线程池创建不列举"><a href="#创建线程-3种-线程池创建不列举" class="headerlink" title="创建线程(3种,线程池创建不列举)"></a>创建线程(3种,线程池创建不列举)</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li><li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li></ul><p>Thread 构造器：</p><ul><li><code>public Thread()</code></li><li><code>public Thread(String name)</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程写法1：可加参数指定线程名字</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//写法2：</span></span><br><span class="line">        <span class="comment">/* Thread t = new Thread()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run()&#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li>优点：编码简单</li><li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li></ul><hr><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><code>public Thread(Runnable target)</code></li><li><code>public Thread(Runnable target, String name)</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//写法1：</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//写法2：</span></span><br><span class="line">        <span class="comment">/* Runnable target = new Runnable()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk8后用lambda简化写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//对于只含有一个方法的接口，底层使用了注解@FunctionalInterface</span></span><br><span class="line">        <span class="comment">//因此可以用lambda简化写法</span></span><br><span class="line">        <span class="comment">//原来写法：</span></span><br><span class="line">        <span class="comment">/* Runnable target = new Runnable()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                //要执行的任务</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="comment">//idea简化只需要鼠标指到Runnable()那里，alt+enter,提示lambda</span></span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        <span class="comment">//1.只有一个方法的话，去掉函数，只保留参数部分与方法体</span></span><br><span class="line">        <span class="comment">//2.在参数部分与方法体之间用-&gt;</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            <span class="comment">//要执行的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><hr><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>实现 Callable 接口：</p><ol><li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li><li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li><li>把未来任务对象包装成线程对象</li><li>调用线程的 start() 方法启动线程</li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li><li>线程池部分详解了 FutureTask 的源码</li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get() 线程会阻塞等待任务执行完成</li><li>run() 执行完后会把结果设置到 FutureTask  的一个成员变量，get() 线程可以获取到该变量的值</li></ul><p>优缺点：</p><ul><li>优点：同 Runnable，并且能得到线程执行的结果</li><li>缺点：编码复杂</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get(); <span class="comment">// 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匿名内部类写法</span></span><br><span class="line">    <span class="comment">/* public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new Callable&lt;String&gt;&#123;</span></span><br><span class="line"><span class="comment">            @Override//重写线程任务类方法</span></span><br><span class="line"><span class="comment">            public String call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">                return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        //进一步简写</span></span><br><span class="line"><span class="comment">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        Thread t = new Thread(task);</span></span><br><span class="line"><span class="comment">        t.start();</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            String s = task.get(); // 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line"><span class="comment">            System.out.println(s);</span></span><br><span class="line"><span class="comment">        &#125;  catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span><span class="comment">//重写线程任务类方法</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th><th>注意</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td><td>start方法只是让线程进入就绪，里面代码不一定立刻运行(cpu的时间片还没分给它)。每个线程对象的start方法只能调用一次，多次会IllegalThreadStateException</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td><td>如果在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为。</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td><td></td></tr><tr><td>public void getName()</td><td>获取当前线程的名字<br>线程存在默认名称：子线程是 Thread-索引，主线程是 main</td><td></td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td><td></td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行<br><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td><td>从Running进入到Timed Waiting状态(阻塞)</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td><td>主要是为了测试和调试，从Running进到Runnable就绪状态，区别于sleep()</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td><td></td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10(大)</td><td></td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td><td>如果被打断线程正在sleep,wait,join会导致被打断的线程抛出InterruptedException,并清除标记；如果打断的正在运行的线程，则会设置打断标记；park的线程被打断也会设置打断标记</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td><td></td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td><td></td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td><td></td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td><td></td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td><td></td></tr><tr><td>public Thread.State getState()</td><td>返回该线程的状态</td><td></td></tr></tbody></table><hr><h3 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h3><p><code>run：</code>称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p><code>start：</code>使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li><li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li></ul><hr><h3 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h3><p><code>sleep：</code></p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li><li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p><code>yield：</code></p><ul><li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li><li>具体的实现依赖于操作系统的任务调度器</li><li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li></ul><hr><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>public final void join()</code>：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul><li>需要外部共享变量，不符合面向对象封装的思想</li><li>必须等待线程结束，不能配合线程池使用</li></ul></li><li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul><li>main 线程接收结果</li><li>get 方法是让调用线程同步等待</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//不等待线程执行结束，输出的10</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><h4 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h4><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li><p>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="comment">// 打断状态: &#123;&#125;false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打断正常运行的线程：不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="comment">//打断状态: &#123;&#125;true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.park();<span class="comment">//失效，不会阻塞</span></span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);<span class="comment">//和上一个unpark同时执行</span></span><br></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h4 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h4><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li><li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul><p>两阶段终止模式图示：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-两阶段终止模式.png" style="zoom: 67%;"><p>解释说明：在一个正常运行的线程中，当没有被打断，此线程会睡眠2秒，此时若没有异常（sleep被打断会抛出异常），则继续监控该线程。但在正常运行的线程中被打断时，抛出异常，设置打断标记后该线程继续执行，到了判断该标志的时候，处理后事(如释放资源)，退出循环线程。</p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">        tpt.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="comment">//isInterrupted不会清除打断标志,interrupt会</span></span><br><span class="line">                    <span class="keyword">if</span> (thread.isInterrupted()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控记录&quot;</span>);<span class="comment">// 在此被打断不会异常</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">// 在睡眠期间被打断，进入异常处理的逻辑</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 重新设置打断标记，打断 sleep 会清除打断状态</span></span><br><span class="line">                        <span class="comment">//清除后为false</span></span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程 </p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程前设置该线程为守护线程</span></span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><hr><h3 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h3><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="/../../images/juc/2023-03-27-14-42-00.png" alt="1"></p><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park 等方法</li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。Context Switch频繁发生会影响性能。</p><p>JVM 规范并没有限定线程模型，以 HotSpot 为例：</p><ul><li>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</li><li><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程。线程debug(鼠标移动到断点处，ctrl+f8,选择Thread)</p><hr><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</li><li>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</li><li>缺点：无法主动为某个线程多分配时间</li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p>说明：并不能通过优先级来判断线程执行的先后顺序</p><hr><h3 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h3><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</li><li>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li>执行过程：用于维护执行现场，保护、恢复上下文状态</li><li>调度器：负责编排所有要执行的代码顺序</li></ul><hr><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%BA%BF%E7%A8%8B6%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li>竞争锁成功，t 线程从 WAITING → RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING → BLOCKED</li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>)&#123;    <span class="comment">//NEW,该线程创建并不执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>)&#123;      <span class="comment">//RUNNABLE,一直运行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>)&#123;     <span class="comment">//TERMINATED，正常结束</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>)&#123;     <span class="comment">//TIMED_WAITING，有时间的等待</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.class)&#123;    <span class="comment">//此时没有线程跟t4竞争锁</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t4.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>)&#123;         <span class="comment">//WAITING，等待t2线程，但t2一直运行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            t2.join();  <span class="comment">//等待t2</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t5.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>)&#123;     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.class)&#123;    <span class="comment">//BLOCKED，跟t4竞争锁失败</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">t6.start();</span><br></pre></td></tr></table></figure><hr><h2 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h2><p>Windows：</p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><p>Linux：</p><ul><li>ps -ef 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</PID></li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></li></ul><p>Java：</p><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</PID></li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h1 id="JUC高级-并发"><a href="#JUC高级-并发" class="headerlink" title="JUC高级-并发"></a>JUC高级-并发</h1><h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>性能：</p><ul><li>线程安全，性能差</li><li>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li></ul><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块-代码块"><a href="#同步块-代码块" class="headerlink" title="同步块(代码块)"></a>同步块(代码块)</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li>锁对象建议使用共享资源</li><li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li><li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li></ul><p>同步代码块格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line"><span class="comment">// 访问共享资源的核心代码(临界区)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;    <span class="comment">//保证临界区代码块的原子性</span></span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的线程安全类有String、Integer、StringBuffer、Random、Vector、HashTable、java.util.concurrent包下的类,因为多个线程调用它们同一个实例的某个方法时，都是线程安全的，加了synchronized。但方法不能组合.如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合使用无法保证线程安全</span></span><br><span class="line"><span class="type">HashTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>)== <span class="literal">null</span>)&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>,valur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程(操作系统中)</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁。说明：<code>对象头包括Mark Word 和 Klass Word</code></p><ul><li><p>Mark Word 结构：最后两位是<strong>锁标志位</strong>,上锁从01变为10,其他位(hashcode等)都不要，变成指向monitor的指针</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"></p></li><li><p>64 位虚拟机 Mark Word：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"></p></li></ul><h6 id="原理之synchronized"><a href="#原理之synchronized" class="headerlink" title="原理之synchronized"></a>原理之synchronized</h6><p>工作流程：</p><ul><li>开始时 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor工作原理1.png" style="zoom:67%;"></li><li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li><li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li><li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><hr><h6 id="原理之synchronized进阶-字节码-不懂"><a href="#原理之synchronized进阶-字节码-不懂" class="headerlink" title="原理之synchronized进阶(字节码)不懂"></a>原理之synchronized进阶(字节码)<strong>不懂</strong></h6><p><img src="/../../images/juc/2023-03-27-22-52-02.png"><br><img src="/../../images/juc/2023-03-27-22-53-51.png"><br>说明：</p><ul><li>通过异常 try-catch 机制，确保一定会被解锁</li><li>方法级别的 synchronized 不会在字节码指令中有所体现</li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                        锁重入(需要cas操作)</span><br><span class="line">       默认延时开启    ============</span><br><span class="line">          /\          ||          ||</span><br><span class="line">          ||          ||          \/</span><br><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br><span class="line">                           ||      /\</span><br><span class="line">                           \/      ||</span><br><span class="line">                          锁膨胀===||</span><br></pre></td></tr></table></figure><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，Mark Word后三位标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord结构64位.png" style="zoom: 67%;"><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li><li>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈(yu)值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS(比较并交换，乐观锁) 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png"></p></li><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p></li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li><li>自旋失败的线程会进入阻塞状态</li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋成功.png" style="zoom: 80%;"></p></li><li><p>自旋失败的情况：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋失败.png" style="zoom:80%;"></li></ul><p>自旋锁说明：</p><ul><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型装的是Thread，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始自旋，期望值为null，更新值是当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; 正在自旋&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; 自旋成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程使用完锁把引用变为null</span></span><br><span class="line">atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; invoke unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//占有锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sleepRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li><li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li><li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li><li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程1：占用资源1 ，请求资源2</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//休息两秒，防止线程1直接运行完成。</span></span><br><span class="line">                <span class="comment">//2秒内线程2肯定可以锁住资源2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resources2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1已经占用了资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程2：占用资源2 ，请求资源1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resources1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2已经占用了资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting formonitor entry [0x000000001f54f000]</span></span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略    </span></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000]</span></span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略</span></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line">    </span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715</span><br></pre></td></tr></table></figure></li><li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack <pid>的输出来看各个线程栈</pid></p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一count:&quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait-notify"></a>wait-notify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></pre></td></tr></table></figure><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li><li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li><li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li></ul><p>相同：状态都是TIMED_WAITING</p><p>底层原理：</p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//有没有烟</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;<span class="comment">//while防止虚假唤醒</span></span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//log.debug(&quot;烟到了噢！&quot;);</span></span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park-unpark"></a>park-unpark</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);<span class="comment">//1</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">// Thread.sleep(3000)</span></span><br><span class="line">        <span class="comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;resume...&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark...&quot;</span>);<span class="comment">//3</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p>原理：类似生产者消费者</p><ul><li>先 park：<ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ol></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%861.png"></p><ul><li><p>先 unpark：</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li></ol><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%862.png"></p></li></ul><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li></ul></li></ul><p>局部变量：</p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">// 线程安全</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">// 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</span></span><br></pre></td></tr></table></figure></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectV2</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//模拟下载</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        object.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> object.get(<span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="comment">//timeout(参数：millis) :最大等待时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="comment">//经历时间超过最大等待时间退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Postman</span>(id, id + <span class="string">&quot;号快递到了&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于解耦的邮箱类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mailboxes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生唯一的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象并从map中移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有ids</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//标识，Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//添加get set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span><span class="params">(id)</span>&#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2  1 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line">            <span class="comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">day2_14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：<br><img src="/../../images/juc/2023-03-29-13-00-53.png"></p><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断  防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraditionalProducerConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">        <span class="comment">// t1线程，生产</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t2线程，消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列类，Java间线程之间通信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;:队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列的头部获取消息返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;：已消费消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">//检查队列是否满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName()+<span class="string">&quot;:队列为已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;:已生产消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"><span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">consumer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">producer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">    producer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待消费...&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2023/03/28/juc/juc-h/" target="_block">了解更多juc知识?</a></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc_多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例&amp;代理设计模式</title>
      <link href="/2023/03/26/design-pattern/singleton-design-pattern/"/>
      <url>/2023/03/26/design-pattern/singleton-design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><hr><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p><ul><li><p>静态变量的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决序列化问题</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p></li><li><p>防止反序列化破坏单例的方式：</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private&#x2F;protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p></li><li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p></li><li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p></li></ul></li><li><p>静态代码块的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.INSTANCE.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Singleton&gt; &#123; <span class="comment">// Enum实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li><p>线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><hr><h3 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h3><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p><ul><li><p>Singleton</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化接口</span></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><ul><li><p>反射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 反射破解单例模式需要添加的代码</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>Runtime 类就是使用的单例设计模式中的饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> currentRuntime;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Runtime</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代售点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><hr><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"><span class="comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用 Proxy 获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//必须时代理ji</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);<span class="comment">//InvocationHandler对象传递给父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span>&#123;</span><br><span class="line">    <span class="comment">// InvocationHandler 为空则抛出异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一份 interfaces</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置可访问的权限</span></span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 的静态内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类型的名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：Proxy.newInstance 时传递的</span></span><br><span class="line">    <span class="comment">//参数二：Proxy.newInstance 时传递的接口集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 遍历接口集合</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载接口类到 JVM</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证接口 interfaces 集合中没有重复的接口</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">        <span class="comment">// 【生成的代理类访问修饰符 public final】 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span></span><br><span class="line">        <span class="comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 获取访问修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取当前接口的全限定名 包名.类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="comment">// 获取包名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取唯一的编号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// 包名+ $proxy + 数字，比如 $proxy1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代理工厂类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//因为返回值为void</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><hr><h3 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h3><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> design-pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdp </tag>
            
            <tag> Singleton Pattern </tag>
            
            <tag> Proxy Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml基础介绍</title>
      <link href="/2023/03/26/xml-basic/xml-basic/"/>
      <url>/2023/03/26/xml-basic/xml-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XML介绍：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li><li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li><li>XML 标签没有被预定义，需要自行定义标签</li><li>XML 被设计为具有自我描述性，易于阅读</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的区别</strong>：</p><ul><li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li><li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li><li>HTML 旨在显示信息，而 XML 旨在传输信息</li></ul><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>person.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;110&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="comment">&lt;!--年龄--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--姓名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>/&gt;</span><span class="comment">&lt;!--性别--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p><ul><li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p><ul><li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li><li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li><li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes&#x2F;no</li></ul></li><li><p><strong>元素</strong>        </p><ul><li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li><li>格式 2：<code>&lt;person/&gt;</code></li><li>普通元素的结构由开始标签、元素体、结束标签组成</li><li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;&#x2F;&gt;</li></ul></li><li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p><ul><li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li><li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li><li>必须存在一个根标签，有且只能有一个</li></ul></li><li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p><ul><li>属性是元素的一部分，它必须出现在元素的开始标签中</li><li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li><li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li><li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li></ul></li><li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p></li><li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p><table><thead><tr><th align="center">字符</th><th align="center">预定义的转义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center"><code> &amp;gt;</code></td><td align="center">大于</td></tr><tr><td align="center">“</td><td align="center"><code> &amp;quot;</code></td><td align="center">双引号</td></tr><tr><td align="center">‘</td><td align="center"><code> &amp;apos;</code></td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center"><code> &amp;amp;</code></td><td align="center">和号</td></tr></tbody></table></li><li><p><strong>字符区</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">文本数据</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><ul><li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li></ul></li><li><p>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束；</p><ul><li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p></li><li><p>规则：</p><ul><li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li><li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;../css/xml.css&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.属性信息：id , desc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>32<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span></span><br><span class="line">        select * from student where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age <span class="symbol">&amp;gt;</span> 10;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符</span></span><br><span class="line"><span class="comment">        或者也可以选择使用字符数据区，里面的内容可以随便了！</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql2</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p><p>DTD 规则：</p><ul><li><p>约束元素的嵌套层级</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;</span><br></pre></td></tr></table></figure></li><li><p>约束元素体里面的数据</p></li><li><p>语法</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 标签名字 标签类型&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">* 判断元素</span><br><span class="line">           简单元素：没有子元素。</span><br><span class="line">           复杂元素：有子元素的元素；</span><br><span class="line">   </span><br><span class="line">   * 标签类型</span><br><span class="line">   </span><br><span class="line">  | 标签类型 | 代码写法  | 说明                 |</span><br><span class="line">  | -------- | --------- | -------------------- |</span><br><span class="line">  | PCDATA   | (#PCDATA) | 被解释的字符串数据   |</span><br><span class="line">  | EMPTY    | EMPTY     | 即空元素，例如\&lt;hr/&gt; |</span><br><span class="line">  | ANY      | ANY       | 即任意类型           |</span><br><span class="line">  </span><br><span class="line">   * 代码</span><br><span class="line">  </span><br><span class="line">     ```dtd</span><br><span class="line">  &lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;</span><br><span class="line">     &lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;</span><br><span class="line">     &lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;</span><br><span class="line">     &lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br></pre></td></tr></table></figure><ul><li><p>数量词</p><table><thead><tr><th>数量词符号</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>表示元素出现一次</td></tr><tr><td>*</td><td>表示元素可以出现0到多个</td></tr><tr><td>+</td><td>表示元素可以出现至少1个</td></tr><tr><td>?</td><td>表示元素可以是0或1个</td></tr><tr><td>,</td><td>表示元素需要按照顺序显示</td></tr><tr><td>|</td><td>表示元素需要选择其中的某一个</td></tr></tbody></table></li></ul></li><li><p>属性声明</p><ul><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 标签名称 </span><br><span class="line">属性名称1 属性类型1 属性说明1</span><br><span class="line">属性名称2 属性类型2 属性说明2</span><br><span class="line">…</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性类型</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>CDATA</td><td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td></tr><tr><td>ID</td><td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td></tr><tr><td>ENUMERATED</td><td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td></tr></tbody></table></li><li><p>属性说明</p><table><thead><tr><th>属性说明</th><th>含义</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>代表属性是必须有的</td></tr><tr><td>#IMPLIED</td><td>代表属性可有可无</td></tr><tr><td>#FIXED</td><td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td></tr></tbody></table></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 书   &lt;!--设置&quot;书&quot;元素的的属性列表--&gt;</span><br><span class="line">id ID #REQUIRED&lt;!--&quot;id&quot;属性值为必须有--&gt;</span><br><span class="line">编号 CDATA #IMPLIED   &lt;!--&quot;编号&quot;属性可有可无--&gt;</span><br><span class="line">出版社 (清华|北大) &quot;清华&quot;   &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“123”--&gt;</span><br><span class="line">type CDATA #FIXED &quot;IT&quot;&lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>XSD 定义：</p><ol><li>Schema 语言也可作为 XSD（XML Schema Definition）</li><li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li><li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li><li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li><li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li></ol><p>XSD 规则：</p><ol><li>创建一个文件，这个文件的后缀名为 .xsd</li><li>定义文档声明</li><li>schema 文件的根标签为： <schema></schema></li><li>在 <schema> 中定义属性：<ul><li>xmlns&#x3D;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li><li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>targetNamespace &#x3D; 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li><li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>elementFormDefault&#x3D;”qualified“，表示当前 schema 文件是一个质量良好的文件。</li></ul></schema></li><li>通过 element 定义元素</li><li><strong>判断当前元素是简单元素还是复杂元素</strong></li></ol><p>person.xsd</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;</span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;</span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span>  &lt;!--本文件是质量好的--&gt;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;      &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">        &lt;complexType&gt;             &lt;!--复杂的元素--&gt;</span><br><span class="line">            &lt;sequence&gt;  &lt;!--里面的元素必须按照顺序定义--&gt;</span><br><span class="line">                &lt;element name = <span class="string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p><p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p><p>Dom4J 实现：</p><ul><li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p></li><li><p>SAXReader 常用 API：</p><ul><li><code>public Document read(File file)</code>：Reads a Document from the given File</li><li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li></ul></li><li><p>Java Class 类 API：</p><ul><li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li></ul></li></ul><hr><h3 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h3><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span></span><br><span class="line">        <span class="comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span></span><br><span class="line">        <span class="comment">// 这里的“/”是直接去src类路径下寻找文件。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="string">&quot;/books.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        System.out.println(document);</span><br><span class="line"><span class="comment">//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]</span></span><br><span class="line"><span class="comment">// 4.从document文档树对象中提取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());<span class="comment">//books</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0001&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一本书&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>  JavaWeb开发教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>    张三<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元   <span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元<span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><p>Element 元素的 API:</p><ul><li>String getName()：取元素的名称。</li><li>List<Element> elements()：获取当前元素下的全部子元素（一级）</Element></li><li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</Element></li><li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.获取根元素下的全部子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements = root.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.获取根源下的全部book子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements1 = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements1) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.获取根源下的指定的某个元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(son.getName());</span><br><span class="line">        <span class="comment">// 默认会提取第一个名称一样的子元素对象返回！</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son1</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(son1.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Element 元素的 API：</p><ul><li>List<Attribute> attributes()：获取元素的全部属性对象</Attribute></li><li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li><li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li></ul><p>Attribute 对象的 API：</p><ul><li>String getName()：获取属性名称</li><li>String getValue()：获取属性值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.获取book子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取book元素的全部属性对象</span></span><br><span class="line">        List&lt;Attribute&gt; attributes = bookEle.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName()+<span class="string">&quot;-&gt;&quot;</span>+attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.获取Book元素的某个属性对象</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">descAttr</span> <span class="operator">=</span> bookEle.attribute(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(descAttr.getName()+<span class="string">&quot;-&gt;&quot;</span>+descAttr.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.可以直接获取元素的属性值</span></span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;desc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>Element：</p><ul><li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li><li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li><li>String getText()：直接获取当前元素的文本内容</li><li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.得到第一个子元素book</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.直接拿到当前book元素下的子元素文本值</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;author&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.先获取到子元素对象，再获取该文本值</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookNameEle</span> <span class="operator">=</span> bookEle.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(bookNameEle.getText());</span><br><span class="line">        System.out.println(bookNameEle.getTextTrim());<span class="comment">// 去前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p><p>XPath 常用API：</p><ul><li>List<Node> selectNodes(String var1) : 检索出一批节点集合</Node></li><li>Node selectSingleNode(String var1) : 检索出一个节点返回</li></ul><p>XPath 提供的四种检索数据的写法：</p><ol><li>绝对路径：&#x2F;根元素&#x2F;子元素&#x2F;子元素</li><li>相对路径：.&#x2F;子元素&#x2F;子元素 (.代表了当前元素)</li><li>全文搜索：<ul><li>&#x2F;&#x2F;元素：在全文找这个元素</li><li>&#x2F;&#x2F;元素1&#x2F;元素2：在全文找元素1下面的一级元素 2</li><li>&#x2F;&#x2F;元素1&#x2F;&#x2F;元素2：在全文找元素1下面的全部元素 2</li></ul></li><li>属性查找：<ul><li>&#x2F;&#x2F;@属性名称：在全文检索属性对象</li><li>&#x2F;&#x2F;元素[@属性名称]：在全文检索包含该属性的元素对象</li><li>&#x2F;&#x2F;元素[@属性名称&#x3D;值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contact.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        <span class="comment">//1.使用绝对路径定位全部的name名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            System.out.println(nameNode.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.相对路径。从根元素开始检索，.代表很根元素</span></span><br><span class="line">        List&lt;Node&gt; nameNodes2 = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.1 在全文中检索name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//name&quot;</span>);<span class="comment">//全部的</span></span><br><span class="line">        <span class="comment">//3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="comment">//3.3 在全文中检索所有contact下的直接name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact/name&quot;</span>);<span class="comment">//不包括sql和外面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1 检索全部属性对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//@id&quot;</span>);<span class="comment">//包括sql4</span></span><br><span class="line">        <span class="comment">//4.2 在全文检索包含该属性的元素对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//contact[@id]&quot;</span>);</span><br><span class="line">        <span class="comment">//4.3 在全文检索包含该属性的元素且属性值为该值的元素对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeEle</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//contact[@id=2]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element)nodeEle;</span><br><span class="line">        System.out.println(ele.elementTextTrim(<span class="string">&quot;name&quot;</span>));<span class="comment">//xi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小白<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>bai@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小黑<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hei@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sql4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小虎<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hu@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>外面的名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门</title>
      <link href="/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h1><h2 id="什么是Java语言"><a href="#什么是Java语言" class="headerlink" title="什么是Java语言"></a>什么是Java语言</h2><p>Java语言是美国Sun公司，在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h2 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h2><ul><li>1995年Sun公司发布java1.0版本</li><li>1997年发布java1.1版本</li><li>1998年发布java1.2版本</li><li>2000年发布java1.4版本</li><li>2002年发布java 5 版本</li><li>2006年发布java 6 版本</li><li>2009年oracle甲骨文公司收购sun公司，并于2011年发布java7版本</li><li>2014年发布java8版本</li><li>2017年9月发布java9版本</li><li>2018年3月发布java10版本</li></ul><h1 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制表示，它只包含0，,两个数，逢二进一，1+1&#x3D;10。每一个0或者每一个1，叫做一个bit(比特，位)。</p><ol><li>十进制数据转成二进制数据：使用除以2获取余数的方式(辗转相除法)<br> <img src="/../../images/JavaSE/2022-05-12-21-20-43.png" alt="123"></li><li>二进制数据转成十进制数据<br> 示例：<table><thead><tr><th>二进制数</th><th>十进制</th></tr></thead><tbody><tr><td>1001011</td><td>2^0+ 2^1+ 2^3+ 2^6</td></tr></tbody></table></li></ol><h1 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h1><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>位(bit):一个数字0或者一个数字1，代表一位。<br>字节(Byte):每逢8位是一个字节，这是数据存储的最小单位。<br>1 Byte &#x3D; 8 bit<br>1 KB &#x3D; 1024 Byte<br>1 MB &#x3D; 1024 KB<br>1 GB &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB<br>1 PB &#x3D; 1024 TB<br>1 EB &#x3D; 1024 PB<br>1 ZB &#x3D; 1024 EB<br>1 Mbps(宽带，Mbit&#x2F;s) &#x3D; 1024 KMps &#x3D; 1024&#x2F;8KBps &#x3D; 128KB&#x2F;s</p><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p>以前：MS -DOS(Microsoft Disk Operating System)<br>Windows:命令提示符(cmd)<br>启动：Win+R<br>输入:cmd</p><h2 id="cmd里常用命令"><a href="#cmd里常用命令" class="headerlink" title="cmd里常用命令"></a>cmd里常用命令</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>转换盘符</td><td>盘符名：</td></tr><tr><td>进入文件夹</td><td>cd 文件夹名称</td></tr><tr><td>进入多级文件夹</td><td>cd 文件夹1\文件夹2\文件夹3</td></tr><tr><td>返回上一级</td><td>cd ..</td></tr><tr><td>直接回根路径</td><td>cd \</td></tr><tr><td>查看当前内容</td><td>dir</td></tr><tr><td>清屏</td><td>cls(clear screen)</td></tr><tr><td>退出</td><td>exit</td></tr></tbody></table><h1 id="Java语言开发环境搭建"><a href="#Java语言开发环境搭建" class="headerlink" title="Java语言开发环境搭建"></a>Java语言开发环境搭建</h1><h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><p>java虚拟机，简称jvm,是运行所有java程序的假想计算机，是java程序的运行环境，是java最具有吸引力的特性之一。<br>跨平台：任何软件的运行，都必须运行在操作系统之上。<br><img src="/../../images/JavaSE/2022-05-12-22-09-00.png" alt="1"></p><h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><p>jre(java runtime environment):java程序时环境，包含jvm和运行时所需要的核心类库。<br>JDK(java development kit):java程序开发工具包，包含jre和开发人员使用的工具。<br>运行，只需要jre.开发，需要jdk.<br><img src="/../../images/JavaSE/2022-05-12-22-10-50.png" alt="2"><br>jdk下载地址： <a href="https://www.oracle.com/java/technologies/downloads/archive/">下载</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>此电脑-&gt;右键-&gt;属性</li><li>高级系统设置</li><li>环境变量</li><li>在系统变量新建</li><li>填写变量名：JAVA_HOME</li><li>变量值为java安装路径，结束为jdk….,点击确定</li><li>点击PATH</li><li>点击新建</li><li>填写%JAVA_HOME%\bin,完成</li></ol><h2 id="Hello-World入门程序"><a href="#Hello-World入门程序" class="headerlink" title="Hello World入门程序"></a>Hello World入门程序</h2><h3 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h3><p>java开发三步骤：<strong>编写、编译、运行</strong><br><img src="/../../images/JavaSE/2022-05-17-14-39-56.png" alt="167"></p><h3 id="编写Java源程序"><a href="#编写Java源程序" class="headerlink" title="编写Java源程序"></a>编写Java源程序</h3><ol><li>在d:\day01目录下新建文本文件，完整的文件名修改为HelloWorld.java,其中文件名为HelloWorld,后缀名必须为.java。</li><li>用记事本打开<blockquote><p>  使用notepad++记事本软件。</p></blockquote></li><li>写程序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWord</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="编译与运行Java源程序"><a href="#编译与运行Java源程序" class="headerlink" title="编译与运行Java源程序"></a>编译与运行Java源程序</h3><p>编译命令：</p><blockquote><p>javac + 源程序(文件名).java</p></blockquote><p>运行命令：</p><blockquote><p>java +源程序(文件名)</p></blockquote><ol><li>打开cmd(win+r,输入cmd)</li><li>cd 源程序路径（java文件所在的文件夹)</li><li>输入命令进行编译：javac +源程序(文件名).java,会发现在存放java文件的文件夹下多一个同名的.class文件</li><li>运行源程序：java +源程序(文件名)</li></ol><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><ul><li>单行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  这是一行注释信息</span></span><br></pre></td></tr></table></figure></li><li>多行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>说明  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多说明内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>说明：在java中有特殊含义的、被保留的、不能随意使用的字符称为关键字。<br>特点：</p><ul><li>完全小写的字母。</li><li>在增强版的记事本当中(例如Notepad++)有特殊颜色。</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p></li><li><p>命名规则(硬件要求)</p><ul><li>标识符可以包含<font color="red">英文字母26个(区分大小写)、0-9数字、$(美元符号)和_(下划线)。</font></li><li>标识符不能以数字开头。</li><li>标识符不能是关键字。</li></ul></li><li><p>命名规范(软件建议)</p><ul><li>类名规范：首字母大写，后面每个单词首字母大写(大驼峰式)</li><li>变量名规范：首字母小写，后面每个单词首字母大写(小驼峰式)</li><li>方法名规范：同变量名。</li></ul></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量：在程序运行期间，固定不变的量。</p><p>常量的分类：</p><ol><li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”abc”、”Hello”、”123”</li><li>整数常量：直接写上的数字，没有小数点。例如：100、200、0、-250</li><li>浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0</li><li>字符常量：凡是用单引号引起来的单个字符，叫做字符常量。例如：’a’,’B’,’9’,’中’</li><li>布尔常量：只有两种取值。true、false</li><li>空常量：null。代表没有任何数据。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>基本数据类型</p><ul><li>整数型 byte short int long</li><li>浮点型 float double</li><li>字符型 char</li><li>布尔型 boolean</li></ul></li><li><p>引用数据类型</p><ul><li>字符串</li><li>数组</li><li>类</li><li>接口</li><li>Lambda</li></ul></li></ol><p><img src="/../../images/JavaSE/2022-06-05-22-18-52.png" alt="16"><br><font color="red">注意事项：</font></p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li>数据范围与字节不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</li><li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母作为后缀。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量：程序运行期间，内容可以发生改变的量。</p><p>创建一个变量并且使用的格式：<br>①变量类型 变量名称；&#x2F;&#x2F;创建了一个变量<br>变量名称 &#x3D; 数据值;&#x2F;&#x2F;赋值，将右边的数据值赋值交给左边的变量<br>②一步到位格式：<br>数据类型 变量名称 &#x3D; 数据值；</p><p>注意：<br>创建多个变量，那么变量的名称不能重复。<br>对于float和long类型来说，字母后缀F和L不用丢掉<br>如果使用byte或者short类型的变量，右侧的数据值不能超过左侧类型的范围。<br>没有进行赋值的变量，不能直接使用；一定要赋值之后才能使用。<br>变量使用不能超过作用域的范围。<br>可以通过一个语句来创建多个变量，不推荐这样写。</p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>当数据类型不一样时，将会发生数据类型转换<br>基本数据类型的数据范围从小到大如下：<br>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>char-&gt;int-&gt;long-&gt;float-&gt;double</p><ul><li><p>自动类型转换(隐式)</p><ol><li>特点：代码不需要进行特殊处理，自动完成。</li><li>规则：数据范围从小到大。</li></ol></li><li><p>强制类型转换(显式)</p><ol><li>特点：代码需要进行特殊的格式处理，不能自动完成。</li><li>格式：范围小的类型 范围小的变量名 &#x3D; (范围小的类型)原本范围大的数据<br>  如：int num1 &#x3D; (int) 100L;—&gt;long类型范围比int大，不能自动转换，则需要强制类型转换。</li></ol></li></ul><p>自动类型转换例子：</p><blockquote><p>&#x2F;&#x2F;左边是long类型，右边是默认的int类型，左右不一样。自动类型转换<br>&#x2F;&#x2F;int–&gt;long,符合数据范围从小到大的要求<br>long num1 &#x3D; 100</p></blockquote><blockquote><p>左边double类型，右边float类型，符合数据范围从小到大，自动类型转换<br>double num2 &#x3D; 2.7F；</p></blockquote><blockquote><p>左边float类型，右边long类型，且long–&gt;float，float数据范围更大，符合自动类型转换。<br>float num3 &#x3D; 30L;</p></blockquote><p><font color="red">注意事项(强制类型转换)：</font></p><ol><li>强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出(大数据转换为小数据)。</li><li>byte&#x2F;short&#x2F;char这三种类型都可以发生数学运算，例如加法“+”.    ‘A’+1&#x3D;66</li><li>byte&#x2F;short&#x2F;char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</li><li>boolean类型不能发生数据类型转换。</li></ol><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><p>数字和字符的对照关系表(编码表)：<br>    ASCII码表：American Standard Code for Information Interchange,美国信息交换标准代码。<br>    Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含跟多字符。</p><p>48 –&gt; ‘0’<br>65 –&gt; ‘A’<br>97 –&gt; ‘a’</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-21-46.png" alt="3"><br><img src="/../../images/JavaSE/2022-06-07-16-27-50.png" alt="4"><br><img src="/../../images/JavaSE/2022-06-07-16-32-45.png" alt="5"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-36-53.png" alt="6"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-40-18.png" alt="7"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-45-38.png" alt="8"></p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-48-58.png" alt="9"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li><p>判断语句</p></li><li><p>选择语句</p><ul><li><p>if</p></li><li><p>if else</p></li><li><p>if … else if()</p></li><li><p>switch…case<br> 注意：<img src="/../../images/JavaSE/2022-06-08-10-19-17.png" alt="10"></p></li></ul></li><li><p>循环语句</p><ul><li>for(){}</li></ul><p> <img src="/../../images/JavaSE/2022-06-08-10-23-06.png" alt="11"></p><ul><li>while</li><li>do…while</li></ul></li></ol><p>3种循环的区别<br><img src="/../../images/JavaSE/2022-06-08-10-36-33.png" alt="12"></p><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>IDE：Integrated Development Environment,集成开发环境–是一种专门用来提高java开发效率的软件。<br>免费eclipse与收费Intellij IDEA</p><p>Intellij IDEA的下载与安装：</p><p><a href="https://www.jetbrains.com/idea/download/other.html">官网下载</a></p><p>IDEA常用快捷键<br><img src="/../../images/JavaSE/2022-06-08-11-16-36.png" alt="13"><br><img src="/../../images/JavaSE/2022-07-12-17-00-19.png" alt="14"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java高级(全)</title>
      <link href="/2023/03/04/Java/java-high/"/>
      <url>/2023/03/04/Java/java-high/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p><p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p><p>数组：类型和长度一旦定义出来就都固定</p><p>作用：</p><ul><li>在开发中，很多时候元素的个数是不确定的</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li></ul><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><ul><li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p></li><li><p>栈（stack）：后进先出，先进后出 （LIFO）</p></li><li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p><p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p></li><li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p></li><li><p>树：</p><ul><li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） </p><p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p></li><li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p><p>特点：<strong>红黑树的增删查改性能都好</strong></p></li></ul></li></ul><p>各数据结构时间复杂度对比：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png"></p><p>图片来源：<a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p><hr><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p><p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection集合的体系:</span><br><span class="line">                      Collection&lt;E&gt;(接口)</span><br><span class="line">                 /                         \</span><br><span class="line">          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)</span><br><span class="line">      /               \                  /             \</span><br><span class="line"> HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类)</span><br><span class="line"> /</span><br><span class="line">LinkedHashSet&lt;&gt;(实现类)</span><br></pre></td></tr></table></figure><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><hr><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sets.add(<span class="string">&quot;MyBatis&quot;</span>);</span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        sets.add(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">        sets.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(sets)<span class="comment">//[]无序的;</span></span><br><span class="line">        System.out.println(sets.contains(<span class="string">&quot;java&quot;</span>));<span class="comment">//true 存在</span></span><br><span class="line">        Object[] arrs = sets.toArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c1.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;ee&quot;</span>);</span><br><span class="line">        c1.addAll(c2);<span class="comment">// c1:[java,ee]  c2:[ee];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器</p><ul><li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li><li><code>E next()</code>：获取下一个元素值</li><li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li><li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li></ul></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        System.out.println(lists); <span class="comment">// lists = [aa, bb, cc]</span></span><br><span class="line"><span class="comment">//迭代器流程</span></span><br><span class="line">        <span class="comment">// 1.得到集合的迭代器对象。</span></span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="comment">// 2.使用while循环遍历。</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>List 集合继承了 Collection 集合全部的功能。</p><p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p><p>List 系列集合：</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引</p></li></ul><hr><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//多态</span></span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);<span class="comment">//可以重复</span></span><br><span class="line">    lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; lists.size() ; i++ ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e 插入的元素  elementData底层数组   size 插入的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">// 插入size位置，然后加一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断elementData是不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值和最小需求容量最大的一个</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的容量大于数组长度，进行扩容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 索引越界</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将指定索引后的数据后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity&#x2F;2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;<span class="comment">//不需要扩容计算</span></span><br><span class="line">    <span class="comment">//检查新容量是否大于最大数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span></span><br><span class="line">        <span class="comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取下一个元素时首先判断结构是否发生变化</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount 被其他线程改变抛出并发修改异常</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【允许删除操作】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 删除后重置 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code> 数组存储</p></li></ol><hr><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue); <span class="comment">// [1号, 2号, 3号]</span></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//1号</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//2号</span></span><br><span class="line">        System.out.println(queue);<span class="comment">//[3号]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做一个栈 先进后出</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);<span class="comment">//addFirst(e);</span></span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack); <span class="comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span></span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        System.out.println(stack.pop());<span class="comment">//removeFirst(); 第3颗子弹</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);<span class="comment">// [第1颗子弹]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index&#x3D;0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index&#x3D;-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Set 系列集合：</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p><hr><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT &#x3D; new Object()</strong></p><p>Set 集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。</span><br><span class="line"><span class="number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。</span><br><span class="line">    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）</span><br><span class="line">    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。</span><br><span class="line">    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了</span><br><span class="line">    如果不相同认为不重复。</span><br><span class="line"></span><br><span class="line">            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较</span><br><span class="line">               /                     \</span><br><span class="line">            <span class="literal">false</span>                    <span class="literal">true</span></span><br><span class="line">            /                          \</span><br><span class="line">        不重复                        继续让两个对象进行equals比较</span><br><span class="line">                                       /          \</span><br><span class="line">                                     <span class="literal">false</span>        <span class="literal">true</span></span><br><span class="line">                                      /             \</span><br><span class="line">                                    不重复          重复了</span><br></pre></td></tr></table></figure></li><li><p>Set 系列集合元素无序的根本原因</p><p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><ul><li>JDK 1.8 之前：哈希表 &#x3D; 数组（初始容量16) + 链表  + （哈希算法）</li><li>JDK 1.8 之后：哈希表 &#x3D; 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul><li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li><li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><hr><h4 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h4><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><hr><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>   方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><pre><code>  * 比较者大于被比较者，返回正数  * 比较者小于被比较者，返回负数  * 比较者等于被比较者，返回 0</code></pre></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">Collections.add(students,s1,s2,s3);</span><br><span class="line">        System.out.println(students);<span class="comment">//按照年龄比较 升序</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// o1比较者   o2被比较者</span></span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 重写了比较方法。</span></span><br><span class="line">    <span class="comment">// e1.compareTo(o)</span></span><br><span class="line">    <span class="comment">// 比较者：this</span></span><br><span class="line">    <span class="comment">// 被比较者：o</span></span><br><span class="line">    <span class="comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? <span class="built_in">this</span>.getName().compareTo(o.getName):result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p><hr><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="comment">//实现大顶堆</span></span><br></pre></td></tr></table></figure></li></ul><p>常用 API：</p><ul><li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列的<strong>尾部</strong></li><li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null </li><li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li><li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li></ul><hr><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p><p>Collections 有几个常用的API：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li><li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;赵&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">98.5</span>, <span class="number">66.5</span> , <span class="number">59.5</span> , <span class="number">66.5</span> , <span class="number">99.5</span> );</span><br><span class="line">        Collections.shuffle(scores);</span><br><span class="line">        Collections.sort(scores); <span class="comment">// 默认升序排序！</span></span><br><span class="line">        System.out.println(scores);</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(students,s1,s2,s3,s4);</span><br><span class="line">        Collections.sort(students,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key&#x3D;value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map集合的体系：</span><br><span class="line">        Map&lt;K , V&gt;(接口,Map集合的祖宗类)</span><br><span class="line">       /                      \</span><br><span class="line">      TreeMap&lt;K , V&gt;           HashMap&lt;K , V&gt;(实现类,经典的，用的最多)</span><br><span class="line">                                 \</span><br><span class="line">                                  LinkedHashMap&lt;K, V&gt;(实现类)</span><br></pre></td></tr></table></figure><p>Map 集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><hr><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(.....);</span><br><span class="line">        System.out.println(maps.isEmpty());<span class="comment">//false</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(<span class="string">&quot;....&quot;</span>);<span class="comment">//返回键值对象</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();<span class="comment">//获取Map集合中所有的键，</span></span><br><span class="line">        <span class="comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        <span class="comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//(1)键找值</span></span><br><span class="line">    Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key : keys) &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Iterator&lt;String&gt; iterator = hm.keySet().iterator();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)键值对</span></span><br><span class="line">    <span class="comment">//(2.1)普通方式</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">             System.out.println(entry.getKey() + <span class="string">&quot;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2.2)迭代器方式</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) Lamda</span></span><br><span class="line">    maps.forEach((k,v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;==&gt;&quot;</span> + v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 &#x3D; 数组 + 链表，8 &#x3D; 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由数组+链表组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><p><a href="https://www.bilibili.com/video/BV1nJ411J7AA">参考视频</a></p><hr><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>HashMap 继承关系如下图所示：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li></ul><hr><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>HashMap 构造方法指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity)<span class="comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合最大容量 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合最大容量的上限是：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span></span><br></pre></td></tr></table></figure></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p> 为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="number">0.75</span>，平均参数约为<span class="number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="number">0.5</span>)*pow(<span class="number">0.5</span>, k)/factorial(k))</span><br><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br><span class="line">一个bin中链表长度达到<span class="number">8</span>个元素的概率为<span class="number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="number">8</span>这个数字</span><br></pre></td></tr></table></figure></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)&#x3D;3，链表的平均查找长度为 n&#x2F;2，当长度为 8 时，平均查找长度为 8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，而 log(6)&#x3D;2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小于 6 则会从红黑树转回链表</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p> 原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>HashMap 中<strong>存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></li><li><p>记录 HashMap 的修改次数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br></pre></td></tr></table></figure></li><li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希表的加载因子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size&#x2F;capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p><p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)<span class="comment">//构造指定初始容量和加载因子的空HashMap</span></span><br></pre></td></tr></table></figure></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;&#x3D; threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p></li></ul></li></ol><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"><span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// 最后调用了tableSizeFor</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putMapEntries 源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">            <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s &#x2F; loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><hr><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p></li><li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p><p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span></span><br><span class="line">    <span class="comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  <span class="comment">//。。。。。。。。。。。。。。</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="comment">// 如果这里允许覆盖，就直接返回了</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数量大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;"><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY &#x3D; 64 就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;<span class="comment">//int cap = 10</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n&#x3D;0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位或之后是13</span></span><br><span class="line"><span class="comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span></span><br></pre></td></tr></table></figure></li><li><p>第二次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位或之后是15</span></span><br><span class="line"><span class="comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span></span><br></pre></td></tr></table></figure><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure></li><li><p>JDK 11</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">//无符号右移，高位补0</span></span><br><span class="line"><span class="comment">//-1补码: 11111111 11111111 11111111 11111111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最高位之前的0的位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始化的threshold赋值给newCap</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// oldCap 旧数组大小，2 的 n 次幂</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;<span class="comment">//指向低位链表头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;<span class="comment">//指向低位链表尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;<span class="comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span></span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果低位链表首节点不为null，说明有这个链表存在</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果链表下的元素小于等于6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span></span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span></span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//需要构建新的红黑树了</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span></span><br><span class="line">    <span class="comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;<span class="comment">//临时变量，储存要返回的节点信息</span></span><br><span class="line">        <span class="comment">//key和value都相等，直接返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="comment">//跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//把当前节点p指向e 继续遍历</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line">        <span class="comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//node是首节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//node不是首节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//LinkedHashMap</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><hr><h4 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h4><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.keySet().iterator();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 底层获取的是 KeyIterator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 回调 HashMap.HashIterator#nextNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> nextNode().key; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for 【fast-fail】，快速失败</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// iterator.next() 会调用这个函数</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li><li><p>维护顺序的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>put()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用父类HashMap的put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">→ afterNodeInsertion(evict);<span class="comment">// evict为true</span></span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);<span class="comment">//移除头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断 p 是否是首节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//是头节点 让p后继节点成为头节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 判断p是否是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 不是尾节点 让p后继节点指向p的前驱节点</span></span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 是尾节点 让last指向p的前驱节点</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 判断last是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// last为空说明p是尾节点或者只有p一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// last和p相互连接</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用HashMap的remove方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,<span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span></span><br><span class="line">→ afterNodeRemoval(node);</span><br></pre></td></tr></table></figure><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 让p节点与前驱节点和后继节点断开链接</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断p是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是头节点 让head指向p的后继节点</span></span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);<span class="comment">//把1放入尾部</span></span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());<span class="comment">//[3, 1, 4]只能存3个，移除2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p><p>成员属性：</p><ul><li><p>Entry 节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;<span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;<span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;<span class="comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator == <span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p><hr><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p><ul><li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p></li><li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p></li><li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p></li><li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">            <span class="built_in">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>泛型（Generic）：</p><ul><li>泛型就是一个标签：&lt;数据类型&gt;</li><li>泛型可以在编译阶段约束只能操作某种数据类型。</li></ul><p>注意：</p><ul><li>JDK 1.7 开始之后，泛型后面的申明可以省略不写</li><li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">lists.add(<span class="number">99.9</span>);</span><br><span class="line">lists.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">lists.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lists1.add(<span class="number">10</span>);</span><br><span class="line">lists1.add(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p><hr><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类：使用了泛型定义的类就是泛型类</p><p>泛型类格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">泛型变量建议使用 E , T , K , V</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;String&gt;();</span><br><span class="line">        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;自定义泛型类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法：定义了泛型的方法就是泛型方法</p><p>泛型方法的定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p><p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] num = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> arrToString(nums);</span><br><span class="line">     </span><br><span class="line">        String[] name = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> arrToString(names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">arrToString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        --------------</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><p>泛型接口：使用了泛型定义的接口就是泛型接口。</p><p>泛型接口的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentData</span>();</span><br><span class="line">        d.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        ................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;重写所有方法&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符：？</p><ul><li>? 可以用在使用泛型的时候代表一切类型</li><li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li><li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;AD&gt; ads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        run(bmws);</span><br><span class="line">        <span class="comment">//run(dogs);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ArrayList&lt;? extends Car&gt; car)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AD</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异常的体系:</span><br><span class="line">         Throwable(根类，不是异常类)</span><br><span class="line">      /              \</span><br><span class="line">    Error           Exception（异常，需要研究和处理）</span><br><span class="line">                    /            \</span><br><span class="line">                   编译时异常     RuntimeException(运行时异常)</span><br></pre></td></tr></table></figure><p>Exception 异常的分类:</p><ul><li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li><li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li></ul><hr><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点终止当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。。。。。。。&quot;</span>);</span><br><span class="line">        chu( <span class="number">10</span> ,<span class="number">0</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b ;<span class="comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p><p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p><p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h4><p>可以处理异常，并且出现异常后代码也不会死亡</p><ul><li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;...finall&#123;</span><br><span class="line"><span class="comment">//资源释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace(); <span class="comment">// **直接打印异常栈信息**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Throwable成员方法:</strong></p><ul><li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li><li><code>public String toString()</code>：返回此可抛出的简短描述</li><li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h4><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseDate(<span class="string">&quot;2013-03-23 10:19:23&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseDate</span><span class="params">(String time)</span> <span class="keyword">throws</span> Exception&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常：NumberFormatException</li></ol><hr><h3 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h3><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            chu(<span class="number">10</span> / <span class="number">0</span>);<span class="comment">//ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作成功！&quot;</span>);<span class="comment">//没输出</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;操作失败！&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>  &#123; System.out.println( a / b );&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>用在捕获处理的异常格式中的，放在最后面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>: <span class="number">1</span>次。</span><br><span class="line"><span class="keyword">catch</span>：<span class="number">0</span>-N次  (如果有<span class="keyword">finally</span>那么<span class="keyword">catch</span>可以没有!!)</span><br><span class="line"><span class="keyword">finally</span>: <span class="number">0</span>-<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(chu());<span class="comment">//一定会输出 finally,优先级比return高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">return</span> a ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====finally被执行&quot;</span>);</span><br><span class="line">            <span class="comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/cang.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==finally被执行===&quot;</span>);</span><br><span class="line">            <span class="comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h2><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li></ul><p>throws：用在方法上，用于抛出方法中的异常</p><p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIllegalException &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>)&#123;<span class="comment">//年龄在0-200之间</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;/ age is illegal!&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄是：&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    Alt + Insert-&gt;Constructor </span><br><span class="line">&#125;<span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//运行时异常</span></span><br></pre></td></tr></table></figure><hr><h2 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h2><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li><li>在 try&#x2F;catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//请输入一个合法的年龄</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入您的年年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄：&quot;</span>+age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;您的年龄是瞎输入的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda 表达式的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line"><span class="comment">//被重写方法的方法体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h3 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h3><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p><ul><li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; System.out.println(s) );</span><br></pre></td></tr></table></figure><hr><h3 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h3><p>Comparator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//...s1 s2 s3</span></span><br><span class="line">        Collections.addAll(lists , s1 , s2 , s3);</span><br><span class="line">        Collections.sort(lists, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.getAge() - t2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 参数类型可以省略,最简单的</span></span><br><span class="line">        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lists.forEach( s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 方法引用！</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义集合加入几个Student元素</span></span><br><span class="line"><span class="comment">// 使用静态方法进行简化！</span></span><br><span class="line">Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));</span><br><span class="line"><span class="comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span></span><br><span class="line">Collections.sort(lists, Student::compareByAge);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1 , Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        <span class="comment">// 对象是 System.out = new PrintStream();</span></span><br><span class="line">        <span class="comment">// 实例方法：println()</span></span><br><span class="line">        <span class="comment">// 前后参数正好都是一个</span></span><br><span class="line">        lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Patricia&quot;</span>,<span class="string">&quot;Dlei&quot;</span> , <span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Boom&quot;</span>, <span class="string">&quot;Cao&quot;</span> ,<span class="string">&quot;black&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>,<span class="string">&quot;cao&quot;</span>,<span class="string">&quot;after&quot;</span>,<span class="string">&quot;sa&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span></span><br><span class="line">        <span class="comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span></span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.compareToIgnoreCase(s2);<span class="comment">//按照元素的首字符(忽略大小写)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特定类型的方法引用：</span></span><br><span class="line">        Arrays.sort(strs,  String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合默认只能转成Object类型的数组。</span></span><br><span class="line">        Object[] objs = lists.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span></span><br><span class="line">        String[] strs = lists.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String[] strs1 = lists.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]);</span><br><span class="line">        String[] strs2 = lists.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p><ul><li>可以解决已有集合类库或者数组 API 的弊端</li><li>Stream 流简化集合和数组的操作</li><li>链式编程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p><p>数组：Arrays.stream(数组)   &#x2F;  Stream.of(数组);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection集合获取Stream流。</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; listStream = c.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map集合获取流</span></span><br><span class="line"><span class="comment">// 先获取键的Stream流。</span></span><br><span class="line">Stream&lt;String&gt; keysStream = map.keySet().stream();</span><br><span class="line"><span class="comment">// 在获取值的Stream流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = map.values().stream();</span><br><span class="line"><span class="comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组获取流</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaEE&quot;</span> ,<span class="string">&quot;Spring Boot&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;String&gt; arrStream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>逐一处理（遍历）</td></tr><tr><td>long count</td><td>返回流中的元素数</td></tr><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</T></td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</T></td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream<T> skip(long n)</T></td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</R></R></td><td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</T></T></td><td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td></tr><tr><td>Stream<T> distinct()</T></td><td>返回由该流的不同元素组成的流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>); list.add(<span class="string">&quot;周芷若&quot;</span>); list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>); list.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">        <span class="comment">//取以张开头并且名字是三位数的</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).count();</span><br><span class="line"><span class="comment">//取前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).limit(<span class="number">2</span>).forEach(...);</span><br><span class="line"><span class="comment">//跳过前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).skip(<span class="number">2</span>).forEach(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：把名称都加上“张三的:+xxx”</span></span><br><span class="line">list.stream().map(s -&gt; <span class="string">&quot;张三的&quot;</span> + s).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 需求：把名称都加工厂学生对象放上去!!</span></span><br><span class="line"><span class="comment">// list.stream().map(name -&gt; new Student(name));</span></span><br><span class="line">list.stream.map(Student::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">                                          </span><br><span class="line"><span class="comment">//数组流</span></span><br><span class="line">Stream&lt;Integer&gt; s1 = Stream.of(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">//集合流</span></span><br><span class="line">Stream&lt;String&gt; s2 = list.stream();</span><br><span class="line"><span class="comment">//合并流</span></span><br><span class="line">Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);</span><br><span class="line">s3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure><hr><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreach终结方法</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">    .filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h3><p>收集 Stream：把 Stream 流的数据转回到集合中去</p><ul><li>Stream 流：工具</li><li>集合：目的</li></ul><p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p><p>Collectors 方法：</p><ul><li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li><li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li><li><code>Object[] toArray()</code>：把元素收集数组中</li><li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));    </span><br><span class="line">    <span class="comment">//把stream流转换成Set集合。</span></span><br><span class="line">    Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成List集合。</span></span><br><span class="line">    <span class="comment">//重新定义，因为资源已经被关闭了</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成数组。</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    Object[] arr = stream2.toArray();</span><br><span class="line">    <span class="comment">// 可以借用构造器引用申明转换成的数组类型！！！</span></span><br><span class="line">    String[] arr1 = stream2.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p><p>File 类构造器：</p><ul><li><code>public File(String pathname)</code>：根据路径获取文件对象</li><li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li></ul><p>File 类创建文件对象的格式：</p><ul><li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p><ul><li>绝对路径：从磁盘的的盘符一路走到目的位置的路径<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li><li>一般是定位某个操作系统中的某个文件对象</li></ul></li><li><strong>相对路径</strong>：不带盘符的（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件，可以跨平台</li></ul></li></ul></li><li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象：使用绝对路径</span></span><br><span class="line">        <span class="comment">// 文件路径分隔符：</span></span><br><span class="line">        <span class="comment">//      -- a.使用正斜杠： /</span></span><br><span class="line">        <span class="comment">//      -- b.使用反斜杠： \\</span></span><br><span class="line">        <span class="comment">//      -- c.使用分隔符API:File.separator</span></span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator</span></span><br><span class="line"><span class="comment">//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 获取文件的大小，字节大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建文件对象：使用相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day09Demo/src/dlei.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建文件对象：代表文件夹。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片资源&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists());<span class="comment">// 判断路径是否存在！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getAbsolutePath()</td><td>返回此 File 的绝对路径名字符串</td></tr><tr><td>String getPath()</td><td>获取创建文件对象的时候用的路径</td></tr><tr><td>String getName()</td><td>返回由此 File 表示的文件或目录的名称</td></tr><tr><td>long length()</td><td>返回由此 File 表示的文件的长度（大小）</td></tr><tr><td>long length(FileFilter filter)</td><td>文件过滤器</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/图片/test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>方法列表：</p><ul><li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li><li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li><li><code>boolean isFile()</code>：此 File 表示的是否为文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// a.判断文件路径是否存在</span></span><br><span class="line">System.out.println(f.exists()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span></span><br><span class="line">System.out.println(f.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span></span><br><span class="line">System.out.println(f.isDirectory()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h4><p>方法列表：</p><ul><li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li><li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li><li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li><li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.创建新文件，创建成功返回true ,反之</span></span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f.delete());</span><br><span class="line">        <span class="comment">// 不能删除非空文件夹，只能删除空文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/it/aaaaa&quot;</span>);</span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/bbbb&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d.创建多级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><ul><li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li><li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li><li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified(); <span class="comment">// 最后修改时间！</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>递归实现文件搜索（非规律递归）</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去某个目录下搜索某个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 搜索文件的目录。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName 搜索文件的名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir , String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断是否存在该路径，是否是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">        <span class="comment">// 2.提取当前目录下的全部一级文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">files</span> <span class="operator">=</span> dir.listFiles();<span class="comment">// 可能是null/也可能是空集合[]</span></span><br><span class="line">        <span class="comment">// 3.判断是否存在一级文件对象,判断是否不为空目录</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.判断一级文件对象</span></span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="comment">// 5.判断file是文件还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 6.判断该文件是否为我要找的文件对象</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;<span class="comment">//模糊查找</span></span><br><span class="line">                        sout(f.getAbsolutePath());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 启动它（拓展）</span></span><br><span class="line">                            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                            r.exec(f.getAbsolutePath());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span></span><br><span class="line">                    searchFiles(file,fileName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>字符集：为字符编制的一套编号规则</p><p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p><p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 &#x3D; 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  97</span><br><span class="line">b  98</span><br><span class="line"></span><br><span class="line">A  65</span><br><span class="line">B  66</span><br><span class="line"></span><br><span class="line">0  48</span><br><span class="line">1  49</span><br></pre></td></tr></table></figure><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p><p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p><ul><li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li><li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li></ul><p>编码前与编码后的编码集必须一致才不会乱码</p><hr><h2 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>IO 输入输出流：输入&#x2F;输出流</p><ul><li>Input：输入</li><li>Output：输出</li></ul><p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p><p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p><p>IO 流的分类：</p><ul><li>按照流的方向分为：输入流，输出流。<ul><li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li></ul></li><li>按照流的内容分为：字节流，字符流<ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li></ul></li></ul><p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IO 流的体系：</span><br><span class="line">        字节流                                   字符流</span><br><span class="line">  字节输入流              字节输出流            字符输入流         字符输出流</span><br><span class="line">InputStream           OutputStream          Reader            <span class="title function_">Writer</span>   <span class="params">(抽象类)</span></span><br><span class="line">FileInputStream       FileOutputStream      FileReader        <span class="title function_">FileWriter</span><span class="params">(实现类)</span></span><br><span class="line">BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="title function_">BufferedWriter</span><span class="params">(实现类缓冲流)</span></span><br><span class="line">                                           InputStreamReader OutputStreamWriter</span><br><span class="line">ObjectInputStream     ObjectOutputStream</span><br></pre></td></tr></table></figure><hr><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h4><p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p><p>构造方法：</p><ul><li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li><li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象</li></ul><p>方法：</p><ul><li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li><li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li><li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li><li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象定位dlei01.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/dlei01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span></span><br><span class="line"><span class="comment">//int code1 = is.read(); // 读取一滴水，一个字节</span></span><br><span class="line"><span class="comment">//System.out.println((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.使用while读取字节数</span></span><br><span class="line">        <span class="comment">// 定义一个整数变量存储字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>((ch = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p><p>采取下面的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//简化写法，底层实质上创建了File对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];<span class="comment">//开发中使用byte[1024]</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取了多少就倒出多少！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"><span class="comment">// 读取全部的</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer);</span><br><span class="line">System.out.println(rs);</span><br></pre></td></tr></table></figure><hr><h4 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h4><p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p><p>构造方法：</p><ul><li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li><li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li><li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li><li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li></ul><p>API：</p><ul><li><p><code>public void write(int a)</code>：写一个字节出去 </p></li><li><p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p></li><li><p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p></li><li><p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p><ul><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot;)</code>：覆盖数据管道</li><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot; , true)</code>：追加数据的管道</li></ul></li></ul><p>说明：</p><ul><li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li><li>换行用：<strong>os.write(“\r\n”.getBytes())</strong></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/out05&quot;</span>);</span><br><span class="line">os.write(<span class="number">97</span>);<span class="comment">//a</span></span><br><span class="line">os.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">os.write(<span class="string">&quot;我爱Java&quot;</span>.getBytes());</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//（1）创建一个字节输入流管道与源文件接通。</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（2）创建一个字节输出流与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（3）创建一个字节数组作为桶</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//（4）从字节输入流管道中读取数据，写出到字节输出流管道即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**（5）关闭资源！ */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h4><p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p><p>构造器：</p><ul><li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li><li><code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li></ul><p>方法：</p><ul><li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li><li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li></ul><p>结论：</p><ul><li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li><li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li></ul><p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span>&#123;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个字符输入流管道与源文件路径接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h4><p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p><p>构造器：</p><ul><li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li><li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li><li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li><li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li></ul><p>方法：</p><ul><li><code>public void write(int c)</code>：写一个字符出去</li><li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li><li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li><li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li><li><code>fw.write(&quot;\r\n&quot;)</code>：换行</li></ul><p>读写字符文件数据建议使用字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">fw.write(<span class="number">97</span>);   <span class="comment">// 字符a</span></span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 字符b</span></span><br><span class="line">fw.write(<span class="string">&quot;Java是最优美的语言！&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">fw.close;</span><br></pre></td></tr></table></figure><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲流可以提高字节流和字符流的读写数据的性能</p><p>缓冲流分为四类：</p><ul><li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li><li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li><li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li><li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li></ul><hr><h4 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h4><p>字节缓冲输入流：BufferedInputStream</p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p><p>构造器：<code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个低级的字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span></span><br><span class="line">        <span class="type">BufferInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferInputStream</span>(is);</span><br><span class="line">        <span class="comment">// 3.定义一个字节数组按照循环读取。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h4><p>字节缓冲输出流：BufferedOutputStream</p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.写一个原始的字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输出流包装成一个高级的缓冲字节输出流</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 3.写数据出去</span></span><br><span class="line">        bos.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bos.write(<span class="number">100</span>);</span><br><span class="line">        bos.write(<span class="string">&quot;我爱中国&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h4><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p><p>复制流：</p><ul><li>使用低级的字节流按照一个一个字节的形式复制文件</li><li>使用低级的字节流按照一个一个字节数组的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li></ul><p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p><hr><h4 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h4><p>字符缓冲输入流：BufferedReader</p><p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p><p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个原始的字符输入流读取源文件</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">    <span class="comment">// 定义一个字符串变量存储每行数据</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">    <span class="comment">//淘汰数组循环读取</span></span><br><span class="line">    <span class="comment">//char[] buffer = new char[1024];</span></span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    <span class="comment">//while((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.println(new String(buffer , 0 , len));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h4><p>符缓冲输出流：BufferedWriter</p><p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code></p><p> 原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p><p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>,<span class="literal">true</span>);<span class="comment">//追加</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    </span><br><span class="line">    bw.write(<span class="string">&quot;我爱学习Java&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//换行</span></span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h4><p>字符型缓冲流高效的原因：（空间换时间）</p><ul><li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li><li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li></ul><p>字节型缓冲流高效的原因：</p><ul><li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li><li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。</li></ul><p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p><hr><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h4><p>字符流读取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码编码            文件编码         中文情况。</span><br><span class="line">UTF-8              UTF-8           不乱码!</span><br><span class="line">GBK                GBK             不乱码!</span><br><span class="line">UTF-8              GBK             乱码!</span><br></pre></td></tr></table></figure><ul><li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li><li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li></ul><hr><h4 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h4><p>字符输入转换流：InputStreamReader</p><p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li><li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.提取GBK文件的原始字节流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\Netty.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        <span class="comment">// 3.包装成缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h4><p>字符输出转换流：OutputStreamWriter</p><p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;我在学习Java&quot;</span>);   </span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 &#x3D;&gt; 文件中</p><p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 &#x3D;&gt; 对象</p><p>transient 关键字修饰的成员变量，将不参与序列化</p><hr><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p><p>作用：把内存中的 Java 对象数据保存到文件中去</p><p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建User用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;seazean&quot;</span>,<span class="string">&quot;980823&quot;</span>,<span class="string">&quot;七十一&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建低级的字节输出流通向目标文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.通过对象字节输出流序列化对象：</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">// 5.释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化对象成功~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">// get+set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化为二进制数据</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(obj);<span class="comment">// 将该对象序列化为二进制数据</span></span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] bytes = bos.toByteArray();</span><br></pre></td></tr></table></figure><hr><h4 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h4><p>对象反序列化（对象字节输入流）：ObjectInputStream</p><p>作用：读取序列化的对象文件恢复到 Java 对象中</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p><p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)ois.readObject();<span class="comment">//反序列化</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流 PrintStream &#x2F; PrintWriter</p><p>打印流的作用：</p><ul><li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li><li>PrintStream&#x2F;PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li><li><strong>System.out.print() 底层基于打印流实现的</strong></li></ul><p>构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><p>System 类：</p><ul><li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        ps.println(任何类型的数据);</span><br><span class="line">        ps.print(不换行);</span><br><span class="line">        ps.write(<span class="string">&quot;我爱你&quot;</span>.getBytes());</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean0==&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/log.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 让系统的输出流向打印流</span></span><br><span class="line"><span class="comment">//不输出在控制台，输出到文件里</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean1==&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean2==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h2><p>try-with-resources：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    <span class="comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span></span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p><p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"><span class="comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （2）创建一个字节输出流与目标文件接通。*/</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （5）关闭资源！是自动进行的 */</span></span><br><span class="line">)&#123;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p><p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p><p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key&#x3D;value</p><p>Properties 方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key, String value)</td><td>设置集合的键和值，底层调用 Hashtable 方法 put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String>   stringPropertyNames()</String></td><td>所有键的名称的集合</td></tr><tr><td>synchronized void load(Reader r)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>synchronized void load(InputStream in)</td><td>加载属性文件的数据到属性集对象中去</td></tr><tr><td>void store(Writer w, String comments)</td><td>将此属性列表(键和元素对)写入 Properties 表</td></tr><tr><td>void store(OutputStream os, String comments)</td><td>保存数据到属性文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.创建一个属性集对象：Properties的对象。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//&#123;&#125;</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span> , <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>);</span><br><span class="line">        properties.store(os,<span class="string">&quot;i am very happy!!我保存了用户数据!&quot;</span>);</span><br><span class="line">        <span class="comment">//参数一：被保存数据的输出管道</span></span><br><span class="line">        <span class="comment">//参数二：保存心得。就是对象保存的数据进行解释说明！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//底层基于map集合</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        </span><br><span class="line">Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(s);</span><br><span class="line">            System.out.println(s + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h2><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p><p>构造器：</p><ul><li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li><li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li></ul><p>常用方法：</p><ul><li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li><li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li><li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    rf.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">    rf.seek(<span class="number">5</span>);<span class="comment">//helloxxxxld</span></span><br><span class="line">    rf.write(<span class="string">&quot;xxxx&quot;</span>.getBytes());</span><br><span class="line">    rf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h2><p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p><p>commons-io 工具包提供了很多有关 IO 操作的类：</p><table><thead><tr><th>包</th><th align="left">功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td align="left">有关 Streams、Readers、Writers、Files 的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td align="left">输入流相关的实现类，包含 Reader 和 InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td align="left">输出流相关的实现类，包含 Writer 和 OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td align="left">序列化相关的类</td></tr></tbody></table><p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.完成文件复制！</span></span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>), </span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.完成文件复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyFileToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片服务器&quot;</span>) ,</span><br><span class="line">                                           <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span></span><br><span class="line">        Files.copy(Paths.get(<span class="string">&quot;Demo/src/books.xml&quot;</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new11.txt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p><p>单元测试：</p><ul><li>单元：在 Java 中，一个类就是一个单元<br>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试</li></ul><p></p><p>Junit 单元测试框架的作用：</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li><li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li></ul><p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p><p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p><ul><li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li><li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li></ul><p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p><ul><li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li><li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li></ul><p>作用：</p><ul><li>开始执行的方法：初始化资源</li><li>执行完之后的方法：释放资源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">     <span class="comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">/**断言预期结果的正确性。</span></span><br><span class="line"><span class="comment">         * 参数一：测试失败的提示信息。</span></span><br><span class="line"><span class="comment">         * 参数二：期望值。</span></span><br><span class="line"><span class="comment">         * 参数三：实际值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="string">&quot;success&quot;</span>,rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.chu(<span class="number">10</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h2><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p><ul><li><p>构造器对象：Constructor</p></li><li><p>成员变量对象：Field</p></li><li><p>成员方法对象：Method</p></li></ul><p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p><p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p><ul><li><code>Class c = HelloWorld.class</code></li></ul><p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p><p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p><p>反射的优点：</p><ul><li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li></ul><p>反射的缺点：</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li><li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li><li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li></ul><hr><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p><ul><li>类名.class</li><li>类的对象.getClass()</li><li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li></ul><p>Class 类下的方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getSimpleName()</td><td>获得类名字符串：类名</td></tr><tr><td>String getName()</td><td>获得类全名：包名+类名</td></tr><tr><td>T newInstance()</td><td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span></span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class _03反射_获取Class类对象.Student</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> swk.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName(&quot;类的全限名&quot;)</span></span><br><span class="line">        <span class="comment">// 直接去加载该类的class文件。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;_03反射_获取Class类对象.Student&quot;</span>);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获取类名本身（简名）Student</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取类的全限名_03反射_获取Class类对象.Student</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h3><p>获取构造器的 API：</p><ul><li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li><li>Constructor getDeclaredConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li><li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li><li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li></ul><p>Constructor 的常用 API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>创建对象，注入构造器需要的数据</td></tr><tr><td>void setAccessible(true)</td><td>修改访问权限，true 攻破权限（暴力反射）</td></tr><tr><td>String getName()</td><td>以字符串形式返回此构造函数的名称</td></tr><tr><td>int getParameterCount()</td><td>返回参数数量</td></tr><tr><td>Class&lt;?&gt;[] getParameterTypes</td><td>返回参数类型数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位全部构造器，只要申明了就可以拿到</span></span><br><span class="line">        Constructor[] cons = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历这些构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor con : cons) &#123;</span><br><span class="line">            System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位某个构造器，根据参数匹配，只要申明了就可以获取</span></span><br><span class="line">        <span class="comment">//Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//有参数的！!</span></span><br><span class="line">        <span class="comment">// c.构造器名称和参数</span></span><br><span class="line">        System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用无参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位无参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// c.暴力打开私有构造器的访问权限</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// d.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(); <span class="comment">// 最终还是调用无参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用有参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位有参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class , <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// c.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>); <span class="comment">// 最终还是调用有参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h3><p>获取 Field 成员变量 API：</p><ul><li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li><li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li><li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li><li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到</li></ul><p>Field 的方法：给成员变量赋值和取值</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td></tr><tr><td>Object get(Object obj)</td><td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td></tr><tr><td>void setAccessible(true)</td><td>暴力反射，设置为可以直接访问私有类型的属性</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回 Class 对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo</span> &#123;</span><br><span class="line">    <span class="comment">//获取全部成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.获取全部申明的成员变量对象</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName()+<span class="string">&quot;-&gt;&quot;</span>+field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某个成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.定位某个成员变量对象 :根据名称定位！！</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(ageF.getName()+<span class="string">&quot;-&gt;&quot;</span>+ageF.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_1</span> <span class="operator">=</span> <span class="string">&quot;宠物学校&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射的第一步获取Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.定位name成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// c.为这个成员变量赋值！</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(d,<span class="string">&quot;泰迪&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;</span></span><br><span class="line">        <span class="comment">// d.获取成员变量的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> name.get(d)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(value);<span class="comment">//泰迪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取 Method 方法 API：</p><ul><li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li><li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li><li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li><li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li></ul><p>Method 常用 API：</p><ul><li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="comment">//获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.获取全部申明的方法!</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历这些方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    + method.getParameterCount()+<span class="string">&quot;-&gt;&quot;</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">// c.触发方法执行!</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> run.invoke(d);</span><br><span class="line">        System.out.println(o);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力反射！</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//参数一：被触发方法所在的对象  参数二：方法需要的入参值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> eat.invoke(d,<span class="string">&quot;肉&quot;</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span>&#123;System.out.println(<span class="string">&quot;狗吃&quot;</span>+name);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;在吉山区有一只单身狗！&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h2><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p><ol><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        scores.add(<span class="number">99.3</span>);</span><br><span class="line">        scores.add(<span class="number">199.3</span>);</span><br><span class="line">        scores.add(<span class="number">89.5</span>);</span><br><span class="line">        <span class="comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span></span><br><span class="line">        <span class="comment">// a.先得到集合对象的Class文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> scores.getClass();</span><br><span class="line">        <span class="comment">// b.从ArrayList的Class对象中定位add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        <span class="comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span></span><br><span class="line">        add.invoke(scores, <span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">        System.out.println(scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p><ul><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li><li><strong>父类中的注解是不能被子类继承的</strong></li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><hr><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">     <span class="comment">// 注解属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解的格式：@注解名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Book</span></span><br><span class="line"><span class="meta">@MyTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBook</span> &#123;</span><br><span class="line">    <span class="comment">//方法变量都可以注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h2><h3 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h3><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p><p>属性的格式：</p><ul><li>格式 1：数据类型 属性名()</li><li>格式 2：数据类型 属性名() default 默认值</li></ul><p>属性适用的数据类型:</p><ul><li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li><li>以上类型的数组形式都支持</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span> &#123;</span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span></span><br><span class="line"><span class="meta">     price = 19.9 , address = &quot;北京&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义一个注解</span></span><br><span class="line"><span class="meta">@interface</span> MyBook&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String[] authors(); <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;武汉&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p>注解的特殊属性名称：value</p><ul><li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li><li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Book(&quot;/deleteBook.action&quot;)</span></span><br><span class="line"><span class="meta">@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是 sun 公司提供的，用来注解自定义注解</p><p>元注解有四个：</p><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">    <span class="comment">// @MyTest // 只能注解方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 申明只能注解方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 申明注解从写代码一直到运行还在，永远存活！！</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>注解解析相关的接口：</p><ul><li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li><li>AnnotatedElement：该接口定义了与注解解析相关的方法</li><li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li></ul><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定位Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// 2.判断这个类上是否使用了某个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="comment">// 3.获取这个注解对象</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)c.getDeclarAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.authors()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)run.getDeclaredAnnotation(Book.class);</span><br><span class="line">           sout(上面的三个);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;张三&quot;,&quot;李四&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line">    <span class="meta">@Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;王五&quot;,&quot;小六&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">// 类和成员方法上使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解永久存活</span></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] authors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础(全)</title>
      <link href="/2023/03/04/Java/java/"/>
      <url>/2023/03/04/Java/java/</url>
      
        <content type="html"><![CDATA[<h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table><thead><tr><th align="center"></th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中，方法外</td><td align="center">方法中或者方法的形参</td><td align="center">在类中，方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无，赋值后才能使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方法</td><td align="center">对象调用</td><td align="center"></td><td align="center">对象调用，类名调用</td></tr><tr><td align="center">存储位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区（JDK8 以后移到堆中）</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center"></td><td align="center">类变量，静态成员变量</td></tr></tbody></table><p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p><p><a href="https://www.bilibili.com/video/BV1TE41177m">参考视频</a></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li><li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li><li>默认值是 <code>0</code></li><li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li><li>例子：<code>byte a = 100，byte b = -50</code></li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li><li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li><li>默认值是 <code>0</code></li><li>例子：<code>short s = 1000，short r = -20000</code></li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li><li>一般地整型变量默认为 int 类型</li><li>默认值是 <code>0</code></li><li>例子：<code>int a = 100000, int b = -200000</code></li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li><li>这种类型主要使用在需要比较大整数的系统上</li><li>默认值是 <code> 0L</code></li><li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li><li>float 在储存大型浮点数组的时候可节省内存空间</li><li>默认值是 <code>0.0f</code></li><li>浮点数不能用来表示精确的值，如货币</li><li>例子：<code>float f1 = 234.5F</code></li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li><li>浮点数的默认类型为 double 类型</li><li>double 类型同样不能表示精确的值，如货币</li><li>默认值是 <code>0.0d</code></li><li>例子：<code>double d1 = 123.4</code></li></ul><p><strong>boolean：</strong></p><ul><li>boolean 数据类型表示一位的信息</li><li>只有两个取值：true 和 false</li><li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li><li>默认值是 <code>false</code></li><li>例子：<code>boolean one = true</code></li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li><li>最小值是 <code>\u0000</code>（即为 0）</li><li>最大值是 <code>\uffff</code>（即为 65535）</li><li>char 数据类型可以<strong>存储任何字符</strong></li><li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li></ul><h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul><li><p>float 与 double：</p><p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//1.1f 字面量才是 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> (<span class="type">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1245</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (<span class="type">int</span>) l2;</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换：</p><p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p><p>使用 +&#x3D; 或者 ++ 运算符会执行类型转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;<span class="comment">//s1++;</span></span><br><span class="line"><span class="comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span></span><br><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p><p>包装类的作用：</p><ul><li>包装类作为类首先拥有了 Object 类的方法</li><li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）</span><br><span class="line"><span class="type">byte</span>                      Byte</span><br><span class="line"><span class="type">short</span>                     Short</span><br><span class="line"><span class="type">int</span>                       Integer</span><br><span class="line"><span class="type">long</span>                      Long</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>                     Float</span><br><span class="line"><span class="type">double</span>                    Double</span><br><span class="line"><span class="type">char</span>                      Character</span><br><span class="line"><span class="type">boolean</span>                   Boolean</span><br></pre></td></tr></table></figure><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p><ul><li><p>可以把基本数据类型的值转换成字符串类型的值</p><ol><li>调用 toString() 方法</li><li>调用 Integer.toString(基本数据类型的值) 得到字符串</li><li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li></ol></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p><ol><li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li><li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClass02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.把基本数据类型的值转成字符串</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="comment">// a.调用toString()方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr</span> <span class="operator">=</span> it.toString();</span><br><span class="line">        System.out.println(itStr+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr1</span> <span class="operator">=</span> Integer.toString(it);</span><br><span class="line">        System.out.println(itStr1+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr2</span> <span class="operator">=</span> it + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(itStr2+<span class="number">1</span>);<span class="comment">// 1001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.valueOf(numStr);</span><br><span class="line">        System.out.println(numInt+<span class="number">1</span>);<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">doubleStr</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleDb</span> <span class="operator">=</span> Double.valueOf(doubleStr);</span><br><span class="line">        System.out.println(doubleDb+<span class="number">0.1</span>);<span class="comment">//100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul><li><p>有了基本数据类型，为什么还要引用数据类型？</p><blockquote><p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p><p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p></blockquote></li><li><p>引用数据类型那么好，为什么还用基本数据类型？</p><blockquote><p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p></blockquote></li><li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p><blockquote><p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p></blockquote></li><li><p>&#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值<br>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</p></blockquote></li></ul><h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p><p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackegeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">12</span> ;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> a ;   <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 引用数据类型的默认值可以为null</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c ;      <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(<span class="number">12</span>);  <span class="comment">// 手工装箱！</span></span><br><span class="line">        <span class="comment">// Integer it1 = new Integer(12); // 手工装箱！</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="number">111</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it33</span> <span class="operator">=</span> it3.intValue(); <span class="comment">// 手工拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 【缓存池】，本质上是一个数组</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li><p>new Integer(123)：每次都会新建一个对象</p></li><li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><p><strong>基本类型对应的缓存池如下：</strong></p><ul><li>Boolean values true and false</li><li>all byte values</li><li>Short values between -128 and 127</li><li>Long values between -128 and 127</li><li>Integer values between -128 and 127</li><li>Character in the range \u0000 to \u007F (0 and 127)</li></ul><p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 自动装箱，底层调用 Integer.valueOf(1)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// false，因为缓存池最大127</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p><ul><li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li><li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li></ul><p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p><ul><li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li><li>print：<code>PrintStream.write()</code></li></ul><blockquote><p>使用引用数据类型的API</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p><p>创建数组：</p><ul><li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li><li>数据类型 数组名[]：<code>int arr[]</code></li></ul><p>静态初始化：</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li><li>数据类型[] 数组名 &#x3D; {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li></ul><p>动态初始化</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li></ul><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul><li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p></li><li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p></li><li><p><strong>赋值：</strong><code>arr[0] = 10</code></p></li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给 CPU 使用</td></tr><tr><td>本地方法栈</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区</td><td>存储可以运行的 class 文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new 来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td></tr></tbody></table><p>内存分配图：<strong>Java 数组分配在堆内存</strong></p><ul><li><p>一个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>两个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>多个数组指向相同内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4></li><li><p>索引越界异常：ArrayIndexOutOfBoundsException </p></li><li><p>空指针异常：NullPointerException </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p><p>解决方案：给数组一个真正的堆内存空间引用即可</p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4></li></ul><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p><p>初始化：</p><ul><li><p>动态初始化：<code>数据类型[][] 变量名 = new 数据类型[m][n]</code>，<code>int[][] arr = new int[3][3]</code></p><ul><li>m 表示这个二维数组，可以存放多少个一维数组，行</li><li>n 表示每一个一维数组，可以存放多少个元素，列</li></ul></li><li><p>静态初始化:<code>数据类型[][] 变量名 = new 数据类型[m][n]&#123;&#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125;&#125; </code></p><ul><li><code>数据类型[][] 变量名 = &#123;&#123;元素1, 元素2...&#125;, &#123;元素1, 元素2...&#125;...&#125;`  * `int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li></ul></li></ul><p>遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        步骤:</span></span><br><span class="line"><span class="comment">            1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line"><span class="comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(arr[i]);</span></span><br><span class="line">            <span class="comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line">            <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>i++ 与 ++i 的区别？</p><p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p></li><li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p><p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p><p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p></li><li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p></li><li><p>同或：两位相同为 1，相异为 0</p></li><li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p></li><li><p>break：跳出一层循环</p></li><li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p><ul><li><p>正数的原码反码补码相同，最高位为 0</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure></li><li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">100</span> 原码:<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span><span class="comment">//32位</span></span><br><span class="line">-<span class="number">100</span> 反码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011011</span></span><br><span class="line">-<span class="number">100</span> 补码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011100</span></span><br></pre></td></tr></table></figure><p>补码 → 原码：符号位不变，其余位置取反加 1</p></li></ul><p>运算符：</p><ul><li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li><li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li><li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li></ul><p>运算规则：</p><ul><li><p>正数的左移与右移，空位补 0</p></li><li><p>负数原码的左移与右移，空位补 0</p><p>负数反码的左移与右移，空位补 1</p><p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p></li><li><p>无符号移位，空位补 0</p></li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p><ul><li>形式参数，用于定义方法的时候使用的参数，只能是变量</li><li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li></ul><p>实参：调用方法时传递的数据可以是常量，也可以是变量</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p><p>格式：数据类型… 参数名称</p><p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p><p>可变参数的注意事项：</p><ul><li>一个形参列表中可变参数只能有一个</li><li>可变参数必须放在形参列表的<strong>最后面</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">sum(); <span class="comment">// 可以不传输参数。</span></span><br><span class="line">sum(<span class="number">10</span>); <span class="comment">// 可以传输一个参数。</span></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 可以传输多个参数。</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">90</span>&#125;); <span class="comment">// 可以传输一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p><p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p><p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p><h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line"><span class="comment">//方法体;</span></span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 (参数) ;</span><br></pre></td></tr></table></figure><ul><li>方法名：调用方法时候使用的标识</li><li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li><li>方法体：完成功能的代码块</li><li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li></ul><p>如果方法操作完毕</p><ul><li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li><li>非 void 类型的方法，推荐用变量接收调用</li></ul><p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>方法不能嵌套定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p><ol><li>多个方法在<strong>同一个类</strong>中</li><li>多个方法具有<strong>相同的方法名</strong></li><li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li></ol><p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p><p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p><p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">/*正确格式*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ul><li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li><li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li><li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li></ul><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法，选取的第二阶段</span></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span></span><br><span class="line">    </span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span></span><br><span class="line">       <span class="comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此不提倡可变长参数方法的重载</strong></p><h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p><ul><li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li><li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p><p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p><ul><li><p>基本数据类型：形式参数的改变，不影响实际参数</p><p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">change(number);</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">number = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型：形式参数的改变，影响实际参数的值</p><p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p><p>定义枚举的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">第一行都是罗列枚举实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的特点：</p><ul><li>枚举类是用 final 修饰的，枚举类不能被继承</li><li>枚举类默认继承了 java.lang.Enum 枚举类</li><li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li><li>枚举类相当于是多例设计模式</li><li>每个枚举项都是一个实例，是一个静态成员变量</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E  o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <T> T  valueOf(Class<T> type,String  name)</T></T></td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类的编译以后源代码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Season&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season[] values();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>API 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        <span class="type">Season</span> <span class="variable">s</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(s);<span class="comment">//SPRING</span></span><br><span class="line">        System.out.println(s.ordinal()); <span class="comment">// 0，该值代表索引，summer 就是 1</span></span><br><span class="line">        s.s.doSomething();</span><br><span class="line">        <span class="comment">// 获取全部枚举</span></span><br><span class="line">        Season[] ss = Season.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Season.SPRING.compareTo(Season.WINTER);</span><br><span class="line">        System.out.println(result);<span class="comment">//-3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p><p>面向对象三大特征：<strong>封装，继承，多态</strong></p><p>两个概念：类和对象</p><ul><li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li><li>对象：是真实存在的实例， 实例 &#x3D;&#x3D; 对象，<strong>对象是类的实例化</strong></li><li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li><li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li><li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分</span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line"><span class="number">1.</span>成员变量(Field):  描述类或者对象的属性信息的。</span><br><span class="line">        <span class="number">2.</span>成员方法(Method):描述类或者对象的行为信息的。</span><br><span class="line"><span class="number">3.</span>构造器(Constructor): 初始化一个对象返回。</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">  &#125;</span><br><span class="line">类中有且仅有这五种成分，否则代码报错！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：初始化类的一个对象返回</p><p>分类：无参数构造器，有参数构造器</p><p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p><p>构造器初始化对象的格式：类名 对象名称 &#x3D; new 构造器</p><ul><li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li><li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li></ul><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p><p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p><p>导包格式：<code>import 包名.类名</code></p><p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p><p>封装最初的目的：提高代码的安全性和复用性，组件化</p><p>封装的步骤：</p><ol><li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li><li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li></ol><p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p><ul><li>this 关键字代表了当前对象的引用</li><li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li><li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li><li>this 可以区分变量是访问的成员变量还是局部变量</li></ul><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p><p>按照有无 static 修饰，成员变量和方法可以分为：</p><ul><li><p>成员变量：</p><ul><li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li><li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li></ul></li><li><p>成员方法：</p><ul><li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li><li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li></ul></li></ul><h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p><ul><li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p><ul><li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li><li>对象.静态成员变量（不推荐）</li></ul></li><li><p>实例成员变量：</p><ul><li>对象.实例成员变量（先创建对象）</li></ul></li></ul><p>成员方法的访问语法：</p><ul><li><p>静态方法：有 static 修饰，属于类</p><ul><li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li><li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li></ul></li><li><p>实例方法：无 static 修饰，属于对象</p><ul><li>对象.实例方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// a.类名.静态方法</span></span><br><span class="line">        Student.inAddr();</span><br><span class="line">        inAddr();</span><br><span class="line">        <span class="comment">// b.对象.实例方法</span></span><br><span class="line">        <span class="comment">// Student.eat(); // 报错了！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        sea.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>访问问题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li><li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li><li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li><li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li><li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li><li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p><ul><li>被继承的类称为：父类&#x2F;超类</li><li>继承父类的类称为：子类</li></ul><p>继承的作用：</p><ul><li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li><li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li><li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li></ul><p>继承的特点：</p><ol><li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li><li><strong>单继承</strong>：一个类只能继承一个直接父类</li><li>多层继承：一个类可以间接继承多个父类（家谱）</li><li>一个类可以有多个子类</li><li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li></ol><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类不能继承父类的东西：</p><ul><li>子类不能继承父类的构造器，子类有自己的构造器</li><li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li><li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// c.run();</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        System.out.println(Cat.schoolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span><span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p><p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wmain</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();w</span><br><span class="line">        w.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类狼&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部name</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类对象的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的</span></span><br><span class="line">        System.out.println(name1); <span class="comment">// 父类的</span></span><br><span class="line">        <span class="comment">//System.out.println(name2); // 报错。子类父类都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类动物名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;父类&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p><p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p><p>方法重写的校验注解：@Override</p><ul><li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li><li>@Override 优势：可读性好，安全，优雅</li></ul><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul><p>继承中的隐藏问题：</p><ul><li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li><li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        w.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>为什么子类构造器会先调用父类构造器？</p><ol><li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li><li>参考 JVM → 类加载 → 对象创建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的有参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么 Java 是单继承的？</strong></p><p>答：反证法，假如 Java 可以多继承，请看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> , B &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.test(); </span><br><span class="line">        <span class="comment">// 出现了类的二义性！所以Java不能多继承！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p><p>总结与拓展：</p><ul><li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li><li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li></ul><p>注意：</p><ul><li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li><li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li><li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;天蓬元帅&quot;</span>, <span class="number">1000</span> );</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;齐天大圣&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;清华大学&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Study</span> <span class="keyword">extends</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Study</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age , schoolName) ; </span><br><span class="line">       <span class="comment">// 根据参数匹配调用父类构造器</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String schoolName ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 借用兄弟构造器的功能！</span></span><br><span class="line">        <span class="built_in">this</span>(name , age , <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......get + set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p><ul><li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li><li>final 可以修饰方法，方法就不能被重写</li><li>final 修饰变量总规则：变量有且仅能被赋值一次</li></ul><p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p><p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p><p>final 修饰静态成员变量可以在哪些地方赋值：</p><ol><li><p>定义的时候赋值一次</p></li><li><p>可以在静态代码块中赋值一次</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line"><span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span></span><br><span class="line">        SCHOOL_NAME1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p><p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p><ol><li>定义的时候赋值一次</li><li>可以在实例代码块中赋值一次</li><li>可以在每个构造器中赋值一次</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在实例代码块中赋值一次。</span></span><br><span class="line">        name1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造器赋值一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalDemo</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalDemo</span>();</span><br><span class="line">        <span class="comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p></blockquote><p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p><p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p><p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;🐕跑&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p><ul><li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li><li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li></ul><blockquote><p>抽象在学术上本身意味着不能实例化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！</span></span><br><span class="line">        <span class="comment">//a.run(); // 抽象方法不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、static 与 abstract 能同时使用吗？</p><p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p><p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作文模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoMa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaoMa.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeText</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;\t内容&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.写一个模板类：代表了作文模板。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;\t\t\t\t\t标题&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;\t开头&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;\t结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(title+<span class="string">&quot;\n&quot;</span>+start);</span><br><span class="line">        System.out.println(writeText());</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正文部分定义成抽象方法，交给子类重写！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">writeText</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p><p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 修饰符 interface 接口名称&#123;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p></li><li><p>静态方法：静态方法必须有方法体</p></li><li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//默认补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p><ul><li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li><li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li><li>接口与接口继承关系：<strong>多继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">修饰符 interface 接口名 extend 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多个接口的使用注意事项：</p><ol><li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p></li><li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p></li><li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p></li><li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.run();</span><br><span class="line">        s.rule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Food</span>, Person&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以直接 interface Person extend Food,</span></span><br><span class="line"><span class="comment">//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p><ul><li>默认方法（就是普通实例方法）<ul><li>必须用 default 修饰，默认会 public 修饰</li><li>必须用接口的实现类的对象来调用</li><li>必须有默认实现</li></ul></li><li>静态方法<ul><li>默认会 public 修饰</li><li>接口的静态方法必须用接口的类名本身来调用</li><li>调用格式：ClassName.method()</li><li>必须有默认实现</li></ul></li><li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        m.run();</span><br><span class="line">        m.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span></span><br><span class="line">        InterfaceJDK8.inAddr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法！！</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// a.默认方法（就是之前写的普通实例方法）</span></span><br><span class="line">    <span class="comment">// 必须用接口的实现类的对象来调用。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始跑步🏃‍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.静态方法</span></span><br><span class="line">    <span class="comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们在武汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span></span><br><span class="line">    <span class="comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>默认的方法实现</td><td>可以有默认的方法实现</td><td>接口完全是抽象的，jdk8 以后有默认的实现</td></tr><tr><td>实现</td><td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常Java类的区别</td><td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td><td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td></tr><tr><td>main方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口可以继承一个或多个其它接口，接口不可继承类</td></tr><tr><td>速度</td><td>比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td></tr><tr><td>添加新方法</td><td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td><td>如果往接口中添加方法，那么必须改变实现该接口的类</td></tr></tbody></table><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p><p>多态的格式：</p><ul><li>父类类型范围 &gt; 子类类型范围</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p>多态的执行：</p><ul><li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li><li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li></ul><p>多态的使用规则：</p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>存在方法重写</li></ul><p>多态的优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li><li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li></ul><p>多态的劣势： </p><ul><li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.run();</span><br><span class="line">        <span class="comment">//c.eat();//报错  编译看左边 需要强转</span></span><br><span class="line">        go(c);</span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Dog</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal d)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote><p>基本数据类型的转换：</p><ol><li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li><li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li></ol></blockquote><p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p><p><strong>父类引用指向子类对象</strong></p><ul><li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li><li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;<span class="comment">// 向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p><ul><li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li><li>强制类型转换的格式：<strong>类型 变量名称 &#x3D; (类型)(对象或者变量)</strong></li><li>有继承&#x2F;实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Dog d = (Dog)a;</span></span><br><span class="line">        <span class="comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p><p>概念：定义在一个类里面的类就是内部类</p><p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p><p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p><p>静态内部类中的成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>特点与外部类是完全一样的，只是位置在别人里面</li><li>可以定义静态成员</li></ul><p>静态内部类的访问格式：外部类名称.内部类名称</p><p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称.内部类构造器</p><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?可以，外部类的静态成员只有一份，可以被共享<br>   静态内部类中是否可以直接访问外部类的实例成员?不可以，外部类的成员必须用外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量</span></span><br><span class="line">         System.out.println(age);</span><br><span class="line">         <span class="comment">//System.out.println(salary);报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p><p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p><p>实例内部类的访问格式：外部类名称.内部类名称</p><p>创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类构造器.new 内部构造器</p><ul><li><code>Outter.Inner in = new Outter().new Inner()</code></li></ul><p><strong>实例内部类可以访问外部类的全部成员</strong></p><ul><li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li><li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p><p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        class&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;</span><br><span class="line"><span class="comment">//方法重写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类不能定义静态成员</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li><li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);</span><br><span class="line">                <span class="comment">//System.out.println(n);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.run();</span><br><span class="line">        a.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始go~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p><table><thead><tr><th>四种修饰符访问权限</th><th align="center">private</th><th align="center">缺省</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下的子类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下其他类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的子类中</td><td align="center">X</td><td align="center">X</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的其他类中</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">√</td></tr></tbody></table><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见</li><li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代码块特点： <ul><li>必须有 static 修饰，只能访问静态资源</li><li>会与类一起优先加载，且自动触发执行一次</li></ul></li><li>静态代码块作用：<ul><li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li><li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块,属于类，与类一起加载一次!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">// 在静态代码块中进行静态资源的初始化操作</span></span><br><span class="line">        schoolName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法被执行&quot;</span>);</span><br><span class="line">        System.out.println(schoolName);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块被触发执行~~~~~~~</span></span><br><span class="line"><span class="comment">main方法被执行</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">[3, 4, 5] */</span></span><br></pre></td></tr></table></figure><h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例代码块的特点：</p><ul><li>无 static 修饰，属于对象</li><li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li></ul></li><li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;代码块&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">()</span>&#123; &#125;<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeDemo</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">        System.out.println(c.name);</span><br><span class="line">        System.out.println(c.lists);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeDemo02</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p><p>Object 类常用方法：</p><ul><li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul><li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li><li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li></ul></li><li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li><li><code>protected Object clone()</code>：创建并返回此对象的副本</li></ul><p>只要两个对象的内容一样，就认为是相等的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">           sex == student.sex &amp;&amp;</span><br><span class="line">           Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：&#x3D;&#x3D; 和 equals 的区别</p><ul><li>&#x3D;&#x3D; 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li><li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li></ul><p>hashCode 的作用：</p><ul><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li><li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li></ul><h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p><p>深浅拷贝（克隆）的概念：</p><ul><li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p><p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p></li><li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p></li></ul><p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p><ul><li><p>Clone &amp; Copy：<code>Student s = new Student</code></p><p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p><p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p></li><li><p>Shallow Clone &amp; Deep Clone：</p><p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p><ul><li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li><li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p><p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        s.date = (Date) date.clone();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>SDP → 创建型 → 原型模式</p><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p><p>Objects 的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line"><span class="comment">// 进行非空判断，从而可以避免空指针异常</span></span><br><span class="line"><span class="keyword">return</span> a == b || a != <span class="literal">null</span> &amp;&amp; a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* `public static boolean isNull(Object obj)`：判断变量是否为 null ，为 null 返回 true</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象)`：返回参数中对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象, 默认字符串)`：返回对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class ObjectsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = null;</span><br><span class="line">        Student s2 = new Student();</span><br><span class="line">        System.out.println(Objects.equals(s1 , s2));//推荐使用</span><br><span class="line">        // System.out.println(s1.equals(s2)); // 空指针异常</span><br><span class="line"> </span><br><span class="line">        System.out.println(Objects.isNull(s1));</span><br><span class="line">        System.out.println(s1 == null);//直接判断比较好</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p><p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p><ul><li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p></li><li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p></li><li><p><code>public int length()</code>：返回此字符串的长度</p></li><li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p></li><li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p></li><li><p><code>public char charAt(int index)</code>：取索引处的值</p></li><li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p></li><li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p></li><li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p></li><li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p></li><li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p></li><li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p></li><li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p></li><li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>-<span class="number">78</span>;</span><br><span class="line">s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p><ul><li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li><li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li><li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li></ul><p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p><ul><li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li><li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li></ul><p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p><ul><li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li><li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;"></li></ul><p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p><ul><li><p>对象 1：new StringBuilder()</p></li><li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p></li><li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;"></li><li><p>StringBuilder 的 toString()：</p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 6：new String(“ab”)</li><li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li></ul><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool &#x2F; StringTable &#x2F; 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p><ul><li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li><li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li><li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li><li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li></ul><h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p><ul><li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li><li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li></ul><p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 串池</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">// 返回的是堆内地址</span></span><br><span class="line">        <span class="comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        <span class="comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值</li><li>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</li></ul><p>结论：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 仅放入串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">// 仅放入堆</span></span><br><span class="line"><span class="comment">// 上面两条指令的结果和下面的 效果 相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2 == str2.intern());<span class="comment">//false，字符串池中存在，直接返回已经存在的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">launcher_name</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_name</span> <span class="operator">=</span> <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_profile_name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221-b11&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p><p>演示 StringTable 位置：</p><ul><li><p><code>-Xmx10m</code> 设置堆内存 10m</p></li><li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p></li><li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(j).intern());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p><h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p><ul><li><p>调整 -XX:StringTableSize&#x3D;桶个数，数量越少，性能越差</p></li><li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//很多数据</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul><li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li><li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li><li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li><li>防止子类继承，破坏 String 的 API 的使用</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p><ul><li>String : <strong>不可变</strong>的字符序列，线程安全</li><li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li><li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li></ul><p>相同点：底层使用 char[] 存储</p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li><li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li></ul><p>常用API : </p><ul><li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li><li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li><li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li></ul><p>存储原理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//new byte[16] </span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure><p>append 源码：扩容为二倍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span></span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到目标字符数组中</span></span><br><span class="line"><span class="comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p><p>常用API：</p><ul><li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li><li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li><li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//按照数字顺序排列指定的数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//1,数组必须有序</span></span><br><span class="line">        <span class="comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span></span><br><span class="line">        <span class="comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span></span><br><span class="line">            <span class="comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p><p>使用步骤：</p><ol><li><p>导入包：<code>import java.util.Random</code></p></li><li><p>创建对象：<code>Random r = new Random()</code></p></li><li><p>随机整数：<code>int num = r.nextInt(10)</code></p><ul><li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li><li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li></ul></li><li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p></li></ol><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p><p>静态方法：</p><ul><li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p></li><li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p></li><li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p><ul><li>参数一：原数组</li><li>参数二：从原数组的哪个位置开始赋值</li><li>参数三：目标数组</li><li>参数四：从目标数组的哪个位置开始赋值</li><li>参数五：赋值几个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.exit(0); // 0代表正常终止!!</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//定义sdf 按照格式输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">System.out.println( (endTime - startTime)/<span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);<span class="comment">//程序用时</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> ,<span class="number">60</span> ,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span></span><br><span class="line">        <span class="comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">2</span>, arr2, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p><ul><li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li></ul><p>方法：</p><ul><li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li></ul><p>时间记录的两种方式：</p><ol><li>Date 日期对象</li><li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s &#x3D; 1000ms</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + <span class="number">121</span>*<span class="number">1000</span>;<span class="comment">//过121s是什么时间</span></span><br><span class="line">        System.out.println(time);<span class="comment">//1602856875485</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d1);<span class="comment">//Fri Oct 16 22:01:15 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="comment">//运行一万次输出需要多长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p><ol><li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li><li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li></ol><p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p><p>SimpleDateFormat  简单日期格式化类：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li><li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li><li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li><li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li></ul><blockquote><p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);</span></span><br><span class="line"><span class="string">    String time = sdf.format(date);</span></span><br><span class="line"><span class="string">    System.out.println(time);//2020-10-18 19:58:34</span></span><br><span class="line"><span class="string">    //过121s后是什么时间</span></span><br><span class="line"><span class="string">    long time = date.getTime();</span></span><br><span class="line"><span class="string">    time+=121;</span></span><br><span class="line"><span class="string">    System.out.println(sdf.formate(time));</span></span><br><span class="line"><span class="string">    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致</span></span><br><span class="line"><span class="string">    Date newDate = sdf.parse(d);</span></span><br><span class="line"><span class="string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p><p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p><p>Calendar 的方法：</p><ul><li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li><li><code>public int get(int field)</code>：取日期中的某个字段信息</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li><li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li><li><code>public final Date getTime()</code>：拿到此刻日期对象</li><li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInsance(); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> rightNow.get(Calendar.YEAR);<span class="comment">//获取年</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> rightNow.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月要+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    rightNow.set(Calendar.YEAR , <span class="number">2099</span>);<span class="comment">//修改某个字段</span></span><br><span class="line">    rightNow.add(Calendar.HOUR , <span class="number">15</span>);<span class="comment">//加15小时  -15就是减去15小时</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> rightNow.getTime();<span class="comment">//日历对象</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rightNow.getTimeInMillis();<span class="comment">//时间毫秒值</span></span><br><span class="line">    <span class="comment">//700天后是什么日子</span></span><br><span class="line">    rightNow.add(Calendar.DAY_OF_YEAR , <span class="number">701</span>);</span><br><span class="line">    Date <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(sdf.format(d));<span class="comment">//输出700天后的日期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p><ul><li>LocalDate       表示日期（年月日）  </li><li>LocalTime       表示时间（时分秒）</li><li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li></ul><p>构造方法：</p><ul><li>public static LocalDateTime now()：获取当前系统时间 </li><li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li></ul><p>常用API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中的第几天（1-31）</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中的第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr><tr><td>public LocalDate  toLocalDate()</td><td>转换成为一个 LocalDate 对象（年月日）</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成为一个 LocalTime 对象（时分秒）</td></tr><tr><td>public String format(指定格式)</td><td>把一个 LocalDateTime 格式化成为一个字符串</td></tr><tr><td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td><td>把一个日期字符串解析成为一个 LocalDateTime 对象</td></tr><tr><td>public static DateTimeFormatter ofPattern(String pattern)</td><td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> localDateTime.format(pattern);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(s, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears (long years)</td><td>添加或者减去年</td></tr><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年</td></tr></tbody></table><p><strong>时间间隔</strong> Duration 类API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public int getYears()</td><td>获得这段时间的年数</td></tr><tr><td>public int getMonths()</td><td>获得此期间的总月数</td></tr><tr><td>public int getDays()</td><td>获得此期间的天数</td></tr><tr><td>public long toTotalMonths()</td><td>获取此期间的总月数</td></tr><tr><td>public static Durationbetween(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public long toSeconds()</td><td>获得此时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获得此时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获得此时间间隔的纳秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate2);</span><br><span class="line">        System.out.println(period);<span class="comment">//P28Y11M11D</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime2);</span><br><span class="line">        System.out.println(duration);<span class="comment">//PT21H57M58S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p><p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取 a 的 b 次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td>public static int max(int a,int b)</td><td>返回较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回较小值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数。</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">4.00000001</span>));<span class="comment">//4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">4.99999999</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">    <span class="comment">//取一位整数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//取一位整数和两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">    <span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">    <span class="comment">//取所有整数部分</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">    <span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));<span class="comment">//2.99792E8</span></span><br><span class="line">    <span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));<span class="comment">//29.9792E7</span></span><br><span class="line">    <span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));<span class="comment">//299,792,458</span></span><br><span class="line">    <span class="comment">//将格式嵌入文本</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p><p>构造方法：</p><ul><li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li><li><code>public BigDecimal(double val)</code></li><li><code>public BigDecimal(String val)</code></li></ul><p>常用API：</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li><li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li><li><code>public int intValue()</code>：转为 int 其他类型相同</li><li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span></span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b ;</span><br><span class="line">        System.out.println(c);<span class="comment">//0.30000000000000004</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把浮点数转换成大数据对象运算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//a1.divide(b1);也可以</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>BigDecimal 是用来进行精确计算的</li><li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li><li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line"><span class="comment">//参数1：表示参与运算的BigDecimal 对象。</span></span><br><span class="line"><span class="comment">//参数2：表示小数点后面精确到多少位</span></span><br><span class="line"><span class="comment">//参数3：舍入模式  </span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_UP  进一法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_FLOOR 去尾法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p><p>比如检验 qq 号：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQRegex</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq!=<span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数</span></span><br><span class="line">&#125;<span class="comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 \ 本身</td></tr><tr><td>()</td><td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td></tr></tbody></table><h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td></tr><tr><td>\d</td><td>数字字符，0~9 中的任意一个，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于  [ ^0-9]</td></tr><tr><td>\w</td><td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td></tr><tr><td>\W</td><td>对\w取非，等价于[ ^\w]</td></tr><tr><td>\s</td><td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p><h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td></tr><tr><td>[a-d[m-p]]</td><td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td></tr><tr><td>[a-z&amp;&amp;[m-p]]</td><td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td></tr><tr><td>[^]</td><td>取反</td></tr></tbody></table><ul><li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p></li><li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p></li></ul><h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li><li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li></ul><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>X?</td><td>X 一次或一次也没，有相当于 {0,1}</td></tr><tr><td>X*</td><td>X 不出现或出现任意次，相当于 {0,}</td></tr><tr><td>X+</td><td>X 至少一次，相当于 {1,}</td></tr><tr><td>X{n}</td><td>X 恰好 n 次</td></tr><tr><td>{n,}</td><td>X 至少 n 次</td></tr><tr><td>{n,m}</td><td>X 至少 n 次，但是不超过 m 次</td></tr></tbody></table><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr></tbody></table><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p><ul><li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li><li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li></ul><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|  (分支结构)</td><td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td></tr><tr><td>()  (捕获组)</td><td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression)   非捕获组</td><td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td></tr></tbody></table><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p><ul><li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p></li><li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p></li><li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p></li><li><p>应用 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li><li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li><li>实例：43438n44</li></ul></li><li><p>应用 2：爬虫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//不匹配</span><br></pre></td></tr></table></figure></li></ul><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p><ul><li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p></li><li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p></li><li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>(?&#x3D;exp)</td><td>断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td>(?&lt;&#x3D;exp)</td><td>断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td>(?!exp)</td><td>断言此位置的后面不能匹配表达式exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言此位置的前面不能匹配表达式exp</td></tr></tbody></table></li></ul><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p><ul><li>IGNORECASE 忽略大小写模式<ul><li>匹配时忽略大小写。</li><li>默认情况下，正则表达式是要区分大小写的。</li></ul></li><li>SINGLELINE 单行模式<ul><li>整个文本看作一个字符串，只有一个开头，一个结尾。</li><li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li></ul></li><li>MULTILINE 多行模式<ul><li>每行都是一个字符串，都有开头和结尾。</li><li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li></ul></li></ul><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p><ul><li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li><li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li><li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li></ul><p>Matcher 类：</p><ul><li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li><li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li><li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li><li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);</span><br><span class="line"><span class="comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span></span><br><span class="line"><span class="comment">//System.out.println(b);//false</span></span><br><span class="line"><span class="comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line"><span class="comment">//System.out.println(b2);//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//asfsdf2</span></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//3323</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//group(),group(0)匹配整个表达式的子字符串</span></span><br><span class="line">System.out.println(m.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="comment">//不需要加多余的括号</span></span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aa232**ssd445&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">1</span>));<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">2</span>));<span class="comment">//aa     ssd</span></span><br><span class="line">            System.out.println(m.group(<span class="number">3</span>));<span class="comment">//232    445 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li><li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false 判断a是否在abc之外的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false 是否a是整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true 是否是字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));<span class="comment">//false 只能检验单个字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 验证。必须是数字和字符  必须是4位</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dsd22&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;A3dy&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机号码格式正确！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;.......&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1111@qq.com  zhy@pic.com.cn</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱格式正确！&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// .是任意字符 \\.就是点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li><li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 1.split的基础用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line"><span class="comment">// 以“，”分割成字符串数组</span></span><br><span class="line">    String[] nameArrs = names.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.split集合正则表达式做分割</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> <span class="string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;</span><br><span class="line">    <span class="comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span></span><br><span class="line">String[] nameArrs1 = names1.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用正则表达式定位出内容，替换成/</span></span><br><span class="line">System.out.println(names1.replaceAll(<span class="string">&quot;\\w+&quot;</span>,<span class="string">&quot;/&quot;</span>));<span class="comment">//风清扬/张无忌/周芷若</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">System.out.println(names3.replaceAll(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;-&quot;</span>));<span class="comment">//风清扬-张无忌-周芷若</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2023/03/04/Java/java-high/" target="_blank">了解更多java高级内容</a></p><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识jvm内存模型</title>
      <link href="/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h1><p><img src="/../../images/jvm/jvm-memory/jvm_classloader.png" alt="jvm_classloader"></p><p>​    区别于Java内存模型，<strong>JVM内存模型是指JVM虚拟机在运行Java程序时，所使用的内存结构和管理方式。</strong>JVM内存模型包括以下几个部分：</p><ol><li><p>程序计数器(Program Counter Register)</p><p>​    Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>总的来说：<font color="red">每个线程都有一个程序计数器，用于记录当前执行的指令地址。</font></p></li><li><p>虚拟机栈(Java Virtual Machine Stacks)<br>每个线程都有一个虚拟机栈，用于存储<font color="red">局部变量、方法参数、方法返回值以及操作数栈。</font>每个方法在执行时都会创建一个栈帧，用于存储该方法的局部变量、操作数栈等信息。当该方法运行完后便出栈。当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError,如果虚拟机栈可以动态扩展，若无法申请到足够的内存，抛出OutOfMemoryError异常。<br><img src="/../../images/jvm/jvm-memory/2022-12-03-11-13-42.png" alt="2022-12-03-11-13-42"></p></li><li><p>本地方法栈(Native Method Stack)<br> JVM 为 Native 方法执行而开辟的一块栈空间，<font color="red">用于存储本地方法的参数和局部变量等信息。</font>本地方法栈与虚拟机栈类似，都是栈结构，但两者是不同的概念和实现方式。（本地方法栈不受 JVM 内存管理机制的控制）</p></li><li><p>堆(Heap)<br>又称为GC堆，垃圾收集器管理的主要区域，是所有线程共享的内存区域，<font color="red">用于存储Java对象实例和数组。</font>现在的收集器基本都采用分代收集算法，即java堆又可以细分为：新生代和老年代。其中新生代又分为 Eden 区、Survivor 区 1 和 Survivor 区 2。堆内存的大小可以通过JVM启动参数进行调整。JVM 会通过垃圾回收机制来自动管理堆内存，包括垃圾收集和内存分配等操作。 </p></li><li><p>方法区(Method Area)<br>方法区也是所有线程共享的内存区域，<font color="red">用于存储类信息、常量池、静态变量、即时编译器编译后的代码等。</font>该区 是 JVM 内存模型中唯一没有规定垃圾回收方式的区域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm内存布局/内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载</title>
      <link href="/2023/03/03/jvm/jvm-classloader/"/>
      <url>/2023/03/03/jvm/jvm-classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h2><p><img src="/../../images/jvm/jvm-classloader/jvm_classloader.png" alt="01_2"></p><p>完整：</p><p><img src="/../../images/jvm/jvm-classloader/1677831036747.png" alt="1677831036747"></p><h2 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h2><p><img src="/../../images/jvm/jvm-classloader/1677831559346.png" alt="1677831519784"></p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>​    Java类加载是指将类的字节码文件加载到 JVM 中，使得这些类在程序运行时可以被使用。Java类加载的过程主要包括三个阶段：加载、链接（连接）和初始化。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><strong>加载阶段</strong></h4><p>​    在加载阶段，JVM会查找并加载类的字节码文件。首先，JVM会通过类的全限定名查找类文件，如果找不到，则会抛出ClassNotFoundException异常；如果找到了，就会将字节码文件加载到内存中，并在方法区中生成一个代表这个类的Class对象，这个过程也被称为类的装载,如 <a href="#classloader">类加载器ClassLoader</a> 的第一个图片。</p><p>​    Java类的加载是通过类加载器（ClassLoader）来完成的。类加载器负责查找和加载类的字节码文件，并生成表示这个类的Class对象。在加载阶段，JVM需要完成以下工作：</p><ul><li>通过类的全限定名查找字节码文件，并将其读入内存。</li><li>解析字节码文件，并生成表示这个类的Class对象。</li><li>在方法区中为这个类分配内存，并存储类的相关信息。<br>这工作在《深入理解Java虚拟机》第三版中的解释为：</li><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据<br>的访问入口。</li></ul><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><strong>链接阶段</strong></h4><p>​    在链接阶段，JVM会对类进行<strong>验证</strong>、<strong>准备</strong>和<strong>解析</strong>三个步骤：</p><p><font color="red">验证</font>：验证字节码文件是否符合Java语言规范以及JVM规范，包括语法检查、语义检查、字节码验证、符号引用验证等。如果验证不通过，则会抛出VerifyError异常。</p><p><font color="red">准备</font>：为类的静态变量分配内存，并设置初始值。这些变量在类加载时会被设置为默认值（0或null）。<strong>变量所使用的内存在方法区</strong></p><p><font color="red">解析</font>：将类中的符号引用（如类、方法、字段等）转换为直接引用。符号引用是一种符号形式的引用，需要通过解析才能转换为直接引用，以便JVM能够定位到对应的类、方法或字段。注意，该阶段可以在初始化后进行，如运行时需要动态绑定，则该阶段在初始完成后再进行。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h4><p>​    在初始化阶段，JVM会对类进行初始化，主要是执行类构造器方法（<clinit>()），静态变量的赋值和静态代码块的执行等。该构造器方法区别于类的构造函数或者说实例构造器（<init>()）方法，类构造器方法是类中的一个静态块，用于初始化静态变量或执行其他的类初始化操作。如果类没有静态变量或静态代码块，则初始化阶段会被跳过。</init></clinit></p><p>​    需要注意的是，类加载过程是按需加载的，即只有在需要使用类时才会进行加载。此外，JVM还提供了双亲委派机制，即先让父类加载器尝试加载类，如果父类加载器无法加载，则由当前类加载器进行加载。这种机制可以保证类的唯一性和安全性，避免重复加载和不同类加载器之间的类名冲突。</p><h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title=" 类加载器ClassLoader"></a><div id="classloader"> 类加载器ClassLoader</div></h2><p>​    <strong>.java</strong>文件通过编译后形成**.class**文件，在程序运行时使用该class文件，需要通过类加载器从内存加载进来处理。</p><p><img src="/../../images/jvm/jvm-classloader/1677832219825.png" alt="1677832219825"></p><p>​    在 JVM 中，类加载器用于查找、加载和链接Java类。Java虚拟机支持三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和系统类加载器（System Class Loader）。 </p><h3 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h3><p>​    启动类加载器是Java虚拟机内置的类加载器，负责加载Java核心类库，如java.lang和java.util等。启动类加载器是Java虚拟机内部实现的，不是Java类，因此无法用Java代码来实现和引用启动类加载器。该类加载器是用 C++ 实现，其他都是Java实现。</p><h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><p>​    扩展类加载器是Java虚拟机的内置类加载器之一，负责加载Java扩展库。Java扩展库包括Java虚拟机扩展机制所需的所有类，例如JNDI、JDBC和JavaMail等。扩展类加载器的父类加载器是启动类加载器。</p><h3 id="系统-x2F-应用程序类加载器（System-Class-Loader）"><a href="#系统-x2F-应用程序类加载器（System-Class-Loader）" class="headerlink" title="系统&#x2F;应用程序类加载器（System Class Loader）"></a>系统&#x2F;应用程序类加载器（System Class Loader）</h3><p>​    系统类加载器也称为应用类加载器，是Java虚拟机默认的类加载器，负责加载应用程序的类。系统类加载器通常从环境变量classpath或者Java命令的-cp选项指定的路径中查找类，它的父类加载器是扩展类加载器。</p><p>​    除了这三种内置类加载器之外，Java虚拟机还支持自定义类加载器。自定义类加载器可以实现特定的加载策略，例如从网络中动态加载类、从数据库中加载类或者从加密文件中加载类等。自定义类加载器必须继承 ClassLoader类，并重写findClass()方法，实现自己的类查找和加载策略。</p><p>​    <strong>需要注意的是，Java虚拟机中每个类加载器都有一个特定的命名空间，它只能加载它自己命名空间中的类。如果同一个类被不同的类加载器加载，那么它们在Java虚拟机中是不同的类，即使它们的字节码文件内容是相同的。这种机制可以保证类的唯一性和安全性，避免不同类加载器之间的类名冲突和安全隐患。</strong></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>​    由于类加载器存在层级关系，这种关系称为双亲委派模型。</p><p><img src="/../../images/jvm/jvm-classloader/1677850958450.png" alt="1677850958450"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>​    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器（Bootstrap ClassLoader）中，只有当父加载器反馈 自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 </p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>​    双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在某些特定情况下，可能需要打破双亲委派模型。具体方法如下：</p><ol><li>自定义类加载器</li></ol><p>​    自定义类加载器可以通过继承ClassLoader类并实现findClass()方法来打破双亲委派模型。如果一个类加载器自己能够完成类的加载任务，就不必委派给父类加载器，这种情况下可以打破双亲委派模型。</p><ol start="2"><li>线程上下文类加载器</li></ol><p>​    线程上下文类加载器可以通过Thread类的setContextClassLoader()方法来设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。在某些复杂的场景中，可能需要在不同的线程中使用不同的类加载器来加载类，这种情况下就需要使用线程上下文类加载器来打破双亲委派模型。</p><ol start="3"><li>OSGi和J2EE容器</li></ol><p>​    OSGi和J2EE容器等平台提供了自己的类加载器实现，可以在不同的模块中加载不同的类。这种情况下，打破双亲委派模型是必要的，否则会出现类加载失败或者类冲突等问题。</p><p><strong>需要注意的是，打破双亲委派模型可能会导致类的重复加载或者不同类加载器之间的类名冲突，从而导致程序运行出现问题。因此，在打破双亲委派模型时，需要谨慎考虑，确保程序的安全性和稳定性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初识类加载过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jwt</title>
      <link href="/2023/01/16/jwt/jwt/"/>
      <url>/2023/01/16/jwt/jwt/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h1><p><a href="https://jwt.io/introduction">官网jwt介绍</a></p><p>​JSON Web Token (JWT) is an open standard (<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the <strong>HMAC</strong> algorithm) or a public&#x2F;private key pair using <strong>RSA</strong> or <strong>ECDSA</strong>. </p><p>​翻译：JSON Web Token (JWT)是一个开放标准(rfc7519),它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥／私钥对进行签名 。</p><p>​通俗来说，JWT简称JSON Web Token，也就是通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p><h1 id="JWT能做什么"><a href="#JWT能做什么" class="headerlink" title="JWT能做什么"></a>JWT能做什么</h1><ol><li><p>授权</p><p>​这是使用JWT的最常见方案，一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。</p></li><li><p>信息交换</p><p>​JSON Web Token是在各方之间安全地<strong>传输信息</strong>的好方法。因为可以对JWT进行签名（例如，使用公钥／私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以<strong>验证内容是否遭到篡改</strong>。</p></li></ol><h1 id="为什么是JWT"><a href="#为什么是JWT" class="headerlink" title="为什么是JWT"></a>为什么是JWT</h1><h2 id="基于传统的Session认证"><a href="#基于传统的Session认证" class="headerlink" title="基于传统的Session认证"></a>基于传统的Session认证</h2><ol><li><p>认证方式<br>我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。 </p></li><li><p>认证流程<br><img src="/../images/jwt/1673842472937.png" alt="1673842472937"></p></li><li><p>暴露问题</p><ol><li><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p></li><li><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li><li><p>在前后端分离系统中就更加痛苦：如下图所示<br><img src="/../images/jwt/1673843150954.png" alt="1673843150954"></p><p>​也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是</p><p>sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</p></li></ol></li></ol><h2 id="基于JWT认证"><a href="#基于JWT认证" class="headerlink" title="基于JWT认证"></a>基于JWT认证</h2><p><img src="/../images/jwt/1673843325267.png" alt="1673843325267"></p><ol><li><p>认证流程</p><p>​首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p><p>​后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同111．zzz．xxx的字符串。</p><p>​后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</p><p>​前端在每次请求时将JWT放入HTTP Header中的Authorization位。（解决XSS和XSRF问题??????）</p><p>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p><p>​验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p></li><li><p>jwt优势</p><ul><li><p>简洁（Compact）：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p></li><li><p>自包含（Self—contained）：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li><li><p>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p></li><li><p>不需要在服务端保存会话信息，特别适用于分布式微服务。</p></li></ul></li></ol><h1 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h1><p>JWT通常为：xxxx.yyyyy.zzzzzHeader.Payload.Signature</p><ol><li>令牌组成<ol><li>标头(Header)<ul><li>标头通常由两部分组成：令牌的类型(即JWT)和所使用的签名算法，例如HMAC SHA256或RSA。它会使用Base64编码组成JWT结构的第一部分。<br>注意：<strong>Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span></span><br><span class="line"> <span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>有效载荷(Payload)<ul><li>令牌的第二部分是有效负载，其中包含声明。声明式有关实体(通常是用户)和其他数据的声明。同样的，它会使用Base64编码组成JWT结构的第二部分。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span></span><br><span class="line">  <span class="string">&quot;admin&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意：<strong>有效负载中不放用户敏感信息，如用户密码等</strong></li></ul></li><li>签名(Signature)<br>   前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过。（HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload) , secret)）<br>   签名的目的：最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</li></ol></li></ol><h1 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h1><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置90秒的对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.SECOND,<span class="number">90</span>);</span><br><span class="line"><span class="comment">//生成令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">    .withClaim(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;张三&quot;</span>)<span class="comment">//设置自定义用户名</span></span><br><span class="line">    .withExpiresAt(instance.getTime())<span class="comment">//设置过期时间</span></span><br><span class="line">    .sign(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>))；<span class="comment">//设置签名  保密  复杂</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出令牌</span></span><br><span class="line">System.out.println(token);</span><br></pre></td></tr></table></figure></li><li><p>根据令牌和签名解析数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>)).build;</span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名&quot;</span>+decodedJWT.getClaim(<span class="string">&quot;username&quot;</span>).asString());</span><br><span class="line">System.out.println(<span class="string">&quot;过期时间：&quot;</span>+decodedJWT.getExpiresAt());</span><br></pre></td></tr></table></figure></li><li><p>常见异常信息</p></li></ol><ul><li>SignatureVerificationException: 签名不一致异常</li><li>TokenExpiredException： 令牌过期异常</li><li>AlgorithmMismatchException:  算法不匹配异常</li><li>InvalidClaimException:  失效的payload异常</li></ul><ol start="5"><li><p>封装工具类<br>方式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtils</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SING</span> <span class="operator">=</span> <span class="string">&quot;hnalhjg&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    生成token   header.payload.sing</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getToken</span><span class="params">(Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.DATE,<span class="number">7</span>);<span class="comment">//默认7天过期</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建jwt builder</span></span><br><span class="line">        JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            builder.withClaim(k,v);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> builder.withExpiresAt(instance.getTime()) <span class="comment">//指定令牌过期时间</span></span><br><span class="line">            .sign(Algorithm.HMAC256(SING));<span class="comment">//sign</span></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    验证token 合法性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SING)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expire;</span><br><span class="line">    <span class="keyword">private</span> String header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(date)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime() + <span class="number">1000</span> * expire))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, key)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">parserToken</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                    .setSigningKey(key)</span><br><span class="line">                    .parseClaimsJws(jwt)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//token是否过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpire</span><span class="params">(Claims claims)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt的基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx基础入门</title>
      <link href="/2023/01/07/nginx/nginx/"/>
      <url>/2023/01/07/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h1><p>说明：<a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=1&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址来源</a> </p><p>​Nginx（＂engine x＂）是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好</p><p>​Nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50，000个并发连接数。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><div id="res">反向代理</div></h2><p>​反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择(转发)目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。  </p><p><img src="/../images/nginx/1672465996506.png" alt="1672465996506"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​正向代理：如果把局域网外的Intemet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。  在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问。</p><p><img src="/../images/nginx/1672465637077.png" alt="1672465637077"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>​客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p><p>​这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？</p><p>​* **单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡  ***</p><p><img src="/../images/nginx/1672466554613.png" alt="1672466554613"></p><h2 id="动态分离"><a href="#动态分离" class="headerlink" title="动态分离"></a>动态分离</h2><p>​为了加快网站的解析速度，可以把动态页面和静态页面有不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><img src="/../images/nginx/1672466852524.png" alt="1672466852524"></p><h1 id="nginx的安装与启动"><a href="#nginx的安装与启动" class="headerlink" title="nginx的安装与启动"></a>nginx的安装与启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p><a href="http://nginx.org/en/download.html">官网下载</a> nginx压缩包，本次为Linux下安装，选择如下：<br><img src="/../images/nginx/1672583906360.png" alt="1672583906360"></p></li><li><p>登录linux，并上传该文件到Linux下，用Winscp上传文件</p><p><img src="/../images/nginx/1672584047837.png" alt="1672584047837"></p><p>附：可用sftp命令上传。。。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接linux</span></span><br><span class="line">sftp [root@192.168...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录成功后，所有的l开头都是代表操作本机，不带l的是操作linux</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在确定好要将本机的文件上传到linux的位置后</span></span><br><span class="line">put 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用命令</span></span><br><span class="line">help  # 看支持哪些命令</span><br><span class="line">pwd &amp; lpwd  # linux当前目录与本机当前工作目录</span><br><span class="line">ls &amp; lls # linux当前目录下的文件，本机当前目录的文件</span><br><span class="line">put a.txt # 将本机a.txt文件上传到linux</span><br><span class="line">get b.txt # 从linux中下载文件到本机</span><br><span class="line">exit &amp; quit # 退出</span><br></pre></td></tr></table></figure></li><li><p>一键安装nginx相关依赖库</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc openssl openssl-devel pcre pcre-devel zlib zlib-devel -y</span><br></pre></td></tr></table></figure><p>   说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- gcc : 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境 </span><br><span class="line">- pcre pcre-devel : pcre(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库,nginx也需要此库。</span><br><span class="line">- zlib : zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</span><br><span class="line">- openssl openssl-devel : OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 </span><br></pre></td></tr></table></figure><ol><li><p>开始安装nginx</p></li><li><p>创建一个nginx文件夹,并进行nginx压缩包的解压</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件夹</span></span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将压缩包解压到当前文件夹中</span></span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz -C /usr/local/nginx# tar -zxvf 压缩包名 -C 指定目录</span><br></pre></td></tr></table></figure></li><li><p>编译并安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx目录</span></span><br><span class="line">cd /usr/local/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd nginx-1.18.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make命令进行编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make install命令进行安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装完后会有conf文件夹，进入nginx.conf文件中配置端口号与ip(与虚拟机ip一致)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开nginx.conf配置文件</span></span><br><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改端口号与ip</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586130429.png" alt="1672586130429"></p></li></ol><h2 id="测试、启动与关闭"><a href="#测试、启动与关闭" class="headerlink" title="测试、启动与关闭"></a>测试、启动与关闭</h2><ol><li><p>查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -v</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -v</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure></li><li><p>查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginxz</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586390937.png" alt="1672586390937"></p></li><li><p>配置过nginx.conf文件，进行刷新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s reload</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s stop</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开放的端口号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式：firewall-cmd --add-service=http --permanent</span></span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>本机浏览器输入虚拟机ip</p><p><img src="/../images/nginx/1672586743935.png" alt="1672586743935"></p><h1 id="nginx配置文件说明"><a href="#nginx配置文件说明" class="headerlink" title="nginx配置文件说明"></a>nginx配置文件说明</h1><p>配置文件位置：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p><p>nginx配置文件由三大部分组成，分为全局块、events块、http块</p><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>​从配置文件开始到 events块之间的内容，主要会设置一些影响 <strong>nginx服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的worker process 数，进程 PID存放路径、日志存放路径和类型以及配置文件的引入等</strong>。 如：</p><p><img src="/../images/nginx/1672627362232.png" alt="1672627362232"></p><p>​这是Nginx 服务器并发处理服务的关键配置，worker＿processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约</p><h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><p>​events 块涉及的指令主要影响 <strong>Nginx 服务器与用户的网络连接</strong>，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。</p><p><img src="/../images/nginx/1672627668523.png" alt="1672627668523"></p><p>​上述例子就表示每个 work process 支持的最大连接数为1024．</p><p>​这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。</p><h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>http块也包括http全局块(http的全局配置)以及server块。</p><ol><li><p>http全局块<br>http 全局块配置的指令包括文件引入、MIME—TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>  <img src="/../images/nginx/1672627926561.png" alt="1672627926561"></p></li><li><p>http块<br>整个大的http包裹的就是http块，可以嵌套多个server</p></li><li><p>server块</p><p>​这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p><p>​每个 http块可以包括多个 server块，而每个server块就相当于一个虚拟主机。而每个 server块也分为全局server块，以及可以同时包含多个locaton块。</p><ol><li><p>全局server块<br>最常见的本虚拟机主机的监听配置和本虚拟机的名称或ip配置</p></li><li><p>location块</p><p>​一个server块可以配置多个location块。</p><p>​这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server-name&#x2F;uri-string），对虚以主机名称（也可以是IP别名）之外的字符串（例如前面的&#x2F;uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。即：<strong>配置请求的路由，以及各种页面 的处理情况</strong>。</p></li></ol></li></ol><h1 id="nginx配置实例-反向代理1"><a href="#nginx配置实例-反向代理1" class="headerlink" title="nginx配置实例-反向代理1"></a>nginx配置实例-反向代理1</h1><p>反向代理原理请参考<a href="#res">1.1反向代理</a></p><p>要实现的效果：</p><p>​打开浏览器，输入网址，跳转到linux系统的tomcat主页</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在linux系统下安装tomcat，使用默认端口8080,并在本地测试是否成功。</p><ol><li><p><a href="https://tomcat.apache.org/download-90.cgi">官网下载 </a> tomcat压缩包<br><img src="/../images/nginx/1672632380038.png" alt="1672632380038"></p></li><li><p>将压缩包上传到linux系统中</p></li><li><p>解压到&#x2F;usr&#x2F;src下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>centos默认安装了jdk，直接进入bin目录启动tomcat|</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/apache-tomcat-9.0.70/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动tomcat</span></span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙或开放8080端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放8080端口</span></span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问linux<br><img src="/../images/nginx/1672632912754.png" alt="1672632912754"></p></li></ol></li></ol><h2 id="访问过程分析"><a href="#访问过程分析" class="headerlink" title="访问过程分析"></a>访问过程分析</h2><p><img src="/../images/nginx/1672633212388.png" alt="1672633212388"></p><h2 id="配置本地host文件"><a href="#配置本地host文件" class="headerlink" title="配置本地host文件"></a>配置本地host文件</h2><ol><li>在C:\Windows\System32\drivers\etc下，修改hosts文件。添加一个本机域名地址：</li></ol><p><img src="/../images/nginx/1672646981434.png" alt="1672646981434"></p><ol><li>在启动了tomcat的情况下，输入地址<a href="http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。">http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。</a><br><img src="/../images/nginx/1672647258790.png" alt="1672647258790"></li><li>配置nginx的配置文件，并启动nginx<br><img src="/../images/nginx/1672647451217.png" alt="1672647451217"></li><li>测试<br>浏览器输入<a href="http://www.123.com,通过nginx的配置,将该请求转发到http//127.0.0.1:8080%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84127.0.0.1%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%AC%E6%9C%BAip%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">www.123.com，通过nginx的配置，将该请求转发到http://127.0.0.1:8080，此时的127.0.0.1代表的是虚拟机本机ip，结果如下：</a><br><img src="/../images/nginx/1672647631481.png" alt="1672647631481"></li></ol><h1 id="nginx配置实例-反向代理2"><a href="#nginx配置实例-反向代理2" class="headerlink" title="nginx配置实例-反向代理2"></a>nginx配置实例-反向代理2</h1><p>想要实现的效果：</p><p>​使用nginx反向代理，根据访问的路径跳转到不同端口的服务中，nginx监听的端口为9001。如：</p><ol><li>访问<a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> ,直接跳转到127.0.0.1:8081</li><li>访问<a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> ,直接跳转到127.0.0.1:8082</li></ol><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>准备两个tomcat服务器，一个8080端口，一个8081端口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/usr/src下创建2个文件夹</span></span><br><span class="line">cd /usr/src</span><br><span class="line">mkdir tomcat8080</span><br><span class="line">mkdir tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/usr/src下的tomcat压缩包分别拷贝到这2个文件夹中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：<span class="built_in">cp</span> 要拷贝的文件名 指定拷贝到的目录</span></span><br><span class="line">cd /usr/src</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8080</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别解压这两个压缩包</span></span><br><span class="line">cd tomcat8080</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line">cd tomcat8081</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改tomcat8081文件夹下的tomcat端口，改为8081</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/conf</span><br><span class="line">vi server.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672657513308.png" alt="1672657513308"></p><p><img src="/../images/nginx/1672657571433.png" alt="1672657571433"></p></li></ol><p><img src="/../images/nginx/1672657600381.png" alt="1672657600381"></p><ol><li><p>分别启动这两个tomcat</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8080端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8081端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>创建一些访问的页面(windows上传过来a.html也行)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/webapps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个文件</span></span><br><span class="line">mkdir edu/a.html</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658101588.png" alt="1672658101588"></p><p>同样方法创建一个vod&#x2F;a.html在端口为8081的tomcat中。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>配置nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在http块中添加如下内容</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658389765.png" alt="1672658389765"></p></li><li><p>开放8080、8081、9001端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8081/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=9001/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658662276.png" alt="1672658662276"></p></li><li><p>测试<br>通过访问不同的文件，nginx转发到不同的端口</p><p>访问<a href="http://192.168.52.128:9001/edu/a.html">192.168.52.128:9001&#x2F;edu&#x2F;a.html</a>  ：</p><p><img src="/../images/nginx/1672658799404.png" alt="1672658799404"></p><p>访问<a href="http://192.168.52.128:9001/vod/a.html">192.168.52.128:9001&#x2F;vod&#x2F;a.html</a> ：</p><p><img src="/../images/nginx/1672658827810.png" alt="1672658827810"></p></li></ol><p>但是现在依然能够不通过nginx，直接进行tomcat的访问，如直接访问8081：</p><p><img src="/../images/nginx/1672658906294.png" alt="1672658906294"></p><p>可以把8080端口与8081端口关闭，达到只能通过9001端口进行访问8080端口的tomcat资源或8081端口的tomcat资源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭8080端口</span></span><br><span class="line">firewall-cmd --remove-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="关于nginx配置文件的location的配置说明"><a href="#关于nginx配置文件的location的配置说明" class="headerlink" title="关于nginx配置文件的location的配置说明"></a>关于nginx配置文件的location的配置说明</h3><p>该指令用于匹配URL。语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~] uri &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>&#x3D; : 用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</li><li>~ ： 用于表示uri包含正则表达式，并且区分大小写。</li><li>~* ：用于表示uri包含正则表达式，并且不区别大小写。</li><li>^~ : 用于不含正在表达式的uri前，要求nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。<br><em><em>注意：如果uri包含正则表达式，则必须要有 ~ 或者 ~</em> 标识</em>*</li></ol><h1 id="nginx配置实例-负载均衡"><a href="#nginx配置实例-负载均衡" class="headerlink" title="nginx配置实例-负载均衡"></a>nginx配置实例-负载均衡</h1><p>想要实现的效果：</p><ol><li>浏览器地址栏输入地址 <a href="http://192.168.52.128/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%B9%B3%E5%9D%87%E8%BD%AC%E5%8F%91%E7%BB%998080%E5%92%8C8081%E7%AB%AF%E5%8F%A3%E3%80%82">http://192.168.52.128/edu/a.html，负载均衡效果：请求平均转发给8080和8081端口。</a></li></ol><h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备两台tomcat服务器，一台8080端口，一台8081<br>根据前面的配置的方向代理实例已经配置好了两台tomcat服务器。</li><li>在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建页面a.html，用于测试|<br><img src="/../images/nginx/1673003516724.png" alt="1673003516724"></li></ol><h2 id="在nginx的配置文件中进行负载均衡的配置"><a href="#在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="在nginx的配置文件中进行负载均衡的配置"></a>在nginx的配置文件中进行负载均衡的配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>   <img src="/../images/nginx/1673003654331.png" alt="1673003654331"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>​在浏览器中输入 <a href="http://192.168.52.128/edu/a.html">http://192.168.52.128/edu/a.html</a> 进行测试，访问一次便刷新一次，效果就是不断依次访问到两个服务器的资源。</p><h2 id="关于nginx分配服务器（负载均衡）的几种策略"><a href="#关于nginx分配服务器（负载均衡）的几种策略" class="headerlink" title="关于nginx分配服务器（负载均衡）的几种策略"></a>关于nginx分配服务器（负载均衡）的几种策略</h2><ol><li><font color="red">轮询(默认)</font><br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉（宕机），能自动剔除。</li><li>weight<br>weight代表权重，默认为1，权重越高被分配的客户端越多。<br><img src="/../images/nginx/1673004386609.png" alt="1673004386609"></li><li>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器，可以解决session的问题。<br><img src="/../images/nginx/1673004591334.png" alt="1673004591334"></li><li>fair(第三方，此配置需要装插件)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><img src="/../images/nginx/1673004829929.png" alt="1673004829929"></li></ol><h1 id="nginx配置实例-动静分离"><a href="#nginx配置实例-动静分离" class="headerlink" title="nginx配置实例-动静分离"></a>nginx配置实例-动静分离</h1><p>​Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过nginx 来分开。</p><p>​通过location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p><p>​具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires 来缓存），我这里设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><img src="/../images/nginx/1673056715488.png" alt="1673056715488"></p><h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>​在linux系统中准备静态资源，用于进行访问。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir data</span><br><span class="line">cd data</span><br><span class="line">mkdir www</span><br><span class="line">mkdir image</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673058624024.png" alt="1673058624024"></p><p>​在image中添加静态资源a.png,在www下添加a.html</p><p><img src="/../images/nginx/1673058664898.png" alt="1673058664898"></p><p><img src="/../images/nginx/1673058781285.png" alt="1673058781285"></p><h2 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>在nginx的配置文件中进行配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673059330164.png" alt="1673059330164"></p></li><li><p>启动nginx后进行测试</p><p>访问静态资源：</p><p><img src="/../images/nginx/1673059651262.png" alt="1673059651262"><br>配置了autoindex on;  ：表示是否将所有资源以列表的形式列举出来。</p><p><img src="/../images/nginx/1673060605982.png" alt="1673060605982"></p></li></ol><h1 id="nginx配置实例-高可用"><a href="#nginx配置实例-高可用" class="headerlink" title="nginx配置实例-高可用"></a>nginx配置实例-高可用</h1><p><img src="/../images/nginx/1673061314633.png" alt="1673061314633"></p><p>nginx宕机则会出现无法访问到tomcat，使用高可用解决该问题，如下图：</p><p><img src="/../images/nginx/1673061394135.png" alt="1673061394135"></p><p>如果nginx主服务器宕机，则通过nginx的备用服务器访问tomcat。</p><p><a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=14&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址：14-nginx配置实例（高可用准备工作）_哔哩哔哩_bilibili</a> </p><p><a href="https://www.cnblogs.com/SimpleWu/p/11004902.html">参考：生产环境之Nginx高可用方案 - 日落西风又在吹 - 博客园 </a> </p><p><a href="https://besterwin.gitee.io/blogs/knowledge/middle/Nginx.html">脑图参考：Nginx.mmap (gitee.io)</a> </p><h1 id="nginx的原理解析"><a href="#nginx的原理解析" class="headerlink" title="nginx的原理解析"></a>nginx的原理解析</h1><p>进程模型：</p><p><img src="/../images/nginx/nginx.webp" alt="img"> </p><ol><li>在nginx启动后，会有一个master进程和多个worker进程，master进程主要用来管理worker进程，包括：接受信号，将信号分发给worker进程，监听worker进程工作状态，当worker进程退出时(非正常)，启动新的worker进程。基本的网络事件会交给worker进程处理。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 。</li><li>当master接收到重新加载的信号会怎么处理(.&#x2F;nginx -s reload)?，master会重新加载配置文件，然后启动新的进程，使用的新的worker进程来接受请求，并告诉老的worker进程他们可以退休了，老的worker进程将不会接受新的，老的worker进程处理完手中正在处理的请求就会退出。</li><li>worker进程是如何处理用户的请求呢？首先master会根据配置文件生成一个监听相应端口的socket，然后再faster出多个worker进程，这样每个worker就可以接受从socket过来的消息（其实这个时候应该是每一个worker都有一个socket，只是这些socket监听的地址是一样的）。当一个连接过来的时候，每一个worker都能接收到通知，但是只有一个worker能和这个连接建立关系，其他的worker都会连接失败，这就是所谓的惊群现在，为了解决这个问题，nginx提供一个共享锁accept_mutex，有了这个共享锁后，就会只有一个worker去接收这个连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。</li></ol><p><a href="https://blog.csdn.net/wangbiao007/article/details/82910709">nginx原理参考</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础常见问题</title>
      <link href="/2022/12/20/Java/JavaSE/"/>
      <url>/2022/12/20/Java/JavaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h1><h2 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1. JDK和JRE有什么区别？"></a>1. JDK和JRE有什么区别？</h2><p>JDK：Java Development Kit的简称，java开发工具包，提供了java的开发环境和运行环境。<br>JRE: Java Runtime Environment的简称，java运行环境，为java的运行提供了所需环境。<br>具体来说JDK其实包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具。简单来说：如果你需要运行java程序，只需要安装JRE就可以了，如果你需要编写java程序，需要安装JDK。</p><h2 id="2-x3D-x3D-和-equals的区别是什么？"><a href="#2-x3D-x3D-和-equals的区别是什么？" class="headerlink" title="2. &#x3D;&#x3D; 和 equals的区别是什么？"></a>2. &#x3D;&#x3D; 和 equals的区别是什么？</h2><ol><li>却别： equals是方法，而 &#x3D;&#x3D; 是操作符；</li><li>对于基本数据类型（short、int、long、float、double）来说，只能使用 &#x3D;&#x3D; 比较值</li><li>对于引用数据类型来说，需要分情况<ul><li>没有重写Object类的equals方法，则用 &#x3D;&#x3D; 比较的是存放的地址。</li><li>重写了Object类的equals方法，如String类，看源码是用 &#x3D;&#x3D; 先进行引用(存放地址)的比较，如果不等，再进行值的比较</li></ul></li></ol><p>总结：<br><font color="red">&#x3D;&#x3D;对于基本数据类型来说是值比较；对于引用数据类型来说，比较的是引用；而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String（先比较引用，再比较值）、Integer（值比较）等把它变成了值比较，所以一般情况下equals比较的是值是否相等</font></p><h2 id="3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？"><a href="#3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？" class="headerlink" title="3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？"></a>3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？</h2><p><font color="red">不对，两个对象的hashCode()相同，equals()不一定为true。</font></p><p>如字符串“通话”、“重地”,这两个字符串的hash相同（用固定公式计算hash），但a.equals(b)是不一样的。</p><h2 id="4-final在java中有什么作用？"><a href="#4-final在java中有什么作用？" class="headerlink" title="4. final在java中有什么作用？"></a>4. final在java中有什么作用？</h2><ul><li>final修饰的类叫最终类，该类不能被继承。</li><li>final修饰的方法不能被重写。</li><li>final修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="5-java中的Math-round-1-5-等于多少？"><a href="#5-java中的Math-round-1-5-等于多少？" class="headerlink" title="5. java中的Math.round(-1.5)等于多少？"></a>5. java中的Math.round(-1.5)等于多少？</h2><p>等于-1，因为在数轴上取值是，中间值(0.5)向右取整，所以整0.5是往上取整，负0.5是直接舍弃。</p><h2 id="6-String属于基础的数据类型吗？"><a href="#6-String属于基础的数据类型吗？" class="headerlink" title="6. String属于基础的数据类型吗？"></a>6. String属于基础的数据类型吗？</h2><p>String不属于基础类型，基础类型有8中，byte(1)、boolean、char(2)、short(2)、int(4)、float(4)、long(8)、double(8)，而String属于对象（引用数据类型）</p><h2 id="7-java中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java中操作字符串都有哪些类？它们之间有什么区别？"></a>7. java中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会⽣成新的String 对象，然后将指针指向新的 String 对象；⽽ StringBuffer、StringBuilder 可以在原有对象的基础上进⾏操作，所以在经常改变字符串内容的情况下最好不要使⽤ String。</p><p>StringBuffer 和 StringBuilder 最⼤的区别在于，StringBuffer 是线程安全的，⽽ StringBuilder 是⾮线程安全的，但 StringBuilder 的性能却⾼于StringBuffer，所以在单线程环境下推荐使⽤ StringBuilder，多线程环境下推荐使⽤ StringBuffer。</p><h2 id="8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？"><a href="#8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？" class="headerlink" title="8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？"></a>8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str &#x3D; “i”的方式，java虚拟机会将其分配到常量池中；而String str &#x3D; new String（”i”）则会被分到堆内存中。</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><p>使用StringBuilder或者StringBuffer的reverse()方法。</p><h2 id="10-String类的常用方法都有哪些？"><a href="#10-String类的常用方法都有哪些？" class="headerlink" title="10. String类的常用方法都有哪些？"></a>10. String类的常用方法都有哪些？</h2><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白（空格）</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的byte类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字母。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li><li>compareTo()：按字典顺序比较大小。</li></ul><h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。（有抽象方法的类必定是抽象类）</p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h2 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13. 抽象类能使用final修饰吗？"></a>13. 抽象类能使用final修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以使任意访问修饰符。</li></ul><h2 id="15-java中IO流分为几种？"><a href="#15-java中IO流分为几种？" class="headerlink" title="15. java中IO流分为几种？"></a>15. java中IO流分为几种？</h2><ol><li>按功能分<ul><li>输入流（input）</li><li>输出流（output）</li></ul></li><li>按类型分<ul><li>字节流</li><li>字符流<br>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字节流按16位传输以字符为单位输入输出数据。</li></ul></li></ol><h2 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16. BIO、NIO、AIO有什么区别？"></a>16. BIO、NIO、AIO有什么区别？</h2><ul><li>BIO：Block IO同步阻塞IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO (或Non Blocking IO) 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel(通道)通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制。</li></ul><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h2><ul><li>Files.exists()：检测⽂件路径是否存在。</li><li>Files.createFile()：创建⽂件。</li><li>Files.createDirectory()：创建⽂件夹。</li><li>Files.delete()：删除⼀个⽂件或⽬录。</li><li>Files.copy()：复制⽂件。</li><li>Files.move()：移动⽂件。</li><li>Files.size()：查看⽂件个数。</li><li>Files.read()：读取⽂件。</li><li>Files.write()：写⼊⽂件。</li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示："><a href="#1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示：" class="headerlink" title="1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示："></a>1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示：</h2><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector<ul><li>Stack</li></ul></li></ul></li><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeSet</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol><li>Collection 是⼀个集合接⼝，它提供了对集合对象进⾏基本操作的通⽤接⼝⽅法，所有集合都是它的⼦类，比如 List、Set 等。</li><li>Collections 是⼀个包装类，包含了很多静态⽅法，不能被实例化，就像⼀个⼯具类，⽐如提供的排序⽅法： Collections.sort(list)。</li></ol><h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个⽅⾯：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br><img src="/../images/JavaSE/2022-12-02-13-46-08.png"></p><h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：HashMap 允许 key 和 value 为 null，⽽ Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，⽽ HashMap 是⾮线程安全的。</li><li>推荐使⽤：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使⽤，推荐在单线程环境下使⽤ HashMap 替代，如果需要多线程使⽤则⽤ ConcurrentHashMap 替代。</li></ul><h2 id="5-如何决定使⽤-HashMap-还是-TreeMap？"><a href="#5-如何决定使⽤-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使⽤ HashMap 还是 TreeMap？"></a>5. 如何决定使⽤ HashMap 还是 TreeMap？</h2><p>   对于在 Map 中插⼊、删除、定位⼀个元素这类操作，HashMap 是最好的选择，因为相对⽽⾔ HashMap的插⼊会更快，但如果你要对⼀个 key 集合进⾏有序的遍历，那 TreeMap 是更好的选择。</p><h2 id="6-说⼀下-HashMap-的实现原理？"><a href="#6-说⼀下-HashMap-的实现原理？" class="headerlink" title="6. 说⼀下 HashMap 的实现原理？"></a>6. 说⼀下 HashMap 的实现原理？</h2><p>   HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传⼊ key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket ⾥。当计算出的hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是⽤链表和红⿊树存储相同 hash 值的 value。<br>当 hash 冲突的个数⽐较少时，使⽤链表否则使⽤红⿊树。</p><h2 id="7-说⼀下-HashSet-的实现原理？"><a href="#7-说⼀下-HashSet-的实现原理？" class="headerlink" title="7. 说⼀下 HashSet 的实现原理？"></a>7. 说⼀下 HashSet 的实现原理？</h2><p>   HashSet 是基于 HashMap 实现的，HashSet 底层使⽤ HashMap 来保存所有元素，因此 HashSet 的实现⽐较简单，相关 HashSet 的操作，基本上都是直接调⽤底层 HashMap 的相关⽅法来完成，HashSet 不允许重复的值。</p><h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，⽽ LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList ⽐ LinkedList 在随机访问的时候效率要⾼，因为 LinkedList 是线性的数据存储⽅式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在⾮⾸尾的增加和删除操作，LinkedList 要⽐ ArrayList 效率要⾼，因为 ArrayList增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使⽤ ArrayList，⽽在插⼊和删除操作较多时，更推荐<br>使⽤ LinkedList。</p><h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使⽤ Arrays.asList(array) 进⾏转换。</li><li>List 转数组：使⽤ List ⾃带的 toArray() ⽅法。</li></ul><h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul><li>线程安全：Vector 使⽤了 Synchronized 来实现线程同步，是线程安全的，⽽ ArrayList 是⾮线程安全的。</li><li>性能：ArrayList 在性能⽅⾯要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1倍，⽽ ArrayList 只会增加 50%。</li></ul><h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定⼤⼩的，⽽ ArrayList ⼤⼩是⾃动扩展的。</li><li>Array 内置⽅法没有 ArrayList 多，⽐如 addAll、removeAll、iteration 等⽅法只有 ArrayList 有。</li></ul><h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul><li>相同点：都是返回第⼀个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，⽽ remove()会直接抛出 NoSuchElementException 异常。</li></ul><h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，⽽像 HashMap 则是⾮线程安全的，不过在 jdk 1.5 之后随着java.util.concurrent 并发包的出现，它们也有了⾃⼰对应的线程安全类，⽐如 HashMap 对应的线程安全类就是ConcurrentHashMap。</p><h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><p>Iterator 接⼝提供遍历任何 Collection 的接⼝。我们可以从⼀个 Collection 中使⽤迭代器⽅法来获取迭代器实例。迭代器取代了 java 集合框架中的Enumeration，迭代器允许调⽤者在迭代过程中移除元素。</p><h2 id="15-Iterator-怎么使⽤？有什么特点？"><a href="#15-Iterator-怎么使⽤？有什么特点？" class="headerlink" title="15. Iterator 怎么使⽤？有什么特点？"></a>15. Iterator 怎么使⽤？有什么特点？</h2><p>使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p><h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator 可以遍历 Set 和 List 集合，⽽ ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，⽽ ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接⼝继承，然后添加了⼀些额外的功能，⽐如添加⼀个元素、替换⼀个元素、获取前⾯或后⾯元素的索引位置。</li></ul><h2 id="17-怎么确保⼀个集合不能被修改？"><a href="#17-怎么确保⼀个集合不能被修改？" class="headerlink" title="17. 怎么确保⼀个集合不能被修改？"></a>17. 怎么确保⼀个集合不能被修改？</h2><p>可以使⽤ Collections.unmodifiableCollection(Collection c) ⽅法来创建⼀个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运⾏时此⾏报错</span></span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
