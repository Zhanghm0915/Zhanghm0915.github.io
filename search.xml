<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-单例&amp;代理设计模式</title>
      <link href="/2023/03/26/design-pattern/singleton-design-pattern/"/>
      <url>/2023/03/26/design-pattern/singleton-design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><hr><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p><ul><li><p>静态变量的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决序列化问题</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p></li><li><p>防止反序列化破坏单例的方式：</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private&#x2F;protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p></li><li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p></li><li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p></li></ul></li><li><p>静态代码块的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Singleton.INSTANCE.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Singleton&gt; &#123; <span class="comment">// Enum实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li><p>线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><hr><h3 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h3><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p><ul><li><p>Singleton</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化接口</span></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h4><ul><li><p>反射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 反射破解单例模式需要添加的代码</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>Runtime 类就是使用的单例设计模式中的饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> currentRuntime;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Runtime</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代售点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><hr><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"><span class="comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用 Proxy 获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//必须时代理ji</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);<span class="comment">//InvocationHandler对象传递给父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span>&#123;</span><br><span class="line">    <span class="comment">// InvocationHandler 为空则抛出异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一份 interfaces</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置可访问的权限</span></span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 的静态内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类型的名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：Proxy.newInstance 时传递的</span></span><br><span class="line">    <span class="comment">//参数二：Proxy.newInstance 时传递的接口集合</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 遍历接口集合</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载接口类到 JVM</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证接口 interfaces 集合中没有重复的接口</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成的代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;   </span><br><span class="line">        <span class="comment">// 【生成的代理类访问修饰符 public final】 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span></span><br><span class="line">        <span class="comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 获取访问修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取当前接口的全限定名 包名.类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="comment">// 获取包名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取唯一的编号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// 包名+ $proxy + 数字，比如 $proxy1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代理工厂类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//因为返回值为void</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><hr><h3 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h3><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> design-pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdp </tag>
            
            <tag> Singleton Pattern </tag>
            
            <tag> Proxy Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml基础介绍</title>
      <link href="/2023/03/26/xml-basic/xml-basic/"/>
      <url>/2023/03/26/xml-basic/xml-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XML介绍：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li><li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li><li>XML 标签没有被预定义，需要自行定义标签</li><li>XML 被设计为具有自我描述性，易于阅读</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的区别</strong>：</p><ul><li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li><li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li><li>HTML 旨在显示信息，而 XML 旨在传输信息</li></ul><hr><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>person.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;110&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="comment">&lt;!--年龄--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--姓名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>/&gt;</span><span class="comment">&lt;!--性别--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p><ul><li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p><ul><li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li><li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li><li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes&#x2F;no</li></ul></li><li><p><strong>元素</strong>        </p><ul><li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li><li>格式 2：<code>&lt;person/&gt;</code></li><li>普通元素的结构由开始标签、元素体、结束标签组成</li><li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;&#x2F;&gt;</li></ul></li><li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p><ul><li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li><li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li><li>必须存在一个根标签，有且只能有一个</li></ul></li><li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p><ul><li>属性是元素的一部分，它必须出现在元素的开始标签中</li><li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li><li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li><li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li></ul></li><li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p></li><li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p><table><thead><tr><th align="center">字符</th><th align="center">预定义的转义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center"><code> &amp;gt;</code></td><td align="center">大于</td></tr><tr><td align="center">“</td><td align="center"><code> &amp;quot;</code></td><td align="center">双引号</td></tr><tr><td align="center">‘</td><td align="center"><code> &amp;apos;</code></td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center"><code> &amp;amp;</code></td><td align="center">和号</td></tr></tbody></table></li><li><p><strong>字符区</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">文本数据</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><ul><li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li></ul></li><li><p>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束；</p><ul><li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p></li><li><p>规则：</p><ul><li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li><li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;../css/xml.css&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.属性信息：id , desc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>32<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span></span><br><span class="line">        select * from student where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age <span class="symbol">&amp;gt;</span> 10;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符</span></span><br><span class="line"><span class="comment">        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符</span></span><br><span class="line"><span class="comment">        或者也可以选择使用字符数据区，里面的内容可以随便了！</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql2</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p><p>DTD 规则：</p><ul><li><p>约束元素的嵌套层级</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;</span><br></pre></td></tr></table></figure></li><li><p>约束元素体里面的数据</p></li><li><p>语法</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 标签名字 标签类型&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">* 判断元素</span><br><span class="line">           简单元素：没有子元素。</span><br><span class="line">           复杂元素：有子元素的元素；</span><br><span class="line">   </span><br><span class="line">   * 标签类型</span><br><span class="line">   </span><br><span class="line">  | 标签类型 | 代码写法  | 说明                 |</span><br><span class="line">  | -------- | --------- | -------------------- |</span><br><span class="line">  | PCDATA   | (#PCDATA) | 被解释的字符串数据   |</span><br><span class="line">  | EMPTY    | EMPTY     | 即空元素，例如\&lt;hr/&gt; |</span><br><span class="line">  | ANY      | ANY       | 即任意类型           |</span><br><span class="line">  </span><br><span class="line">   * 代码</span><br><span class="line">  </span><br><span class="line">     ```dtd</span><br><span class="line">  &lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;</span><br><span class="line">     &lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;</span><br><span class="line">     &lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;</span><br><span class="line">     &lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br></pre></td></tr></table></figure><ul><li><p>数量词</p><table><thead><tr><th>数量词符号</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>表示元素出现一次</td></tr><tr><td>*</td><td>表示元素可以出现0到多个</td></tr><tr><td>+</td><td>表示元素可以出现至少1个</td></tr><tr><td>?</td><td>表示元素可以是0或1个</td></tr><tr><td>,</td><td>表示元素需要按照顺序显示</td></tr><tr><td>|</td><td>表示元素需要选择其中的某一个</td></tr></tbody></table></li></ul></li><li><p>属性声明</p><ul><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 标签名称 </span><br><span class="line">属性名称1 属性类型1 属性说明1</span><br><span class="line">属性名称2 属性类型2 属性说明2</span><br><span class="line">…</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性类型</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>CDATA</td><td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td></tr><tr><td>ID</td><td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td></tr><tr><td>ENUMERATED</td><td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td></tr></tbody></table></li><li><p>属性说明</p><table><thead><tr><th>属性说明</th><th>含义</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>代表属性是必须有的</td></tr><tr><td>#IMPLIED</td><td>代表属性可有可无</td></tr><tr><td>#FIXED</td><td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td></tr></tbody></table></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 书   &lt;!--设置&quot;书&quot;元素的的属性列表--&gt;</span><br><span class="line">id ID #REQUIRED&lt;!--&quot;id&quot;属性值为必须有--&gt;</span><br><span class="line">编号 CDATA #IMPLIED   &lt;!--&quot;编号&quot;属性可有可无--&gt;</span><br><span class="line">出版社 (清华|北大) &quot;清华&quot;   &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“123”--&gt;</span><br><span class="line">type CDATA #FIXED &quot;IT&quot;&lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>XSD 定义：</p><ol><li>Schema 语言也可作为 XSD（XML Schema Definition）</li><li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li><li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li><li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li><li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li></ol><p>XSD 规则：</p><ol><li>创建一个文件，这个文件的后缀名为 .xsd</li><li>定义文档声明</li><li>schema 文件的根标签为： <schema></schema></li><li>在 <schema> 中定义属性：<ul><li>xmlns&#x3D;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li><li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>targetNamespace &#x3D; 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li><li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>elementFormDefault&#x3D;”qualified“，表示当前 schema 文件是一个质量良好的文件。</li></ul></schema></li><li>通过 element 定义元素</li><li><strong>判断当前元素是简单元素还是复杂元素</strong></li></ol><p>person.xsd</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;</span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;</span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span>  &lt;!--本文件是质量好的--&gt;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;      &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">        &lt;complexType&gt;             &lt;!--复杂的元素--&gt;</span><br><span class="line">            &lt;sequence&gt;  &lt;!--里面的元素必须按照顺序定义--&gt;</span><br><span class="line">                &lt;element name = <span class="string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p><p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p><p>Dom4J 实现：</p><ul><li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p></li><li><p>SAXReader 常用 API：</p><ul><li><code>public Document read(File file)</code>：Reads a Document from the given File</li><li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li></ul></li><li><p>Java Class 类 API：</p><ul><li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li></ul></li></ul><hr><h3 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h3><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个dom4j的解析器对象：代表整个dom4j框架。</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。</span></span><br><span class="line">        <span class="comment">//Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.第二种方式（代码多点）先把xml文件读成一个字节输入流</span></span><br><span class="line">        <span class="comment">// 这里的“/”是直接去src类路径下寻找文件。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JDemo01.class.getResourceAsStream(<span class="string">&quot;/books.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        System.out.println(document);</span><br><span class="line"><span class="comment">//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]</span></span><br><span class="line"><span class="comment">// 4.从document文档树对象中提取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());<span class="comment">//books</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0001&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一本书&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>  JavaWeb开发教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>    张三<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元   <span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0002&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元<span class="tag">&lt;/<span class="name">sale</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><p>Element 元素的 API:</p><ul><li>String getName()：取元素的名称。</li><li>List<Element> elements()：获取当前元素下的全部子元素（一级）</Element></li><li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</Element></li><li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.获取根元素下的全部子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements = root.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.获取根源下的全部book子元素</span></span><br><span class="line">        List&lt;Element&gt; sonElements1 = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonElement : sonElements1) &#123;</span><br><span class="line">            System.out.println(sonElement.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.获取根源下的指定的某个元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(son.getName());</span><br><span class="line">        <span class="comment">// 默认会提取第一个名称一样的子元素对象返回！</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">son1</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(son1.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Element 元素的 API：</p><ul><li>List<Attribute> attributes()：获取元素的全部属性对象</Attribute></li><li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li><li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li></ul><p>Attribute 对象的 API：</p><ul><li>String getName()：获取属性名称</li><li>String getValue()：获取属性值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.获取book子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取book元素的全部属性对象</span></span><br><span class="line">        List&lt;Attribute&gt; attributes = bookEle.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName()+<span class="string">&quot;-&gt;&quot;</span>+attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.获取Book元素的某个属性对象</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">descAttr</span> <span class="operator">=</span> bookEle.attribute(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(descAttr.getName()+<span class="string">&quot;-&gt;&quot;</span>+descAttr.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.可以直接获取元素的属性值</span></span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.attributeValue(<span class="string">&quot;desc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>Element：</p><ul><li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li><li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li><li>String getText()：直接获取当前元素的文本内容</li><li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 4.得到第一个子元素book</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.直接拿到当前book元素下的子元素文本值</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line">        System.out.println(bookEle.elementText(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">        System.out.println(bookEle.elementTextTrim(<span class="string">&quot;author&quot;</span>)); <span class="comment">// 去前后空格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.先获取到子元素对象，再获取该文本值</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bookNameEle</span> <span class="operator">=</span> bookEle.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(bookNameEle.getText());</span><br><span class="line">        System.out.println(bookNameEle.getTextTrim());<span class="comment">// 去前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p><p>XPath 常用API：</p><ul><li>List<Node> selectNodes(String var1) : 检索出一批节点集合</Node></li><li>Node selectSingleNode(String var1) : 检索出一个节点返回</li></ul><p>XPath 提供的四种检索数据的写法：</p><ol><li>绝对路径：&#x2F;根元素&#x2F;子元素&#x2F;子元素</li><li>相对路径：.&#x2F;子元素&#x2F;子元素 (.代表了当前元素)</li><li>全文搜索：<ul><li>&#x2F;&#x2F;元素：在全文找这个元素</li><li>&#x2F;&#x2F;元素1&#x2F;元素2：在全文找元素1下面的一级元素 2</li><li>&#x2F;&#x2F;元素1&#x2F;&#x2F;元素2：在全文找元素1下面的全部元素 2</li></ul></li><li>属性查找：<ul><li>&#x2F;&#x2F;@属性名称：在全文检索属性对象</li><li>&#x2F;&#x2F;元素[@属性名称]：在全文检索包含该属性的元素对象</li><li>&#x2F;&#x2F;元素[@属性名称&#x3D;值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contact.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line">        <span class="comment">//1.使用绝对路径定位全部的name名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes1 = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            System.out.println(nameNode.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.相对路径。从根元素开始检索，.代表很根元素</span></span><br><span class="line">        List&lt;Node&gt; nameNodes2 = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.1 在全文中检索name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//name&quot;</span>);<span class="comment">//全部的</span></span><br><span class="line">        <span class="comment">//3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="comment">//3.3 在全文中检索所有contact下的直接name节点</span></span><br><span class="line">        List&lt;Node&gt; nameNodes3 = root.selectNodes(<span class="string">&quot;//contact/name&quot;</span>);<span class="comment">//不包括sql和外面</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.1 检索全部属性对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//@id&quot;</span>);<span class="comment">//包括sql4</span></span><br><span class="line">        <span class="comment">//4.2 在全文检索包含该属性的元素对象</span></span><br><span class="line">        List&lt;Node&gt; attributes1 = root.selectNodes(<span class="string">&quot;//contact[@id]&quot;</span>);</span><br><span class="line">        <span class="comment">//4.3 在全文检索包含该属性的元素且属性值为该值的元素对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeEle</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//contact[@id=2]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element)nodeEle;</span><br><span class="line">        System.out.println(ele.elementTextTrim(<span class="string">&quot;name&quot;</span>));<span class="comment">//xi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小白<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>bai@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小黑<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hei@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sql4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小虎<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hu@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contact</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>外面的名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础(全)</title>
      <link href="/2023/03/04/Java/java/"/>
      <url>/2023/03/04/Java/java/</url>
      
        <content type="html"><![CDATA[<h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table><thead><tr><th align="center"></th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中，方法外</td><td align="center">方法中或者方法的形参</td><td align="center">在类中，方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无，赋值后才能使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方法</td><td align="center">对象调用</td><td align="center"></td><td align="center">对象调用，类名调用</td></tr><tr><td align="center">存储位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区（JDK8 以后移到堆中）</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center"></td><td align="center">类变量，静态成员变量</td></tr></tbody></table><p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p><p><a href="https://www.bilibili.com/video/BV1TE41177m">参考视频</a></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li><li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li><li>默认值是 <code>0</code></li><li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li><li>例子：<code>byte a = 100，byte b = -50</code></li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li><li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li><li>默认值是 <code>0</code></li><li>例子：<code>short s = 1000，short r = -20000</code></li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li><li>一般地整型变量默认为 int 类型</li><li>默认值是 <code>0</code></li><li>例子：<code>int a = 100000, int b = -200000</code></li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li><li>这种类型主要使用在需要比较大整数的系统上</li><li>默认值是 <code> 0L</code></li><li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li><li>float 在储存大型浮点数组的时候可节省内存空间</li><li>默认值是 <code>0.0f</code></li><li>浮点数不能用来表示精确的值，如货币</li><li>例子：<code>float f1 = 234.5F</code></li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li><li>浮点数的默认类型为 double 类型</li><li>double 类型同样不能表示精确的值，如货币</li><li>默认值是 <code>0.0d</code></li><li>例子：<code>double d1 = 123.4</code></li></ul><p><strong>boolean：</strong></p><ul><li>boolean 数据类型表示一位的信息</li><li>只有两个取值：true 和 false</li><li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li><li>默认值是 <code>false</code></li><li>例子：<code>boolean one = true</code></li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li><li>最小值是 <code>\u0000</code>（即为 0）</li><li>最大值是 <code>\uffff</code>（即为 65535）</li><li>char 数据类型可以<strong>存储任何字符</strong></li><li>例子：<code>char c = &#39;A&#39;</code>，<code>char c = &#39;张&#39;</code></li></ul><h5 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h5><ul><li><p>float 与 double：</p><p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//1.1f 字面量才是 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.23</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> (<span class="type">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1245</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (<span class="type">int</span>) l2;</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换：</p><p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p><p>使用 +&#x3D; 或者 ++ 运算符会执行类型转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;<span class="comment">//s1++;</span></span><br><span class="line"><span class="comment">//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型</span></span><br><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p><p>包装类的作用：</p><ul><li>包装类作为类首先拥有了 Object 类的方法</li><li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）</span><br><span class="line"><span class="type">byte</span>                      Byte</span><br><span class="line"><span class="type">short</span>                     Short</span><br><span class="line"><span class="type">int</span>                       Integer</span><br><span class="line"><span class="type">long</span>                      Long</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>                     Float</span><br><span class="line"><span class="type">double</span>                    Double</span><br><span class="line"><span class="type">char</span>                      Character</span><br><span class="line"><span class="type">boolean</span>                   Boolean</span><br></pre></td></tr></table></figure><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p><ul><li><p>可以把基本数据类型的值转换成字符串类型的值</p><ol><li>调用 toString() 方法</li><li>调用 Integer.toString(基本数据类型的值) 得到字符串</li><li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li></ol></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p><ol><li>Xxx.parseXxx(“字符串类型的数值”) → <code>Integer.parseInt(numStr)</code></li><li>Xxx.valueOf(“字符串类型的数值”)   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClass02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.把基本数据类型的值转成字符串</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="comment">// a.调用toString()方法。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr</span> <span class="operator">=</span> it.toString();</span><br><span class="line">        System.out.println(itStr+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// b.调用Integer.toString(基本数据类型的值)得到字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr1</span> <span class="operator">=</span> Integer.toString(it);</span><br><span class="line">        System.out.println(itStr1+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="comment">// c.直接把基本数据类型+空字符串就得到了字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">itStr2</span> <span class="operator">=</span> it + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(itStr2+<span class="number">1</span>);<span class="comment">// 1001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把字符串类型的数值转换成对应的基本数据类型的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numInt</span> <span class="operator">=</span> Integer.valueOf(numStr);</span><br><span class="line">        System.out.println(numInt+<span class="number">1</span>);<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">doubleStr</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleDb</span> <span class="operator">=</span> Double.valueOf(doubleStr);</span><br><span class="line">        System.out.println(doubleDb+<span class="number">0.1</span>);<span class="comment">//100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h5><ul><li><p>有了基本数据类型，为什么还要引用数据类型？</p><blockquote><p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p><p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p></blockquote></li><li><p>引用数据类型那么好，为什么还用基本数据类型？</p><blockquote><p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p></blockquote></li><li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p><blockquote><p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p></blockquote></li><li><p>&#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值<br>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</p></blockquote></li></ul><h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p><p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackegeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">12</span> ;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> a ;   <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 引用数据类型的默认值可以为null</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c ;      <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(<span class="number">12</span>);  <span class="comment">// 手工装箱！</span></span><br><span class="line">        <span class="comment">// Integer it1 = new Integer(12); // 手工装箱！</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="number">111</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">it33</span> <span class="operator">=</span> it3.intValue(); <span class="comment">// 手工拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 【缓存池】，本质上是一个数组</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li><p>new Integer(123)：每次都会新建一个对象</p></li><li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><p><strong>基本类型对应的缓存池如下：</strong></p><ul><li>Boolean values true and false</li><li>all byte values</li><li>Short values between -128 and 127</li><li>Long values between -128 and 127</li><li>Integer values between -128 and 127</li><li>Character in the range \u0000 to \u007F (0 and 127)</li></ul><p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 自动装箱，底层调用 Integer.valueOf(1)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);   <span class="comment">// false，因为缓存池最大127</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true，因为 y 会调用 intValue 【自动拆箱】返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p><ul><li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li><li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li></ul><p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p><ul><li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li><li>print：<code>PrintStream.write()</code></li></ul><blockquote><p>使用引用数据类型的API</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p><p>创建数组：</p><ul><li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li><li>数据类型 数组名[]：<code>int arr[]</code></li></ul><p>静态初始化：</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li><li>数据类型[] 数组名 &#x3D; {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li></ul><p>动态初始化</p><ul><li>数据类型[] 数组名 &#x3D; new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li></ul><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul><li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p></li><li><p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p></li><li><p><strong>赋值：</strong><code>arr[0] = 10</code></p></li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给 CPU 使用</td></tr><tr><td>本地方法栈</td><td>JVM 在使用操作系统功能的时候使用</td></tr><tr><td>方法区</td><td>存储可以运行的 class 文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new 来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td></tr></tbody></table><p>内存分配图：<strong>Java 数组分配在堆内存</strong></p><ul><li><p>一个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>两个数组内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>多个数组指向相同内存图</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p><h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4></li><li><p>索引越界异常：ArrayIndexOutOfBoundsException </p></li><li><p>空指针异常：NullPointerException </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p><p>解决方案：给数组一个真正的堆内存空间引用即可</p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4></li></ul><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p><p>初始化：</p><ul><li><p>动态初始化：<code>数据类型[][] 变量名 = new 数据类型[m][n]</code>，<code>int[][] arr = new int[3][3]</code></p><ul><li>m 表示这个二维数组，可以存放多少个一维数组，行</li><li>n 表示每一个一维数组，可以存放多少个元素，列</li></ul></li><li><p>静态初始化:<code>数据类型[][] 变量名 = new 数据类型[m][n]&#123;&#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125;&#125; </code></p><ul><li><code>数据类型[][] 变量名 = &#123;&#123;元素1, 元素2...&#125;, &#123;元素1, 元素2...&#125;...&#125;`  * `int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;</code></li></ul></li></ul><p>遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        步骤:</span></span><br><span class="line"><span class="comment">            1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line"><span class="comment">            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(arr[i]);</span></span><br><span class="line">            <span class="comment">// 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素</span></span><br><span class="line">            <span class="comment">//int[] temp = arr[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>i++ 与 ++i 的区别？</p><p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p></li><li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p><p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p><p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p></li><li><p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p></li><li><p>同或：两位相同为 1，相异为 0</p></li><li><p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p></li><li><p>break：跳出一层循环</p></li><li><p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p><ul><li><p>正数的原码反码补码相同，最高位为 0</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure></li><li><p>负数：<br>原码：最高位为 1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">100</span> 原码:<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span><span class="comment">//32位</span></span><br><span class="line">-<span class="number">100</span> 反码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011011</span></span><br><span class="line">-<span class="number">100</span> 补码:<span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">11111111</span>  <span class="number">10011100</span></span><br></pre></td></tr></table></figure><p>补码 → 原码：符号位不变，其余位置取反加 1</p></li></ul><p>运算符：</p><ul><li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li><li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li><li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li></ul><p>运算规则：</p><ul><li><p>正数的左移与右移，空位补 0</p></li><li><p>负数原码的左移与右移，空位补 0</p><p>负数反码的左移与右移，空位补 1</p><p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p></li><li><p>无符号移位，空位补 0</p></li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p><ul><li>形式参数，用于定义方法的时候使用的参数，只能是变量</li><li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li></ul><p>实参：调用方法时传递的数据可以是常量，也可以是变量</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p><p>格式：数据类型… 参数名称</p><p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p><p>可变参数的注意事项：</p><ul><li>一个形参列表中可变参数只能有一个</li><li>可变参数必须放在形参列表的<strong>最后面</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">sum(); <span class="comment">// 可以不传输参数。</span></span><br><span class="line">sum(<span class="number">10</span>); <span class="comment">// 可以传输一个参数。</span></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); <span class="comment">// 可以传输多个参数。</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">90</span>&#125;); <span class="comment">// 可以传输一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p><p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p><p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p><h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line"><span class="comment">//方法体;</span></span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 (参数) ;</span><br></pre></td></tr></table></figure><ul><li>方法名：调用方法时候使用的标识</li><li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li><li>方法体：完成功能的代码块</li><li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li></ul><p>如果方法操作完毕</p><ul><li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li><li>非 void 类型的方法，推荐用变量接收调用</li></ul><p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>方法不能嵌套定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p><ol><li>多个方法在<strong>同一个类</strong>中</li><li>多个方法具有<strong>相同的方法名</strong></li><li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li></ol><p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p><p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p><p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">/*正确格式*/</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ul><li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li><li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li><li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li></ul><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法，选取的第二阶段</span></span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类</span></span><br><span class="line">    </span><br><span class="line">    invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法</span></span><br><span class="line">       <span class="comment">// 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此不提倡可变长参数方法的重载</strong></p><h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p><ul><li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li><li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p><p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p><ul><li><p>基本数据类型：形式参数的改变，不影响实际参数</p><p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">change(number);</span><br><span class="line">System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);<span class="comment">//100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">number = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型：形式参数的改变，影响实际参数的值</p><p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());<span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p><p>定义枚举的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">第一行都是罗列枚举实例的名称。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的特点：</p><ul><li>枚举类是用 final 修饰的，枚举类不能被继承</li><li>枚举类默认继承了 java.lang.Enum 枚举类</li><li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li><li>枚举类相当于是多例设计模式</li><li>每个枚举项都是一个实例，是一个静态成员变量</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E  o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <T> T  valueOf(Class<T> type,String  name)</T></T></td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类的编译以后源代码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Season&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season[] values();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>API 使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引</span></span><br><span class="line">        <span class="type">Season</span> <span class="variable">s</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">        System.out.println(s);<span class="comment">//SPRING</span></span><br><span class="line">        System.out.println(s.ordinal()); <span class="comment">// 0，该值代表索引，summer 就是 1</span></span><br><span class="line">        s.s.doSomething();</span><br><span class="line">        <span class="comment">// 获取全部枚举</span></span><br><span class="line">        Season[] ss = Season.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Season.SPRING.compareTo(Season.WINTER);</span><br><span class="line">        System.out.println(result);<span class="comment">//-3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 是一种面向对象的高级编程语言</p><p>面向对象三大特征：<strong>封装，继承，多态</strong></p><p>两个概念：类和对象</p><ul><li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li><li>对象：是真实存在的实例， 实例 &#x3D;&#x3D; 对象，<strong>对象是类的实例化</strong></li><li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li><li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li><li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分</span><br><span class="line">修饰符 class 类名&#123;</span><br><span class="line"><span class="number">1.</span>成员变量(Field):  描述类或者对象的属性信息的。</span><br><span class="line">        <span class="number">2.</span>成员方法(Method):描述类或者对象的行为信息的。</span><br><span class="line"><span class="number">3.</span>构造器(Constructor): 初始化一个对象返回。</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">  &#125;</span><br><span class="line">类中有且仅有这五种成分，否则代码报错！</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：初始化类的一个对象返回</p><p>分类：无参数构造器，有参数构造器</p><p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p><p>构造器初始化对象的格式：类名 对象名称 &#x3D; new 构造器</p><ul><li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li><li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li></ul><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p><p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p><p>导包格式：<code>import 包名.类名</code></p><p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露</p><p>封装最初的目的：提高代码的安全性和复用性，组件化</p><p>封装的步骤：</p><ol><li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li><li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li></ol><p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p><ul><li>this 关键字代表了当前对象的引用</li><li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li><li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li><li>this 可以区分变量是访问的成员变量还是局部变量</li></ul><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p><p>按照有无 static 修饰，成员变量和方法可以分为：</p><ul><li><p>成员变量：</p><ul><li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li><li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li></ul></li><li><p>成员方法：</p><ul><li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li><li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li></ul></li></ul><h4 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h4><p>成员变量的访问语法：</p><ul><li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p><ul><li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li><li>对象.静态成员变量（不推荐）</li></ul></li><li><p>实例成员变量：</p><ul><li>对象.实例成员变量（先创建对象）</li></ul></li></ul><p>成员方法的访问语法：</p><ul><li><p>静态方法：有 static 修饰，属于类</p><ul><li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li><li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li></ul></li><li><p>实例方法：无 static 修饰，属于对象</p><ul><li>对象.实例方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 2.实例方法：无static修饰，属于对象，必须用对象访问！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// a.类名.静态方法</span></span><br><span class="line">        Student.inAddr();</span><br><span class="line">        inAddr();</span><br><span class="line">        <span class="comment">// b.对象.实例方法</span></span><br><span class="line">        <span class="comment">// Student.eat(); // 报错了！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        sea.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>访问问题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li><li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li><li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li><li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li><li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li><li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p><ul><li>被继承的类称为：父类&#x2F;超类</li><li>继承父类的类称为：子类</li></ul><p>继承的作用：</p><ul><li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li><li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li><li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li></ul><p>继承的特点：</p><ol><li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li><li><strong>单继承</strong>：一个类只能继承一个直接父类</li><li>多层继承：一个类可以间接继承多个父类（家谱）</li><li>一个类可以有多个子类</li><li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li></ol><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类不能继承父类的东西：</p><ul><li>子类不能继承父类的构造器，子类有自己的构造器</li><li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li><li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// c.run();</span></span><br><span class="line">        Cat.test();</span><br><span class="line">        System.out.println(Cat.schoolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span><span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p><p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wmain</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();w</span><br><span class="line">        w.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类狼&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部name</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类对象的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的</span></span><br><span class="line">        System.out.println(name1); <span class="comment">// 父类的</span></span><br><span class="line">        <span class="comment">//System.out.println(name2); // 报错。子类父类都没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类动物名称&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;父类&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p><p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p><p>方法重写的校验注解：@Override</p><ul><li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li><li>@Override 优势：可读性好，安全，优雅</li></ul><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul><p>继承中的隐藏问题：</p><ul><li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li><li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wolf</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        w.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>为什么子类构造器会先调用父类构造器？</p><ol><li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li><li>参考 JVM → 类加载 → 对象创建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的无参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  默认存在的，根据参数去匹配调用父类的构造器。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==子类Tiger的有参数构造器==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>为什么 Java 是单继承的？</strong></p><p>答：反证法，假如 Java 可以多继承，请看如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> , B &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.test(); </span><br><span class="line">        <span class="comment">// 出现了类的二义性！所以Java不能多继承！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p><p>总结与拓展：</p><ul><li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(…)</strong> 可以根据参数匹配访问本类其他构造器</li><li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…) 可以根据参数匹配访问父类的构造器</li></ul><p>注意：</p><ul><li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器</li><li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错</li><li>this(…) 和 super(…) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;天蓬元帅&quot;</span>, <span class="number">1000</span> );</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;齐天大圣&quot;</span>, <span class="number">2000</span>, <span class="string">&quot;清华大学&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Study</span> <span class="keyword">extends</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Study</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age , schoolName) ; </span><br><span class="line">       <span class="comment">// 根据参数匹配调用父类构造器</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String schoolName ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// 借用兄弟构造器的功能！</span></span><br><span class="line">        <span class="built_in">this</span>(name , age , <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......get + set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p><ul><li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li><li>final 可以修饰方法，方法就不能被重写</li><li>final 修饰变量总规则：变量有且仅能被赋值一次</li></ul><p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p><p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p><p>final 修饰静态成员变量可以在哪些地方赋值：</p><ol><li><p>定义的时候赋值一次</p></li><li><p>可以在静态代码块中赋值一次</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line"><span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_NAME1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//SCHOOL_NAME = &quot;java&quot;;//报错</span></span><br><span class="line">        SCHOOL_NAME1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p><p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p><ol><li>定义的时候赋值一次</li><li>可以在实例代码块中赋值一次</li><li>可以在每个构造器中赋值一次</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在实例代码块中赋值一次。</span></span><br><span class="line">        name1 = <span class="string">&quot;张三1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造器赋值一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalDemo</span><span class="params">(String a)</span>&#123;</span><br><span class="line">        name2 = <span class="string">&quot;张三2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalDemo</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalDemo</span>();</span><br><span class="line">        <span class="comment">//f1.name = &quot;张三1&quot;; // 第二次赋值 报错！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p></blockquote><p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p><p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p><p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;🐕跑&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?</p><ul><li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li><li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li></ul><blockquote><p>抽象在学术上本身意味着不能实例化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！</span></span><br><span class="line">        <span class="comment">//a.run(); // 抽象方法不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、static 与 abstract 能同时使用吗？</p><p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p><p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作文模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoMa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xiaoMa.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeText</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;\t内容&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.写一个模板类：代表了作文模板。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;\t\t\t\t\t标题&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;\t开头&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;\t结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(title+<span class="string">&quot;\n&quot;</span>+start);</span><br><span class="line">        System.out.println(writeText());</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正文部分定义成抽象方法，交给子类重写！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">writeText</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口是 Java 语言中一种引用类型，是方法的集合。</p><p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 修饰符 interface 接口名称&#123;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p></li><li><p>静态方法：静态方法必须有方法体</p></li><li><p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//默认补充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p><strong>接口是用来被类实现的。</strong></p><ul><li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li><li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li><li>接口与接口继承关系：<strong>多继承</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">修饰符 interface 接口名 extend 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3</span>,....&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现多个接口的使用注意事项：</p><ol><li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p></li><li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p></li><li><p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p></li><li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.run();</span><br><span class="line">        s.rule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Food</span>, Person&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以直接 interface Person extend Food,</span></span><br><span class="line"><span class="comment">//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p><ul><li>默认方法（就是普通实例方法）<ul><li>必须用 default 修饰，默认会 public 修饰</li><li>必须用接口的实现类的对象来调用</li><li>必须有默认实现</li></ul></li><li>静态方法<ul><li>默认会 public 修饰</li><li>接口的静态方法必须用接口的类名本身来调用</li><li>调用格式：ClassName.method()</li><li>必须有默认实现</li></ul></li><li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        m.run();</span><br><span class="line">        m.work();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接口的静态方法必须用接口的类名本身来调用。</span></span><br><span class="line">        InterfaceJDK8.inAddr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作中。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceJDK8</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法！！</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// a.默认方法（就是之前写的普通实例方法）</span></span><br><span class="line">    <span class="comment">// 必须用接口的实现类的对象来调用。</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始跑步🏃‍&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.静态方法</span></span><br><span class="line">    <span class="comment">// 注意：接口的静态方法必须用接口的类名本身来调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们在武汉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。</span></span><br><span class="line">    <span class="comment">// 只能在本接口中被其他的默认方法或者私有方法访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>默认的方法实现</td><td>可以有默认的方法实现</td><td>接口完全是抽象的，jdk8 以后有默认的实现</td></tr><tr><td>实现</td><td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常Java类的区别</td><td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td><td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td></tr><tr><td>main方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口可以继承一个或多个其它接口，接口不可继承类</td></tr><tr><td>速度</td><td>比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td></tr><tr><td>添加新方法</td><td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td><td>如果往接口中添加方法，那么必须改变实现该接口的类</td></tr></tbody></table><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p><p>多态的格式：</p><ul><li>父类类型范围 &gt; 子类类型范围</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p>多态的执行：</p><ul><li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li><li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li></ul><p>多态的使用规则：</p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>存在方法重写</li></ul><p>多态的优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li><li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li></ul><p>多态的劣势： </p><ul><li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.run();</span><br><span class="line">        <span class="comment">//c.eat();//报错  编译看左边 需要强转</span></span><br><span class="line">        go(c);</span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Dog</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal d)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上下转型-1"><a href="#上下转型-1" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote><p>基本数据类型的转换：</p><ol><li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li><li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li></ol></blockquote><p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p><p><strong>父类引用指向子类对象</strong></p><ul><li>**向上转型 (upcasting)**：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li><li>**向下转型 (downcasting)**：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;<span class="comment">// 向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p><ul><li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li><li>强制类型转换的格式：<strong>类型 变量名称 &#x3D; (类型)(对象或者变量)</strong></li><li>有继承&#x2F;实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Dog d = (Dog)a;</span></span><br><span class="line">        <span class="comment">//Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误</span></span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p><p>概念：定义在一个类里面的类就是内部类</p><p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p><p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有 static 修饰，属于外部类本身，会加载一次</p><p>静态内部类中的成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>特点与外部类是完全一样的，只是位置在别人里面</li><li>可以定义静态成员</li></ul><p>静态内部类的访问格式：外部类名称.内部类名称</p><p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称.内部类构造器</p><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?可以，外部类的静态成员只有一份，可以被共享<br>   静态内部类中是否可以直接访问外部类的实例成员?不可以，外部类的成员必须用外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量</span></span><br><span class="line">         System.out.println(age);</span><br><span class="line">         <span class="comment">//System.out.println(salary);报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p><p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p><p>实例内部类的访问格式：外部类名称.内部类名称</p><p>创建对象的格式：外部类名称.内部类名称 对象名称 &#x3D; new 外部类构造器.new 内部构造器</p><ul><li><code>Outter.Inner in = new Outter().new Inner()</code></li></ul><p><strong>实例内部类可以访问外部类的全部成员</strong></p><ul><li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li><li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p><p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        class&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;</span><br><span class="line"><span class="comment">//方法重写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类不能定义静态成员</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li><li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);</span><br><span class="line">                <span class="comment">//System.out.println(n);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.run();</span><br><span class="line">        a.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始go~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p><table><thead><tr><th>四种修饰符访问权限</th><th align="center">private</th><th align="center">缺省</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下的子类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下其他类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的子类中</td><td align="center">X</td><td align="center">X</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的其他类中</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">√</td></tr></tbody></table><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见</li><li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代码块特点： <ul><li>必须有 static 修饰，只能访问静态资源</li><li>会与类一起优先加载，且自动触发执行一次</li></ul></li><li>静态代码块作用：<ul><li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li><li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块,属于类，与类一起加载一次!</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被触发执行~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">// 在静态代码块中进行静态资源的初始化操作</span></span><br><span class="line">        schoolName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法被执行&quot;</span>);</span><br><span class="line">        System.out.println(schoolName);</span><br><span class="line">        System.out.println(lists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块被触发执行~~~~~~~</span></span><br><span class="line"><span class="comment">main方法被执行</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">[3, 4, 5] */</span></span><br></pre></td></tr></table></figure><h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例代码块的特点：</p><ul><li>无 static 修饰，属于对象</li><li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li></ul></li><li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;代码块&quot;</span>;</span><br><span class="line">        lists.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">()</span>&#123; &#125;<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeDemo02</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeDemo</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">        System.out.println(c.name);</span><br><span class="line">        System.out.println(c.lists);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeDemo02</span>();<span class="comment">//实例代码块被触发执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p><p>Object 类常用方法：</p><ul><li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul><li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li><li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li></ul></li><li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li><li><code>protected Object clone()</code>：创建并返回此对象的副本</li></ul><p>只要两个对象的内容一样，就认为是相等的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2.判断被比较者是否为null ,以及是否是学生类型。</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3.o一定是学生类型，强制转换成学生，开始比较内容！</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">           sex == student.sex &amp;&amp;</span><br><span class="line">           Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：&#x3D;&#x3D; 和 equals 的区别</p><ul><li>&#x3D;&#x3D; 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li><li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li></ul><p>hashCode 的作用：</p><ul><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li><li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li></ul><h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p><p>深浅拷贝（克隆）的概念：</p><ul><li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p><p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p></li><li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p></li></ul><p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p><ul><li><p>Clone &amp; Copy：<code>Student s = new Student</code></p><p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p><p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p></li><li><p>Shallow Clone &amp; Deep Clone：</p><p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p><ul><li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li><li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p><p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        s.date = (Date) date.clone();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>SDP → 创建型 → 原型模式</p><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系</p><p>Objects 的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line"><span class="comment">// 进行非空判断，从而可以避免空指针异常</span></span><br><span class="line"><span class="keyword">return</span> a == b || a != <span class="literal">null</span> &amp;&amp; a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* `public static boolean isNull(Object obj)`：判断变量是否为 null ，为 null 返回 true</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象)`：返回参数中对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">* `public static String toString(对象, 默认字符串)`：返回对象的字符串表示形式</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class ObjectsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = null;</span><br><span class="line">        Student s2 = new Student();</span><br><span class="line">        System.out.println(Objects.equals(s1 , s2));//推荐使用</span><br><span class="line">        // System.out.println(s1.equals(s2)); // 空指针异常</span><br><span class="line"> </span><br><span class="line">        System.out.println(Objects.isNull(s1));</span><br><span class="line">        System.out.println(s1 == null);//直接判断比较好</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p><p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p><ul><li><p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p></li><li><p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p></li><li><p><code>public int length()</code>：返回此字符串的长度</p></li><li><p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p></li><li><p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p></li><li><p><code>public char charAt(int index)</code>：取索引处的值</p></li><li><p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p></li><li><p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p></li><li><p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p></li><li><p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p></li><li><p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p></li><li><p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p></li><li><p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p></li><li><p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>-<span class="number">78</span>;</span><br><span class="line">s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p><ul><li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li><li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li><li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li></ul><p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p><ul><li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li><li>直接赋值方式创建：以 <code>&quot; &quot;</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li></ul><p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p><ul><li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li><li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;"></li></ul><p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p><ul><li><p>对象 1：new StringBuilder()</p></li><li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p></li><li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;"></li><li><p>StringBuilder 的 toString()：</p></li></ul>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 6：new String(“ab”)</li><li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li></ul><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool &#x2F; StringTable &#x2F; 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p><ul><li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li><li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li><li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li><li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li></ul><h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p><ul><li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li><li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li></ul><p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 懒惰的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 串池</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">// 返回的是堆内地址</span></span><br><span class="line">        <span class="comment">// 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;  <span class="comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        <span class="comment">// 虽然 new，但是在字符串常量池没有 cd 对象，因为 toString() 方法</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D; 比较基本数据类型：比较的是具体的值</li><li>&#x3D;&#x3D; 比较引用数据类型：比较的是对象地址值</li></ul><p>结论：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;<span class="comment">// 仅放入串池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">// 仅放入堆</span></span><br><span class="line"><span class="comment">// 上面两条指令的结果和下面的 效果 相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="常见问题-2"><a href="#常见问题-2" class="headerlink" title="常见问题"></a>常见问题</h5><p>问题一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line">    <span class="comment">//jdk6：串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">    <span class="comment">//jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向 new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2 == str2.intern());<span class="comment">//false，字符串池中存在，直接返回已经存在的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>&quot;java&quot;</code> 字符串字面量就被放入的字符串常量池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Version</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">launcher_name</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_name</span> <span class="operator">=</span> <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_profile_name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">java_runtime_version</span> <span class="operator">=</span> <span class="string">&quot;1.8.0_221-b11&quot;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p><p>演示 StringTable 位置：</p><ul><li><p><code>-Xmx10m</code> 设置堆内存 10m</p></li><li><p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p></li><li><p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(j).intern());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p><h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p><ul><li><p>调整 -XX:StringTableSize&#x3D;桶个数，数量越少，性能越差</p></li><li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment"> * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_25</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//很多数据</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul><li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li><li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li><li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li><li>防止子类继承，破坏 String 的 API 的使用</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p><ul><li>String : <strong>不可变</strong>的字符序列，线程安全</li><li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li><li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li></ul><p>相同点：底层使用 char[] 存储</p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li><li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li></ul><p>常用API : </p><ul><li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li><li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li><li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li></ul><p>存储原理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//new byte[16] </span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure><p>append 源码：扩容为二倍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2</span></span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到目标字符数组中</span></span><br><span class="line"><span class="comment">// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类 Arrays</p><p>常用API：</p><ul><li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li><li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li><li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//按照数字顺序排列指定的数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//1,数组必须有序</span></span><br><span class="line">        <span class="comment">//2.如果要查找的元素存在,那么返回的是这个元素实际的索引</span></span><br><span class="line">        <span class="comment">//3.如果要查找的元素不存在,那么返回的是 (-插入点-1)</span></span><br><span class="line">            <span class="comment">//插入点:如果这个元素在数组中,他应该在哪个索引上.</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p><p>使用步骤：</p><ol><li><p>导入包：<code>import java.util.Random</code></p></li><li><p>创建对象：<code>Random r = new Random()</code></p></li><li><p>随机整数：<code>int num = r.nextInt(10)</code></p><ul><li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li><li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li></ul></li><li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p></li></ol><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 代表当前系统</p><p>静态方法：</p><ul><li><p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p></li><li><p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p></li><li><p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p><ul><li>参数一：原数组</li><li>参数二：从原数组的哪个位置开始赋值</li><li>参数三：目标数组</li><li>参数四：从目标数组的哪个位置开始赋值</li><li>参数五：赋值几个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System.exit(0); // 0代表正常终止!!</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//定义sdf 按照格式输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">System.out.println( (endTime - startTime)/<span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);<span class="comment">//程序用时</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span> ,<span class="number">20</span> ,<span class="number">30</span> ,<span class="number">40</span> ,<span class="number">50</span> ,<span class="number">60</span> ,<span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [ 0 , 0 , 0 , 0 , 0 , 0]</span></span><br><span class="line">        <span class="comment">// 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">2</span>, arr2, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p><ul><li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li></ul><p>方法：</p><ul><li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li></ul><p>时间记录的两种方式：</p><ol><li>Date 日期对象</li><li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s &#x3D; 1000ms</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + <span class="number">121</span>*<span class="number">1000</span>;<span class="comment">//过121s是什么时间</span></span><br><span class="line">        System.out.println(time);<span class="comment">//1602856875485</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d1);<span class="comment">//Fri Oct 16 22:01:15 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="comment">//运行一万次输出需要多长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p><ol><li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li><li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li></ol><p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p><p>SimpleDateFormat  简单日期格式化类：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li><li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li><li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li><li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li></ul><blockquote><p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);</span></span><br><span class="line"><span class="string">    String time = sdf.format(date);</span></span><br><span class="line"><span class="string">    System.out.println(time);//2020-10-18 19:58:34</span></span><br><span class="line"><span class="string">    //过121s后是什么时间</span></span><br><span class="line"><span class="string">    long time = date.getTime();</span></span><br><span class="line"><span class="string">    time+=121;</span></span><br><span class="line"><span class="string">    System.out.println(sdf.formate(time));</span></span><br><span class="line"><span class="string">    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致</span></span><br><span class="line"><span class="string">    Date newDate = sdf.parse(d);</span></span><br><span class="line"><span class="string">    System.out.println(sdf.format(newDate)); //按照前面的方法输出</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p><p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p><p>Calendar 的方法：</p><ul><li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li><li><code>public int get(int field)</code>：取日期中的某个字段信息</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li><li><code>public void add(int field,int amount)</code>：为某个字段增加&#x2F;减少指定的值</li><li><code>public final Date getTime()</code>：拿到此刻日期对象</li><li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInsance(); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> rightNow.get(Calendar.YEAR);<span class="comment">//获取年</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> rightNow.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月要+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> rightNow.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    rightNow.set(Calendar.YEAR , <span class="number">2099</span>);<span class="comment">//修改某个字段</span></span><br><span class="line">    rightNow.add(Calendar.HOUR , <span class="number">15</span>);<span class="comment">//加15小时  -15就是减去15小时</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> rightNow.getTime();<span class="comment">//日历对象</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rightNow.getTimeInMillis();<span class="comment">//时间毫秒值</span></span><br><span class="line">    <span class="comment">//700天后是什么日子</span></span><br><span class="line">    rightNow.add(Calendar.DAY_OF_YEAR , <span class="number">701</span>);</span><br><span class="line">    Date <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    System.out.println(sdf.format(d));<span class="comment">//输出700天后的日期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p><ul><li>LocalDate       表示日期（年月日）  </li><li>LocalTime       表示时间（时分秒）</li><li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li></ul><p>构造方法：</p><ul><li>public static LocalDateTime now()：获取当前系统时间 </li><li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li></ul><p>常用API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中的第几天（1-31）</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中的第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr><tr><td>public LocalDate  toLocalDate()</td><td>转换成为一个 LocalDate 对象（年月日）</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成为一个 LocalTime 对象（时分秒）</td></tr><tr><td>public String format(指定格式)</td><td>把一个 LocalDateTime 格式化成为一个字符串</td></tr><tr><td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td><td>把一个日期字符串解析成为一个 LocalDateTime 对象</td></tr><tr><td>public static DateTimeFormatter ofPattern(String pattern)</td><td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> localDateTime.format(pattern);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(s, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears (long years)</td><td>添加或者减去年</td></tr><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年</td></tr></tbody></table><p><strong>时间间隔</strong> Duration 类API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public int getYears()</td><td>获得这段时间的年数</td></tr><tr><td>public int getMonths()</td><td>获得此期间的总月数</td></tr><tr><td>public int getDays()</td><td>获得此期间的天数</td></tr><tr><td>public long toTotalMonths()</td><td>获取此期间的总月数</td></tr><tr><td>public static Durationbetween(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public long toSeconds()</td><td>获得此时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获得此时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获得此时间间隔的纳秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK8DateDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate1, localDate2);</span><br><span class="line">        System.out.println(period);<span class="comment">//P28Y11M11D</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime2);</span><br><span class="line">        System.out.println(duration);<span class="comment">//PT21H57M58S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p><p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取 a 的 b 次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td>public static int max(int a,int b)</td><td>返回较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回较小值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数。</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>));</span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(-<span class="number">4.00000001</span>));<span class="comment">//4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(-<span class="number">4.99999999</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">    <span class="comment">//取一位整数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//取一位整数和两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">    <span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">    <span class="comment">//取所有整数部分</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">    <span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));<span class="comment">//2.99792E8</span></span><br><span class="line">    <span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));<span class="comment">//29.9792E7</span></span><br><span class="line">    <span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));<span class="comment">//299,792,458</span></span><br><span class="line">    <span class="comment">//将格式嵌入文本</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p><p>构造方法：</p><ul><li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li><li><code>public BigDecimal(double val)</code></li><li><code>public BigDecimal(String val)</code></li></ul><p>常用API：</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li><li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li><li><code>public int intValue()</code>：转为 int 其他类型相同</li><li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。</span></span><br><span class="line">        System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">        System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span> ;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b ;</span><br><span class="line">        System.out.println(c);<span class="comment">//0.30000000000000004</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把浮点数转换成大数据对象运算</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//a1.divide(b1);也可以</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c1.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>BigDecimal 是用来进行精确计算的</li><li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li><li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line"><span class="comment">//参数1：表示参与运算的BigDecimal 对象。</span></span><br><span class="line"><span class="comment">//参数2：表示小数点后面精确到多少位</span></span><br><span class="line"><span class="comment">//参数3：舍入模式  </span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_UP  进一法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_FLOOR 去尾法</span></span><br><span class="line"><span class="comment">// BigDecimal.ROUND_HALF_UP 四舍五入</span></span><br></pre></td></tr></table></figure><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p><p>比如检验 qq 号：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQRegex</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq!=<span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数</span></span><br><span class="line">&#125;<span class="comment">// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 \ 本身</td></tr><tr><td>()</td><td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td></tr></tbody></table><h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td></tr><tr><td>\d</td><td>数字字符，0~9 中的任意一个，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于  [ ^0-9]</td></tr><tr><td>\w</td><td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td></tr><tr><td>\W</td><td>对\w取非，等价于[ ^\w]</td></tr><tr><td>\s</td><td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p><h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td></tr><tr><td>[a-d[m-p]]</td><td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td></tr><tr><td>[a-z&amp;&amp;[m-p]]</td><td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td></tr><tr><td>[^]</td><td>取反</td></tr></tbody></table><ul><li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p></li><li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p></li></ul><h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li><li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li></ul><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>X?</td><td>X 一次或一次也没，有相当于 {0,1}</td></tr><tr><td>X*</td><td>X 不出现或出现任意次，相当于 {0,}</td></tr><tr><td>X+</td><td>X 至少一次，相当于 {1,}</td></tr><tr><td>X{n}</td><td>X 恰好 n 次</td></tr><tr><td>{n,}</td><td>X 至少 n 次</td></tr><tr><td>{n,m}</td><td>X 至少 n 次，但是不超过 m 次</td></tr></tbody></table><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr></tbody></table><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p><ul><li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li><li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li></ul><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|  (分支结构)</td><td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td></tr><tr><td>()  (捕获组)</td><td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression)   非捕获组</td><td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td></tr></tbody></table><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p><ul><li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p></li><li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p></li><li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p></li><li><p>应用 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li><li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li><li>实例：43438n44</li></ul></li><li><p>应用 2：爬虫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>//匹配</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>x<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>//不匹配</span><br></pre></td></tr></table></figure></li></ul><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p><ul><li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p></li><li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p></li><li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>(?&#x3D;exp)</td><td>断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td>(?&lt;&#x3D;exp)</td><td>断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td>(?!exp)</td><td>断言此位置的后面不能匹配表达式exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言此位置的前面不能匹配表达式exp</td></tr></tbody></table></li></ul><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p><ul><li>IGNORECASE 忽略大小写模式<ul><li>匹配时忽略大小写。</li><li>默认情况下，正则表达式是要区分大小写的。</li></ul></li><li>SINGLELINE 单行模式<ul><li>整个文本看作一个字符串，只有一个开头，一个结尾。</li><li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li></ul></li><li>MULTILINE 多行模式<ul><li>每行都是一个字符串，都有开头和结尾。</li><li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li></ul></li></ul><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p><ul><li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li><li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li><li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li></ul><p>Matcher 类：</p><ul><li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li><li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li><li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li><li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;asfsdf2&amp;&amp;3323&quot;</span>);</span><br><span class="line"><span class="comment">//boolean b = m.matches();//尝试将整个字符序列与该模式匹配</span></span><br><span class="line"><span class="comment">//System.out.println(b);//false</span></span><br><span class="line"><span class="comment">//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列</span></span><br><span class="line"><span class="comment">//System.out.println(b2);//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//asfsdf2</span></span><br><span class="line"><span class="comment">//System.out.println(m.find());</span></span><br><span class="line"><span class="comment">//System.out.println(m.group());//3323</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//group(),group(0)匹配整个表达式的子字符串</span></span><br><span class="line">System.out.println(m.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+</span></span><br><span class="line"><span class="comment">//表达式对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([a-z]+)([0-9]+))&quot;</span>);<span class="comment">//不需要加多余的括号</span></span><br><span class="line"><span class="comment">//创建Matcher对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aa232**ssd445&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">1</span>));<span class="comment">//aa232  ssd445</span></span><br><span class="line">System.out.println(m.group(<span class="number">2</span>));<span class="comment">//aa     ssd</span></span><br><span class="line">            System.out.println(m.group(<span class="number">3</span>));<span class="comment">//232    445 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则表达式改为 <code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有 group(3) 因为是非捕获组</li><li>正则表达式改为 <code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));<span class="comment">//false 判断a是否在abc之外的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">//false 是否a是整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//true 是否是字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aa&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));<span class="comment">//false 只能检验单个字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密码 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;ssds3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 验证。必须是数字和字符  必须是4位</span></span><br><span class="line">    System.out.println(<span class="string">&quot;dsd22&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;A3dy&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机号码格式正确！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;.......&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1111@qq.com  zhy@pic.com.cn</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮箱格式正确！&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">// .是任意字符 \\.就是点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li><li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 1.split的基础用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line"><span class="comment">// 以“，”分割成字符串数组</span></span><br><span class="line">    String[] nameArrs = names.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.split集合正则表达式做分割</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> <span class="string">&quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;</span>;</span><br><span class="line">    <span class="comment">// 以匹配正则表达式的内容为分割点分割成字符串数组</span></span><br><span class="line">String[] nameArrs1 = names1.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用正则表达式定位出内容，替换成/</span></span><br><span class="line">System.out.println(names1.replaceAll(<span class="string">&quot;\\w+&quot;</span>,<span class="string">&quot;/&quot;</span>));<span class="comment">//风清扬/张无忌/周芷若</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> <span class="string">&quot;风清扬,张无忌,周芷若&quot;</span>;</span><br><span class="line">System.out.println(names3.replaceAll(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;-&quot;</span>));<span class="comment">//风清扬-张无忌-周芷若</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="搜索号码"><a href="#搜索号码" class="headerlink" title="搜索号码"></a>搜索号码</h5><p>找出所有 189 和 132 开头的手机号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/2023/03/04/Java/java-high/" target="_blank">了解更多java高级内容</a></p><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门</title>
      <link href="/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/04/Java/java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h1><h2 id="什么是Java语言"><a href="#什么是Java语言" class="headerlink" title="什么是Java语言"></a>什么是Java语言</h2><p>Java语言是美国Sun公司，在1995年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h2 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h2><ul><li>1995年Sun公司发布java1.0版本</li><li>1997年发布java1.1版本</li><li>1998年发布java1.2版本</li><li>2000年发布java1.4版本</li><li>2002年发布java 5 版本</li><li>2006年发布java 6 版本</li><li>2009年oracle甲骨文公司收购sun公司，并于2011年发布java7版本</li><li>2014年发布java8版本</li><li>2017年9月发布java9版本</li><li>2018年3月发布java10版本</li></ul><h1 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制表示，它只包含0，,两个数，逢二进一，1+1&#x3D;10。每一个0或者每一个1，叫做一个bit(比特，位)。</p><ol><li>十进制数据转成二进制数据：使用除以2获取余数的方式(辗转相除法)<br> <img src="/../../images/JavaSE/2022-05-12-21-20-43.png" alt="123"></li><li>二进制数据转成十进制数据<br> 示例：<table><thead><tr><th>二进制数</th><th>十进制</th></tr></thead><tbody><tr><td>1001011</td><td>2^0+ 2^1+ 2^3+ 2^6</td></tr></tbody></table></li></ol><h1 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h1><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>位(bit):一个数字0或者一个数字1，代表一位。<br>字节(Byte):每逢8位是一个字节，这是数据存储的最小单位。<br>1 Byte &#x3D; 8 bit<br>1 KB &#x3D; 1024 Byte<br>1 MB &#x3D; 1024 KB<br>1 GB &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB<br>1 PB &#x3D; 1024 TB<br>1 EB &#x3D; 1024 PB<br>1 ZB &#x3D; 1024 EB<br>1 Mbps(宽带，Mbit&#x2F;s) &#x3D; 1024 KMps &#x3D; 1024&#x2F;8KBps &#x3D; 128KB&#x2F;s</p><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><p>以前：MS -DOS(Microsoft Disk Operating System)<br>Windows:命令提示符(cmd)<br>启动：Win+R<br>输入:cmd</p><h2 id="cmd里常用命令"><a href="#cmd里常用命令" class="headerlink" title="cmd里常用命令"></a>cmd里常用命令</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>转换盘符</td><td>盘符名：</td></tr><tr><td>进入文件夹</td><td>cd 文件夹名称</td></tr><tr><td>进入多级文件夹</td><td>cd 文件夹1\文件夹2\文件夹3</td></tr><tr><td>返回上一级</td><td>cd ..</td></tr><tr><td>直接回根路径</td><td>cd \</td></tr><tr><td>查看当前内容</td><td>dir</td></tr><tr><td>清屏</td><td>cls(clear screen)</td></tr><tr><td>退出</td><td>exit</td></tr></tbody></table><h1 id="Java语言开发环境搭建"><a href="#Java语言开发环境搭建" class="headerlink" title="Java语言开发环境搭建"></a>Java语言开发环境搭建</h1><h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><p>java虚拟机，简称jvm,是运行所有java程序的假想计算机，是java程序的运行环境，是java最具有吸引力的特性之一。<br>跨平台：任何软件的运行，都必须运行在操作系统之上。<br><img src="/../../images/JavaSE/2022-05-12-22-09-00.png" alt="1"></p><h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><p>jre(java runtime environment):java程序时环境，包含jvm和运行时所需要的核心类库。<br>JDK(java development kit):java程序开发工具包，包含jre和开发人员使用的工具。<br>运行，只需要jre.开发，需要jdk.<br><img src="/../../images/JavaSE/2022-05-12-22-10-50.png" alt="2"><br>jdk下载地址： <a href="https://www.oracle.com/java/technologies/downloads/archive/">下载</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>此电脑-&gt;右键-&gt;属性</li><li>高级系统设置</li><li>环境变量</li><li>在系统变量新建</li><li>填写变量名：JAVA_HOME</li><li>变量值为java安装路径，结束为jdk….,点击确定</li><li>点击PATH</li><li>点击新建</li><li>填写%JAVA_HOME%\bin,完成</li></ol><h2 id="Hello-World入门程序"><a href="#Hello-World入门程序" class="headerlink" title="Hello World入门程序"></a>Hello World入门程序</h2><h3 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h3><p>java开发三步骤：<strong>编写、编译、运行</strong><br><img src="/../../images/JavaSE/2022-05-17-14-39-56.png" alt="167"></p><h3 id="编写Java源程序"><a href="#编写Java源程序" class="headerlink" title="编写Java源程序"></a>编写Java源程序</h3><ol><li>在d:\day01目录下新建文本文件，完整的文件名修改为HelloWorld.java,其中文件名为HelloWorld,后缀名必须为.java。</li><li>用记事本打开<blockquote><p>  使用notepad++记事本软件。</p></blockquote></li><li>写程序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWord</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="编译与运行Java源程序"><a href="#编译与运行Java源程序" class="headerlink" title="编译与运行Java源程序"></a>编译与运行Java源程序</h3><p>编译命令：</p><blockquote><p>javac + 源程序(文件名).java</p></blockquote><p>运行命令：</p><blockquote><p>java +源程序(文件名)</p></blockquote><ol><li>打开cmd(win+r,输入cmd)</li><li>cd 源程序路径（java文件所在的文件夹)</li><li>输入命令进行编译：javac +源程序(文件名).java,会发现在存放java文件的文件夹下多一个同名的.class文件</li><li>运行源程序：java +源程序(文件名)</li></ol><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><ul><li>单行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  这是一行注释信息</span></span><br></pre></td></tr></table></figure></li><li>多行注释：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>说明  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是很多说明内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>说明：在java中有特殊含义的、被保留的、不能随意使用的字符称为关键字。<br>特点：</p><ul><li>完全小写的字母。</li><li>在增强版的记事本当中(例如Notepad++)有特殊颜色。</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p></li><li><p>命名规则(硬件要求)</p><ul><li>标识符可以包含<font color="red">英文字母26个(区分大小写)、0-9数字、$(美元符号)和_(下划线)。</font></li><li>标识符不能以数字开头。</li><li>标识符不能是关键字。</li></ul></li><li><p>命名规范(软件建议)</p><ul><li>类名规范：首字母大写，后面每个单词首字母大写(大驼峰式)</li><li>变量名规范：首字母小写，后面每个单词首字母大写(小驼峰式)</li><li>方法名规范：同变量名。</li></ul></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量：在程序运行期间，固定不变的量。</p><p>常量的分类：</p><ol><li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”abc”、”Hello”、”123”</li><li>整数常量：直接写上的数字，没有小数点。例如：100、200、0、-250</li><li>浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.0</li><li>字符常量：凡是用单引号引起来的单个字符，叫做字符常量。例如：’a’,’B’,’9’,’中’</li><li>布尔常量：只有两种取值。true、false</li><li>空常量：null。代表没有任何数据。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>基本数据类型</p><ul><li>整数型 byte short int long</li><li>浮点型 float double</li><li>字符型 char</li><li>布尔型 boolean</li></ul></li><li><p>引用数据类型</p><ul><li>字符串</li><li>数组</li><li>类</li><li>接口</li><li>Lambda</li></ul></li></ol><p><img src="/../../images/JavaSE/2022-06-05-22-18-52.png" alt="16"><br><font color="red">注意事项：</font></p><ol><li>字符串不是基本类型，而是引用类型。</li><li>浮点型可能只是一个近似值，并非精确的值。</li><li>数据范围与字节不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</li><li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母作为后缀。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量：程序运行期间，内容可以发生改变的量。</p><p>创建一个变量并且使用的格式：<br>①变量类型 变量名称；&#x2F;&#x2F;创建了一个变量<br>变量名称 &#x3D; 数据值;&#x2F;&#x2F;赋值，将右边的数据值赋值交给左边的变量<br>②一步到位格式：<br>数据类型 变量名称 &#x3D; 数据值；</p><p>注意：<br>创建多个变量，那么变量的名称不能重复。<br>对于float和long类型来说，字母后缀F和L不用丢掉<br>如果使用byte或者short类型的变量，右侧的数据值不能超过左侧类型的范围。<br>没有进行赋值的变量，不能直接使用；一定要赋值之后才能使用。<br>变量使用不能超过作用域的范围。<br>可以通过一个语句来创建多个变量，不推荐这样写。</p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>当数据类型不一样时，将会发生数据类型转换<br>基本数据类型的数据范围从小到大如下：<br>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>char-&gt;int-&gt;long-&gt;float-&gt;double</p><ul><li><p>自动类型转换(隐式)</p><ol><li>特点：代码不需要进行特殊处理，自动完成。</li><li>规则：数据范围从小到大。</li></ol></li><li><p>强制类型转换(显式)</p><ol><li>特点：代码需要进行特殊的格式处理，不能自动完成。</li><li>格式：范围小的类型 范围小的变量名 &#x3D; (范围小的类型)原本范围大的数据<br>  如：int num1 &#x3D; (int) 100L;—&gt;long类型范围比int大，不能自动转换，则需要强制类型转换。</li></ol></li></ul><p>自动类型转换例子：</p><blockquote><p>&#x2F;&#x2F;左边是long类型，右边是默认的int类型，左右不一样。自动类型转换<br>&#x2F;&#x2F;int–&gt;long,符合数据范围从小到大的要求<br>long num1 &#x3D; 100</p></blockquote><blockquote><p>左边double类型，右边float类型，符合数据范围从小到大，自动类型转换<br>double num2 &#x3D; 2.7F；</p></blockquote><blockquote><p>左边float类型，右边long类型，且long–&gt;float，float数据范围更大，符合自动类型转换。<br>float num3 &#x3D; 30L;</p></blockquote><p><font color="red">注意事项(强制类型转换)：</font></p><ol><li>强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出(大数据转换为小数据)。</li><li>byte&#x2F;short&#x2F;char这三种类型都可以发生数学运算，例如加法“+”.    ‘A’+1&#x3D;66</li><li>byte&#x2F;short&#x2F;char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。</li><li>boolean类型不能发生数据类型转换。</li></ol><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><p>数字和字符的对照关系表(编码表)：<br>    ASCII码表：American Standard Code for Information Interchange,美国信息交换标准代码。<br>    Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含跟多字符。</p><p>48 –&gt; ‘0’<br>65 –&gt; ‘A’<br>97 –&gt; ‘a’</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-21-46.png" alt="3"><br><img src="/../../images/JavaSE/2022-06-07-16-27-50.png" alt="4"><br><img src="/../../images/JavaSE/2022-06-07-16-32-45.png" alt="5"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-36-53.png" alt="6"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-40-18.png" alt="7"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-45-38.png" alt="8"></p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><img src="/../../images/JavaSE/2022-06-07-16-48-58.png" alt="9"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li><p>判断语句</p></li><li><p>选择语句</p><ul><li><p>if</p></li><li><p>if else</p></li><li><p>if … else if()</p></li><li><p>switch…case<br> 注意：<img src="/../../images/JavaSE/2022-06-08-10-19-17.png" alt="10"></p></li></ul></li><li><p>循环语句</p><ul><li>for(){}</li></ul><p> <img src="/../../images/JavaSE/2022-06-08-10-23-06.png" alt="11"></p><ul><li>while</li><li>do…while</li></ul></li></ol><p>3种循环的区别<br><img src="/../../images/JavaSE/2022-06-08-10-36-33.png" alt="12"></p><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>IDE：Integrated Development Environment,集成开发环境–是一种专门用来提高java开发效率的软件。<br>免费eclipse与收费Intellij IDEA</p><p>Intellij IDEA的下载与安装：</p><p><a href="https://www.jetbrains.com/idea/download/other.html">官网下载</a></p><p>IDEA常用快捷键<br><img src="/../../images/JavaSE/2022-06-08-11-16-36.png" alt="13"><br><img src="/../../images/JavaSE/2022-07-12-17-00-19.png" alt="14"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java高级(全)</title>
      <link href="/2023/03/04/Java/java-high/"/>
      <url>/2023/03/04/Java/java-high/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p><p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p><p>数组：类型和长度一旦定义出来就都固定</p><p>作用：</p><ul><li>在开发中，很多时候元素的个数是不确定的</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li></ul><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><ul><li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p></li><li><p>栈（stack）：后进先出，先进后出 （LIFO）</p></li><li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p><p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p></li><li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p></li><li><p>树：</p><ul><li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree） </p><p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p></li><li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p><p>特点：<strong>红黑树的增删查改性能都好</strong></p></li></ul></li></ul><p>各数据结构时间复杂度对比：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png"></p><p>图片来源：<a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p><hr><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p><p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection集合的体系:</span><br><span class="line">                      Collection&lt;E&gt;(接口)</span><br><span class="line">                 /                         \</span><br><span class="line">          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)</span><br><span class="line">      /               \                  /             \</span><br><span class="line"> HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类)</span><br><span class="line"> /</span><br><span class="line">LinkedHashSet&lt;&gt;(实现类)</span><br></pre></td></tr></table></figure><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><hr><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sets.add(<span class="string">&quot;MyBatis&quot;</span>);</span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        sets.add(<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">        sets.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(sets)<span class="comment">//[]无序的;</span></span><br><span class="line">        System.out.println(sets.contains(<span class="string">&quot;java&quot;</span>));<span class="comment">//true 存在</span></span><br><span class="line">        Object[] arrs = sets.toArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;数组：&quot;</span>+ Arrays.toString(arrs));</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c1.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;ee&quot;</span>);</span><br><span class="line">        c1.addAll(c2);<span class="comment">// c1:[java,ee]  c2:[ee];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器</p><ul><li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li><li><code>E next()</code>：获取下一个元素值</li><li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li><li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li></ul></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        System.out.println(lists); <span class="comment">// lists = [aa, bb, cc]</span></span><br><span class="line"><span class="comment">//迭代器流程</span></span><br><span class="line">        <span class="comment">// 1.得到集合的迭代器对象。</span></span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="comment">// 2.使用while循环遍历。</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>List 集合继承了 Collection 集合全部的功能。</p><p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p><p>List 系列集合：</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引</p></li></ul><hr><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//多态</span></span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">    lists.add(<span class="string">&quot;java1&quot;</span>);<span class="comment">//可以重复</span></span><br><span class="line">    lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; lists.size() ; i++ ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e 插入的元素  elementData底层数组   size 插入的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">// 插入size位置，然后加一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断elementData是不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 返回默认值和最小需求容量最大的一个</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要的容量大于数组长度，进行扩容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 索引越界</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将指定索引后的数据后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity&#x2F;2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;<span class="comment">//不需要扩容计算</span></span><br><span class="line">    <span class="comment">//检查新容量是否大于最大数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span></span><br><span class="line">        <span class="comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">             &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取下一个元素时首先判断结构是否发生变化</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">       <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modCount 被其他线程改变抛出并发修改异常</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【允许删除操作】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 删除后重置 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code> 数组存储</p></li></ol><hr><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue); <span class="comment">// [1号, 2号, 3号]</span></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//1号</span></span><br><span class="line">        System.out.println(queue.removeFirst());<span class="comment">//2号</span></span><br><span class="line">        System.out.println(queue);<span class="comment">//[3号]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做一个栈 先进后出</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);<span class="comment">//addFirst(e);</span></span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack); <span class="comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span></span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        System.out.println(stack.pop());<span class="comment">//removeFirst(); 第3颗子弹</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);<span class="comment">// [第1颗子弹]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(...));</span><br></pre></td></tr></table></figure></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index&#x3D;0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index&#x3D;-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Set 系列集合：</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p><hr><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT &#x3D; new Object()</strong></p><p>Set 集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。</span><br><span class="line"><span class="number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。</span><br><span class="line">    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）</span><br><span class="line">    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。</span><br><span class="line">    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了</span><br><span class="line">    如果不相同认为不重复。</span><br><span class="line"></span><br><span class="line">            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较</span><br><span class="line">               /                     \</span><br><span class="line">            <span class="literal">false</span>                    <span class="literal">true</span></span><br><span class="line">            /                          \</span><br><span class="line">        不重复                        继续让两个对象进行equals比较</span><br><span class="line">                                       /          \</span><br><span class="line">                                     <span class="literal">false</span>        <span class="literal">true</span></span><br><span class="line">                                      /             \</span><br><span class="line">                                    不重复          重复了</span><br></pre></td></tr></table></figure></li><li><p>Set 系列集合元素无序的根本原因</p><p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><ul><li>JDK 1.8 之前：哈希表 &#x3D; 数组（初始容量16) + 链表  + （哈希算法）</li><li>JDK 1.8 之后：哈希表 &#x3D; 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul><li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li><li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li></ul></li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><hr><h4 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h4><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><hr><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>   方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><pre><code>  * 比较者大于被比较者，返回正数  * 比较者小于被比较者，返回负数  * 比较者等于被比较者，返回 0</code></pre></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">Collections.add(students,s1,s2,s3);</span><br><span class="line">        System.out.println(students);<span class="comment">//按照年龄比较 升序</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// o1比较者   o2被比较者</span></span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();<span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 重写了比较方法。</span></span><br><span class="line">    <span class="comment">// e1.compareTo(o)</span></span><br><span class="line">    <span class="comment">// 比较者：this</span></span><br><span class="line">    <span class="comment">// 被比较者：o</span></span><br><span class="line">    <span class="comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? <span class="built_in">this</span>.getName().compareTo(o.getName):result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p><hr><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="comment">//实现大顶堆</span></span><br></pre></td></tr></table></figure></li></ul><p>常用 API：</p><ul><li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列的<strong>尾部</strong></li><li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null </li><li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li><li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li></ul><hr><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p><p>Collections 有几个常用的API：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li><li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;赵&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">98.5</span>, <span class="number">66.5</span> , <span class="number">59.5</span> , <span class="number">66.5</span> , <span class="number">99.5</span> );</span><br><span class="line">        Collections.shuffle(scores);</span><br><span class="line">        Collections.sort(scores); <span class="comment">// 默认升序排序！</span></span><br><span class="line">        System.out.println(scores);</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(students,s1,s2,s3,s4);</span><br><span class="line">        Collections.sort(students,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key&#x3D;value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map集合的体系：</span><br><span class="line">        Map&lt;K , V&gt;(接口,Map集合的祖宗类)</span><br><span class="line">       /                      \</span><br><span class="line">      TreeMap&lt;K , V&gt;           HashMap&lt;K , V&gt;(实现类,经典的，用的最多)</span><br><span class="line">                                 \</span><br><span class="line">                                  LinkedHashMap&lt;K, V&gt;(实现类)</span><br></pre></td></tr></table></figure><p>Map 集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><hr><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(.....);</span><br><span class="line">        System.out.println(maps.isEmpty());<span class="comment">//false</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(<span class="string">&quot;....&quot;</span>);<span class="comment">//返回键值对象</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();<span class="comment">//获取Map集合中所有的键，</span></span><br><span class="line">        <span class="comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        <span class="comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//(1)键找值</span></span><br><span class="line">    Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key : keys) &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + maps.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Iterator&lt;String&gt; iterator = hm.keySet().iterator();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)键值对</span></span><br><span class="line">    <span class="comment">//(2.1)普通方式</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">             System.out.println(entry.getKey() + <span class="string">&quot;=&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2.2)迭代器方式</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) Lamda</span></span><br><span class="line">    maps.forEach((k,v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;==&gt;&quot;</span> + v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 &#x3D; 数组 + 链表，8 &#x3D; 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由数组+链表组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><p><a href="https://www.bilibili.com/video/BV1nJ411J7AA">参考视频</a></p><hr><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>HashMap 继承关系如下图所示：</p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li></ul><hr><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>HashMap 构造方法指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity)<span class="comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合最大容量 </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合最大容量的上限是：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span></span><br></pre></td></tr></table></figure></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p> 为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="number">0.75</span>，平均参数约为<span class="number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="number">0.5</span>)*pow(<span class="number">0.5</span>, k)/factorial(k))</span><br><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br><span class="line">一个bin中链表长度达到<span class="number">8</span>个元素的概率为<span class="number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="number">8</span>这个数字</span><br></pre></td></tr></table></figure></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)&#x3D;3，链表的平均查找长度为 n&#x2F;2，当长度为 8 时，平均查找长度为 8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，而 log(6)&#x3D;2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小于 6 则会从红黑树转回链表</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p> 原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>HashMap 中<strong>存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></li><li><p>记录 HashMap 的修改次数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br></pre></td></tr></table></figure></li><li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希表的加载因子</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size&#x2F;capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p><p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)<span class="comment">//构造指定初始容量和加载因子的空HashMap</span></span><br></pre></td></tr></table></figure></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;&#x3D; threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p></li></ul></li></ol><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"><span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// 最后调用了tableSizeFor</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putMapEntries 源码分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123;  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">            <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s &#x2F; loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><hr><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p></li><li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p><p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span></span><br><span class="line">    <span class="comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  <span class="comment">//。。。。。。。。。。。。。。</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="comment">// 如果这里允许覆盖，就直接返回了</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数量大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;"><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY &#x3D; 64 就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;<span class="comment">//int cap = 10</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n&#x3D;0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位或之后是13</span></span><br><span class="line"><span class="comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span></span><br></pre></td></tr></table></figure></li><li><p>第二次右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位或之后是15</span></span><br><span class="line"><span class="comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span></span><br></pre></td></tr></table></figure><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure></li><li><p>JDK 11</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">//无符号右移，高位补0</span></span><br><span class="line"><span class="comment">//-1补码: 11111111 11111111 11111111 11111111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最高位之前的0的位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始化的threshold赋值给newCap</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的节点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// oldCap 旧数组大小，2 的 n 次幂</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">            loHead = e;<span class="comment">//指向低位链表头节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;<span class="comment">//指向低位链表尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;<span class="comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span></span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果低位链表首节点不为null，说明有这个链表存在</span></span><br><span class="line"><span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果链表下的元素小于等于6</span></span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span></span><br><span class="line">        tab[index] = loHead.untreeify(map);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span></span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//需要构建新的红黑树了</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span></span><br><span class="line">    <span class="comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;<span class="comment">//临时变量，储存要返回的节点信息</span></span><br><span class="line">        <span class="comment">//key和value都相等，直接返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="comment">//跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//把当前节点p指向e 继续遍历</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空，说明根据key匹配到了要删除的节点</span></span><br><span class="line">        <span class="comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//node是首节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//node不是首节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//LinkedHashMap</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><hr><h4 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h4><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.keySet().iterator();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 底层获取的是 KeyIterator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="comment">// 回调 HashMap.HashIterator#nextNode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> nextNode().key; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// for 【fast-fail】，快速失败</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// iterator.next() 会调用这个函数</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li><li><p>维护顺序的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>put()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用父类HashMap的put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span></span><br><span class="line">→ afterNodeInsertion(evict);<span class="comment">// evict为true</span></span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);<span class="comment">//移除头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断 p 是否是首节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//是头节点 让p后继节点成为头节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 判断p是否是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 不是尾节点 让p后继节点指向p的前驱节点</span></span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 是尾节点 让last指向p的前驱节点</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 判断last是否是空</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// last为空说明p是尾节点或者只有p一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// last和p相互连接</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用HashMap的remove方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,<span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span></span><br><span class="line">→ afterNodeRemoval(node);</span><br></pre></td></tr></table></figure><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 让p节点与前驱节点和后继节点断开链接</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断p是否是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是头节点 让head指向p的后继节点</span></span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);<span class="comment">//把1放入尾部</span></span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());<span class="comment">//[3, 1, 4]只能存3个，移除2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p><p>成员属性：</p><ul><li><p>Entry 节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;<span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;<span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;<span class="comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator == <span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p><hr><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p><ul><li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p></li><li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p></li><li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p></li><li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">            <span class="built_in">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>泛型（Generic）：</p><ul><li>泛型就是一个标签：&lt;数据类型&gt;</li><li>泛型可以在编译阶段约束只能操作某种数据类型。</li></ul><p>注意：</p><ul><li>JDK 1.7 开始之后，泛型后面的申明可以省略不写</li><li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">lists.add(<span class="number">99.9</span>);</span><br><span class="line">lists.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">lists.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lists1.add(<span class="number">10</span>);</span><br><span class="line">lists1.add(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p><hr><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类：使用了泛型定义的类就是泛型类</p><p>泛型类格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">泛型变量建议使用 E , T , K , V</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;String&gt;();</span><br><span class="line">        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;自定义泛型类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法：定义了泛型的方法就是泛型方法</p><p>泛型方法的定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p><p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] num = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> arrToString(nums);</span><br><span class="line">     </span><br><span class="line">        String[] name = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> arrToString(names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">arrToString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        --------------</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><p>泛型接口：使用了泛型定义的接口就是泛型接口。</p><p>泛型接口的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称&lt;泛型变量&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentData</span>();</span><br><span class="line">        d.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        ................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;重写所有方法&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符：？</p><ul><li>? 可以用在使用泛型的时候代表一切类型</li><li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li><li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;AD&gt; ads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        run(bmws);</span><br><span class="line">        <span class="comment">//run(dogs);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ArrayList&lt;? extends Car&gt; car)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AD</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异常的体系:</span><br><span class="line">         Throwable(根类，不是异常类)</span><br><span class="line">      /              \</span><br><span class="line">    Error           Exception（异常，需要研究和处理）</span><br><span class="line">                    /            \</span><br><span class="line">                   编译时异常     RuntimeException(运行时异常)</span><br></pre></td></tr></table></figure><p>Exception 异常的分类:</p><ul><li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li><li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li></ul><hr><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点终止当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。。。。。。。&quot;</span>);</span><br><span class="line">        chu( <span class="number">10</span> ,<span class="number">0</span> );</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b ;<span class="comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p><p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p><p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h4><p>可以处理异常，并且出现异常后代码也不会死亡</p><ul><li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">&#125;...finall&#123;</span><br><span class="line"><span class="comment">//资源释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace(); <span class="comment">// **直接打印异常栈信息**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Throwable成员方法:</strong></p><ul><li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li><li><code>public String toString()</code>：返回此可抛出的简短描述</li><li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h4><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseDate(<span class="string">&quot;2013-03-23 10:19:23&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseDate</span><span class="params">(String time)</span> <span class="keyword">throws</span> Exception&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常：NumberFormatException</li></ol><hr><h3 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h3><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            chu(<span class="number">10</span> / <span class="number">0</span>);<span class="comment">//ArithmeticException: / by zero</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作成功！&quot;</span>);<span class="comment">//没输出</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;操作失败！&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>  &#123; System.out.println( a / b );&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>用在捕获处理的异常格式中的，放在最后面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>: <span class="number">1</span>次。</span><br><span class="line"><span class="keyword">catch</span>：<span class="number">0</span>-N次  (如果有<span class="keyword">finally</span>那么<span class="keyword">catch</span>可以没有!!)</span><br><span class="line"><span class="keyword">finally</span>: <span class="number">0</span>-<span class="number">1</span>次</span><br></pre></td></tr></table></figure><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(chu());<span class="comment">//一定会输出 finally,优先级比return高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">chu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">return</span> a ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====finally被执行&quot;</span>);</span><br><span class="line">            <span class="comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/cang.png&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==finally被执行===&quot;</span>);</span><br><span class="line">            <span class="comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h2><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li></ul><p>throws：用在方法上，用于抛出方法中的异常</p><p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(<span class="number">101</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIllegalException &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>)&#123;<span class="comment">//年龄在0-200之间</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;/ age is illegal!&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄是：&quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    Alt + Insert-&gt;Constructor </span><br><span class="line">&#125;<span class="comment">//编译时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//运行时异常</span></span><br></pre></td></tr></table></figure><hr><h2 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h2><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li><li>在 try&#x2F;catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//请输入一个合法的年龄</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入您的年年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄：&quot;</span>+age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;您的年龄是瞎输入的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda 表达式的格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line"><span class="comment">//被重写方法的方法体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h3 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h3><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p><ul><li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach((s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">names.forEach(s -&gt; System.out.println(s) );</span><br></pre></td></tr></table></figure><hr><h3 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h3><p>Comparator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//...s1 s2 s3</span></span><br><span class="line">        Collections.addAll(lists , s1 , s2 , s3);</span><br><span class="line">        Collections.sort(lists, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> t1.getAge() - t2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 参数类型可以省略,最简单的</span></span><br><span class="line">        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lists.forEach( s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 方法引用！</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义集合加入几个Student元素</span></span><br><span class="line"><span class="comment">// 使用静态方法进行简化！</span></span><br><span class="line">Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));</span><br><span class="line"><span class="comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span></span><br><span class="line">Collections.sort(lists, Student::compareByAge);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1 , Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">        <span class="comment">// 对象是 System.out = new PrintStream();</span></span><br><span class="line">        <span class="comment">// 实例方法：println()</span></span><br><span class="line">        <span class="comment">// 前后参数正好都是一个</span></span><br><span class="line">        lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Patricia&quot;</span>,<span class="string">&quot;Dlei&quot;</span> , <span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Boom&quot;</span>, <span class="string">&quot;Cao&quot;</span> ,<span class="string">&quot;black&quot;</span> ,</span><br><span class="line">                <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>,<span class="string">&quot;cao&quot;</span>,<span class="string">&quot;after&quot;</span>,<span class="string">&quot;sa&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</span></span><br><span class="line">        <span class="comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span></span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.compareToIgnoreCase(s2);<span class="comment">//按照元素的首字符(忽略大小写)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特定类型的方法引用：</span></span><br><span class="line">        Arrays.sort(strs,  String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合默认只能转成Object类型的数组。</span></span><br><span class="line">        Object[] objs = lists.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span></span><br><span class="line">        String[] strs = lists.toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String[] strs1 = lists.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]);</span><br><span class="line">        String[] strs2 = lists.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的数组：&quot;</span>+ Arrays.toString(strs2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p><ul><li>可以解决已有集合类库或者数组 API 的弊端</li><li>Stream 流简化集合和数组的操作</li><li>链式编程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p><p>数组：Arrays.stream(数组)   &#x2F;  Stream.of(数组);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection集合获取Stream流。</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; listStream = c.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map集合获取流</span></span><br><span class="line"><span class="comment">// 先获取键的Stream流。</span></span><br><span class="line">Stream&lt;String&gt; keysStream = map.keySet().stream();</span><br><span class="line"><span class="comment">// 在获取值的Stream流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = map.values().stream();</span><br><span class="line"><span class="comment">// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组获取流</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaEE&quot;</span> ,<span class="string">&quot;Spring Boot&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;String&gt; arrStream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>逐一处理（遍历）</td></tr><tr><td>long count</td><td>返回流中的元素数</td></tr><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</T></td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</T></td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream<T> skip(long n)</T></td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</R></R></td><td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</T></T></td><td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td></tr><tr><td>Stream<T> distinct()</T></td><td>返回由该流的不同元素组成的流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>); list.add(<span class="string">&quot;周芷若&quot;</span>); list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>); list.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">        <span class="comment">//取以张开头并且名字是三位数的</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)</span><br><span class="line">                .filter(s -&gt; s.length == <span class="number">3</span>).count();</span><br><span class="line"><span class="comment">//取前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).limit(<span class="number">2</span>).forEach(...);</span><br><span class="line"><span class="comment">//跳过前两个</span></span><br><span class="line">list.stream().filter(s -&gt; s.length == <span class="number">3</span>).skip(<span class="number">2</span>).forEach(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：把名称都加上“张三的:+xxx”</span></span><br><span class="line">list.stream().map(s -&gt; <span class="string">&quot;张三的&quot;</span> + s).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 需求：把名称都加工厂学生对象放上去!!</span></span><br><span class="line"><span class="comment">// list.stream().map(name -&gt; new Student(name));</span></span><br><span class="line">list.stream.map(Student::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">                                          </span><br><span class="line"><span class="comment">//数组流</span></span><br><span class="line">Stream&lt;Integer&gt; s1 = Stream.of(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">//集合流</span></span><br><span class="line">Stream&lt;String&gt; s2 = list.stream();</span><br><span class="line"><span class="comment">//合并流</span></span><br><span class="line">Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);</span><br><span class="line">s3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure><hr><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreach终结方法</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">    .filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h3 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h3><p>收集 Stream：把 Stream 流的数据转回到集合中去</p><ul><li>Stream 流：工具</li><li>集合：目的</li></ul><p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p><p>Collectors 方法：</p><ul><li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li><li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li><li><code>Object[] toArray()</code>：把元素收集数组中</li><li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));    </span><br><span class="line">    <span class="comment">//把stream流转换成Set集合。</span></span><br><span class="line">    Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成List集合。</span></span><br><span class="line">    <span class="comment">//重新定义，因为资源已经被关闭了</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把stream流转换成数组。</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    Object[] arr = stream2.toArray();</span><br><span class="line">    <span class="comment">// 可以借用构造器引用申明转换成的数组类型！！！</span></span><br><span class="line">    String[] arr1 = stream2.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p><p>File 类构造器：</p><ul><li><code>public File(String pathname)</code>：根据路径获取文件对象</li><li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li></ul><p>File 类创建文件对象的格式：</p><ul><li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p><ul><li>绝对路径：从磁盘的的盘符一路走到目的位置的路径<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li><li>一般是定位某个操作系统中的某个文件对象</li></ul></li><li><strong>相对路径</strong>：不带盘符的（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件，可以跨平台</li></ul></li></ul></li><li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象：使用绝对路径</span></span><br><span class="line">        <span class="comment">// 文件路径分隔符：</span></span><br><span class="line">        <span class="comment">//      -- a.使用正斜杠： /</span></span><br><span class="line">        <span class="comment">//      -- b.使用反斜杠： \\</span></span><br><span class="line">        <span class="comment">//      -- c.使用分隔符API:File.separator</span></span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator</span></span><br><span class="line"><span class="comment">//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 获取文件的大小，字节大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建文件对象：使用相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Day09Demo/src/dlei.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建文件对象：代表文件夹。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片资源&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists());<span class="comment">// 判断路径是否存在！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getAbsolutePath()</td><td>返回此 File 的绝对路径名字符串</td></tr><tr><td>String getPath()</td><td>获取创建文件对象的时候用的路径</td></tr><tr><td>String getName()</td><td>返回由此 File 表示的文件或目录的名称</td></tr><tr><td>long length()</td><td>返回由此 File 表示的文件的长度（大小）</td></tr><tr><td>long length(FileFilter filter)</td><td>文件过滤器</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/图片/test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.相对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>方法列表：</p><ul><li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li><li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li><li><code>boolean isFile()</code>：此 File 表示的是否为文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// a.判断文件路径是否存在</span></span><br><span class="line">System.out.println(f.exists()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// b.判断文件对象是否是文件,是文件返回true ,反之</span></span><br><span class="line">System.out.println(f.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// c.判断文件对象是否是文件夹,是文件夹返回true ,反之</span></span><br><span class="line">System.out.println(f.isDirectory()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h4><p>方法列表：</p><ul><li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li><li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li><li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li><li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.创建新文件，创建成功返回true ,反之</span></span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f.delete());</span><br><span class="line">        <span class="comment">// 不能删除非空文件夹，只能删除空文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/it/aaaaa&quot;</span>);</span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/bbbb&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d.创建多级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><ul><li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li><li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li><li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\seazean&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。</span></span><br><span class="line">        String[] names = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\图片资源\\beautiful.jpg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified(); <span class="comment">// 最后修改时间！</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>递归实现文件搜索（非规律递归）</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去某个目录下搜索某个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 搜索文件的目录。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName 搜索文件的名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFiles</span><span class="params">(File dir , String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断是否存在该路径，是否是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(dir.exists() &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">        <span class="comment">// 2.提取当前目录下的全部一级文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">files</span> <span class="operator">=</span> dir.listFiles();<span class="comment">// 可能是null/也可能是空集合[]</span></span><br><span class="line">        <span class="comment">// 3.判断是否存在一级文件对象,判断是否不为空目录</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.判断一级文件对象</span></span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="comment">// 5.判断file是文件还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 6.判断该文件是否为我要找的文件对象</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;<span class="comment">//模糊查找</span></span><br><span class="line">                        sout(f.getAbsolutePath());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 启动它（拓展）</span></span><br><span class="line">                            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                            r.exec(f.getAbsolutePath());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 7.该文件是文件夹，文件夹要递归进入继续寻找</span></span><br><span class="line">                    searchFiles(file,fileName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>字符集：为字符编制的一套编号规则</p><p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p><p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 &#x3D; 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  97</span><br><span class="line">b  98</span><br><span class="line"></span><br><span class="line">A  65</span><br><span class="line">B  66</span><br><span class="line"></span><br><span class="line">0  48</span><br><span class="line">1  49</span><br></pre></td></tr></table></figure><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p><p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p><ul><li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li><li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li></ul><p>编码前与编码后的编码集必须一致才不会乱码</p><hr><h2 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>IO 输入输出流：输入&#x2F;输出流</p><ul><li>Input：输入</li><li>Output：输出</li></ul><p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p><p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p><p>IO 流的分类：</p><ul><li>按照流的方向分为：输入流，输出流。<ul><li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li></ul></li><li>按照流的内容分为：字节流，字符流<ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li></ul></li></ul><p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IO 流的体系：</span><br><span class="line">        字节流                                   字符流</span><br><span class="line">  字节输入流              字节输出流            字符输入流         字符输出流</span><br><span class="line">InputStream           OutputStream          Reader            <span class="title function_">Writer</span>   <span class="params">(抽象类)</span></span><br><span class="line">FileInputStream       FileOutputStream      FileReader        <span class="title function_">FileWriter</span><span class="params">(实现类)</span></span><br><span class="line">BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="title function_">BufferedWriter</span><span class="params">(实现类缓冲流)</span></span><br><span class="line">                                           InputStreamReader OutputStreamWriter</span><br><span class="line">ObjectInputStream     ObjectOutputStream</span><br></pre></td></tr></table></figure><hr><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h4><p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p><p>构造方法：</p><ul><li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li><li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象</li></ul><p>方法：</p><ul><li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li><li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li><li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li><li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象定位dlei01.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/dlei01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 3.读取一个字节的编号返回，读取完毕返回-1</span></span><br><span class="line"><span class="comment">//int code1 = is.read(); // 读取一滴水，一个字节</span></span><br><span class="line"><span class="comment">//System.out.println((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.使用while读取字节数</span></span><br><span class="line">        <span class="comment">// 定义一个整数变量存储字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>((ch = is.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p><p>采取下面的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//简化写法，底层实质上创建了File对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];<span class="comment">//开发中使用byte[1024]</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取了多少就倒出多少！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"><span class="comment">// 读取全部的</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer);</span><br><span class="line">System.out.println(rs);</span><br></pre></td></tr></table></figure><hr><h4 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h4><p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p><p>构造方法：</p><ul><li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li><li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li><li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li><li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li></ul><p>API：</p><ul><li><p><code>public void write(int a)</code>：写一个字节出去 </p></li><li><p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p></li><li><p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p></li><li><p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p><ul><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot;)</code>：覆盖数据管道</li><li><code>OutputStream os = new FileOutputStream(&quot;Demo/out05&quot; , true)</code>：追加数据的管道</li></ul></li></ul><p>说明：</p><ul><li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li><li>换行用：<strong>os.write(“\r\n”.getBytes())</strong></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/out05&quot;</span>);</span><br><span class="line">os.write(<span class="number">97</span>);<span class="comment">//a</span></span><br><span class="line">os.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">os.write(<span class="string">&quot;我爱Java&quot;</span>.getBytes());</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//（1）创建一个字节输入流管道与源文件接通。</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（2）创建一个字节输出流与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\test.jpg&quot;</span>);</span><br><span class="line">            <span class="comment">//（3）创建一个字节数组作为桶</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//（4）从字节输入流管道中读取数据，写出到字节输出流管道即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**（5）关闭资源！ */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">                <span class="keyword">if</span>(is!=<span class="literal">null</span>)is.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h4><p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p><p>构造器：</p><ul><li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li><li><code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li></ul><p>方法：</p><ul><li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li><li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li></ul><p>结论：</p><ul><li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li><li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li></ul><p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span>&#123;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个字符输入流管道与源文件路径接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;<span class="comment">//字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h4><p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p><p>构造器：</p><ul><li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li><li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li><li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li><li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li></ul><p>方法：</p><ul><li><code>public void write(int c)</code>：写一个字符出去</li><li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li><li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li><li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li><li><code>fw.write(&quot;\r\n&quot;)</code>：换行</li></ul><p>读写字符文件数据建议使用字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">fw.write(<span class="number">97</span>);   <span class="comment">// 字符a</span></span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 字符b</span></span><br><span class="line">fw.write(<span class="string">&quot;Java是最优美的语言！&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">fw.close;</span><br></pre></td></tr></table></figure><hr><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲流可以提高字节流和字符流的读写数据的性能</p><p>缓冲流分为四类：</p><ul><li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li><li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li><li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li><li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li></ul><hr><h4 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h4><p>字节缓冲输入流：BufferedInputStream</p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p><p>构造器：<code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个低级的字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。</span></span><br><span class="line">        <span class="type">BufferInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferInputStream</span>(is);</span><br><span class="line">        <span class="comment">// 3.定义一个字节数组按照循环读取。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h4><p>字节缓冲输出流：BufferedOutputStream</p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.写一个原始的字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把低级的字节输出流包装成一个高级的缓冲字节输出流</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 3.写数据出去</span></span><br><span class="line">        bos.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bos.write(<span class="number">100</span>);</span><br><span class="line">        bos.write(<span class="string">&quot;我爱中国&quot;</span>.getBytes());</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h4><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p><p>复制流：</p><ul><li>使用低级的字节流按照一个一个字节的形式复制文件</li><li>使用低级的字节流按照一个一个字节数组的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li><li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li></ul><p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p><hr><h4 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h4><p>字符缓冲输入流：BufferedReader</p><p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p><p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个原始的字符输入流读取源文件</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">    <span class="comment">// 定义一个字符串变量存储每行数据</span></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">    <span class="comment">//淘汰数组循环读取</span></span><br><span class="line">    <span class="comment">//char[] buffer = new char[1024];</span></span><br><span class="line">    <span class="comment">//int len;</span></span><br><span class="line">    <span class="comment">//while((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.println(new String(buffer , 0 , len));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h4><p>符缓冲输出流：BufferedWriter</p><p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code></p><p> 原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p><p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>,<span class="literal">true</span>);<span class="comment">//追加</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    </span><br><span class="line">    bw.write(<span class="string">&quot;我爱学习Java&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//换行</span></span><br><span class="line">    bw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h4><p>字符型缓冲流高效的原因：（空间换时间）</p><ul><li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li><li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li></ul><p>字节型缓冲流高效的原因：</p><ul><li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li><li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。</li></ul><p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p><hr><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h4><p>字符流读取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码编码            文件编码         中文情况。</span><br><span class="line">UTF-8              UTF-8           不乱码!</span><br><span class="line">GBK                GBK             不乱码!</span><br><span class="line">UTF-8              GBK             乱码!</span><br></pre></td></tr></table></figure><ul><li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li><li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li></ul><hr><h4 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h4><p>字符输入转换流：InputStreamReader</p><p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li><li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.提取GBK文件的原始字节流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\Netty.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        <span class="comment">// 3.包装成缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h4><p>字符输出转换流：OutputStreamWriter</p><p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;我在学习Java&quot;</span>);   </span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 &#x3D;&gt; 文件中</p><p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 &#x3D;&gt; 对象</p><p>transient 关键字修饰的成员变量，将不参与序列化</p><hr><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p><p>作用：把内存中的 Java 对象数据保存到文件中去</p><p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建User用户对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;seazean&quot;</span>,<span class="string">&quot;980823&quot;</span>,<span class="string">&quot;七十一&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建低级的字节输出流通向目标文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.通过对象字节输出流序列化对象：</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        <span class="comment">// 5.释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化对象成功~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">// get+set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化为二进制数据</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(obj);<span class="comment">// 将该对象序列化为二进制数据</span></span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] bytes = bos.toByteArray();</span><br></pre></td></tr></table></figure><hr><h4 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h4><p>对象反序列化（对象字节输入流）：ObjectInputStream</p><p>作用：读取序列化的对象文件恢复到 Java 对象中</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p><p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/obj.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)ois.readObject();<span class="comment">//反序列化</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流 PrintStream &#x2F; PrintWriter</p><p>打印流的作用：</p><ul><li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li><li>PrintStream&#x2F;PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li><li><strong>System.out.print() 底层基于打印流实现的</strong></li></ul><p>构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><p>System 类：</p><ul><li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/test.txt&quot;</span>);</span><br><span class="line">        ps.println(任何类型的数据);</span><br><span class="line">        ps.print(不换行);</span><br><span class="line">        ps.write(<span class="string">&quot;我爱你&quot;</span>.getBytes());</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean0==&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;Demo/src/log.txt&quot;</span>);</span><br><span class="line">        System.setOut(ps); <span class="comment">// 让系统的输出流向打印流</span></span><br><span class="line"><span class="comment">//不输出在控制台，输出到文件里</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean1==&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==seazean2==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h2><p>try-with-resources：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    <span class="comment">// 这里只能放置资源对象，用完会自动调用close()关闭</span></span><br><span class="line">)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p><p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"><span class="comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （2）创建一个字节输出流与目标文件接通。*/</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);</span><br><span class="line"><span class="comment">/** （5）关闭资源！是自动进行的 */</span></span><br><span class="line">)&#123;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p><p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p><p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key&#x3D;value</p><p>Properties 方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key, String value)</td><td>设置集合的键和值，底层调用 Hashtable 方法 put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String>   stringPropertyNames()</String></td><td>所有键的名称的集合</td></tr><tr><td>synchronized void load(Reader r)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>synchronized void load(InputStream in)</td><td>加载属性文件的数据到属性集对象中去</td></tr><tr><td>void store(Writer w, String comments)</td><td>将此属性列表(键和元素对)写入 Properties 表</td></tr><tr><td>void store(OutputStream os, String comments)</td><td>保存数据到属性文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.创建一个属性集对象：Properties的对象。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//&#123;&#125;</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span> , <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// b.把属性集对象的数据存入到属性文件中去（重点）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>);</span><br><span class="line">        properties.store(os,<span class="string">&quot;i am very happy!!我保存了用户数据!&quot;</span>);</span><br><span class="line">        <span class="comment">//参数一：被保存数据的输出管道</span></span><br><span class="line">        <span class="comment">//参数二：保存心得。就是对象保存的数据进行解释说明！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//底层基于map集合</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        </span><br><span class="line">Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(s);</span><br><span class="line">            System.out.println(s + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h2><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p><p>构造器：</p><ul><li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li><li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li></ul><p>常用方法：</p><ul><li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li><li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li><li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    rf.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">    rf.seek(<span class="number">5</span>);<span class="comment">//helloxxxxld</span></span><br><span class="line">    rf.write(<span class="string">&quot;xxxx&quot;</span>.getBytes());</span><br><span class="line">    rf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h2><p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p><p>commons-io 工具包提供了很多有关 IO 操作的类：</p><table><thead><tr><th>包</th><th align="left">功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td align="left">有关 Streams、Readers、Writers、Files 的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td align="left">输入流相关的实现类，包含 Reader 和 InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td align="left">输出流相关的实现类，包含 Writer 和 OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td align="left">序列化相关的类</td></tr></tbody></table><p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.完成文件复制！</span></span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>), </span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.完成文件复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyFileToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Demo/src/books.xml&quot;</span>),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/it&quot;</span>));</span><br><span class="line">        <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line">        FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\it\\图片服务器&quot;</span>) ,</span><br><span class="line">                                           <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。</span></span><br><span class="line">        Files.copy(Paths.get(<span class="string">&quot;Demo/src/books.xml&quot;</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/new11.txt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p><p>单元测试：</p><ul><li>单元：在 Java 中，一个类就是一个单元<br>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试</li></ul><p></p><p>Junit 单元测试框架的作用：</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li><li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li></ul><p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p><p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p><ul><li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li><li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li></ul><p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p><ul><li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li><li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li></ul><p>作用：</p><ul><li>开始执行的方法：初始化资源</li><li>执行完之后的方法：释放资源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">     <span class="comment">// @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</span></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">/**断言预期结果的正确性。</span></span><br><span class="line"><span class="comment">         * 参数一：测试失败的提示信息。</span></span><br><span class="line"><span class="comment">         * 参数二：期望值。</span></span><br><span class="line"><span class="comment">         * 参数三：实际值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;登录业务功能方法有错误，请检查！&quot;</span>,<span class="string">&quot;success&quot;</span>,rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.chu(<span class="number">10</span> , <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h2><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p><ul><li><p>构造器对象：Constructor</p></li><li><p>成员变量对象：Field</p></li><li><p>成员方法对象：Method</p></li></ul><p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p><p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p><ul><li><code>Class c = HelloWorld.class</code></li></ul><p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p><p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p><p>反射的优点：</p><ul><li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li></ul><p>反射的缺点：</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li><li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li><li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li></ul><hr><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p><ul><li>类名.class</li><li>类的对象.getClass()</li><li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li></ul><p>Class 类下的方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getSimpleName()</td><td>获得类名字符串：类名</td></tr><tr><td>String getName()</td><td>获得类全名：包名+类名</td></tr><tr><td>T newInstance()</td><td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。</span></span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);<span class="comment">//class _03反射_获取Class类对象.Student</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> swk.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName(&quot;类的全限名&quot;)</span></span><br><span class="line">        <span class="comment">// 直接去加载该类的class文件。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;_03反射_获取Class类对象.Student&quot;</span>);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获取类名本身（简名）Student</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取类的全限名_03反射_获取Class类对象.Student</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h3><p>获取构造器的 API：</p><ul><li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li><li>Constructor getDeclaredConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li><li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li><li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li></ul><p>Constructor 的常用 API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>创建对象，注入构造器需要的数据</td></tr><tr><td>void setAccessible(true)</td><td>修改访问权限，true 攻破权限（暴力反射）</td></tr><tr><td>String getName()</td><td>以字符串形式返回此构造函数的名称</td></tr><tr><td>int getParameterCount()</td><td>返回参数数量</td></tr><tr><td>Class&lt;?&gt;[] getParameterTypes</td><td>返回参数类型数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位全部构造器，只要申明了就可以拿到</span></span><br><span class="line">        Constructor[] cons = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历这些构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor con : cons) &#123;</span><br><span class="line">            System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位某个构造器，根据参数匹配，只要申明了就可以获取</span></span><br><span class="line">        <span class="comment">//Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//有参数的！!</span></span><br><span class="line">        <span class="comment">// c.构造器名称和参数</span></span><br><span class="line">        System.out.println(con.getName()+<span class="string">&quot;-&gt;&quot;</span>+con.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器被执行~~~~&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用无参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位无参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// c.暴力打开私有构造器的访问权限</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// d.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(); <span class="comment">// 最终还是调用无参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用有参数构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObj02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步是先得到Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class ;</span><br><span class="line">        <span class="comment">// b.定位有参数构造器对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class , <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// c.通过无参数构造器初始化对象返回</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">swk</span> <span class="operator">=</span> (Student) constructor.newInstance(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>); <span class="comment">// 最终还是调用有参数构造器的！</span></span><br><span class="line">        System.out.println(swk);<span class="comment">//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h3><p>获取 Field 成员变量 API：</p><ul><li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li><li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li><li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li><li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到</li></ul><p>Field 的方法：给成员变量赋值和取值</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td></tr><tr><td>Object get(Object obj)</td><td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td></tr><tr><td>void setAccessible(true)</td><td>暴力反射，设置为可以直接访问私有类型的属性</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回 Class 对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo</span> &#123;</span><br><span class="line">    <span class="comment">//获取全部成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.获取全部申明的成员变量对象</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName()+<span class="string">&quot;-&gt;&quot;</span>+field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取某个成员变量</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.定位某个成员变量对象 :根据名称定位！！</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(ageF.getName()+<span class="string">&quot;-&gt;&quot;</span>+ageF.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_1</span> <span class="operator">=</span> <span class="string">&quot;宠物学校&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射的第一步获取Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.定位name成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// c.为这个成员变量赋值！</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(d,<span class="string">&quot;泰迪&quot;</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;</span></span><br><span class="line">        <span class="comment">// d.获取成员变量的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> name.get(d)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(value);<span class="comment">//泰迪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取 Method 方法 API：</p><ul><li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li><li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li><li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li><li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li></ul><p>Method 常用 API：</p><ul><li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span>&#123;</span><br><span class="line">    <span class="comment">//获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.先获取class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class ;</span><br><span class="line">        <span class="comment">// b.获取全部申明的方法!</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历这些方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    + method.getParameterCount()+<span class="string">&quot;-&gt;&quot;</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">// c.触发方法执行!</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> run.invoke(d);</span><br><span class="line">        System.out.println(o);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力反射！</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//参数一：被触发方法所在的对象  参数二：方法需要的入参值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> eat.invoke(d,<span class="string">&quot;肉&quot;</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// 如果方法没有返回值，结果是null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span>&#123;System.out.println(<span class="string">&quot;狗吃&quot;</span>+name);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;在吉山区有一只单身狗！&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h2><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p><ol><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        scores.add(<span class="number">99.3</span>);</span><br><span class="line">        scores.add(<span class="number">199.3</span>);</span><br><span class="line">        scores.add(<span class="number">89.5</span>);</span><br><span class="line">        <span class="comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。</span></span><br><span class="line">        <span class="comment">// a.先得到集合对象的Class文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> scores.getClass();</span><br><span class="line">        <span class="comment">// b.从ArrayList的Class对象中定位add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        <span class="comment">// c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）</span></span><br><span class="line">        add.invoke(scores, <span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">        System.out.println(scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p><ul><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li><li><strong>父类中的注解是不能被子类继承的</strong></li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><hr><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">     <span class="comment">// 注解属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解的格式：@注解名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Book</span></span><br><span class="line"><span class="meta">@MyTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBook</span> &#123;</span><br><span class="line">    <span class="comment">//方法变量都可以注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h2><h3 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h3><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p><p>属性的格式：</p><ul><li>格式 1：数据类型 属性名()</li><li>格式 2：数据类型 属性名() default 默认值</li></ul><p>属性适用的数据类型:</p><ul><li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li><li>以上类型的数组形式都支持</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span> &#123;</span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,</span></span><br><span class="line"><span class="meta">     price = 19.9 , address = &quot;北京&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义一个注解</span></span><br><span class="line"><span class="meta">@interface</span> MyBook&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String[] authors(); <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;武汉&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p>注解的特殊属性名称：value</p><ul><li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li><li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Book(&quot;/deleteBook.action&quot;)</span></span><br><span class="line"><span class="meta">@Book(value = &quot;/deleteBook.action&quot; , age = 12)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是 sun 公司提供的，用来注解自定义注解</p><p>元注解有四个：</p><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo01</span>&#123;</span><br><span class="line">    <span class="comment">// @MyTest // 只能注解方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 申明只能注解方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 申明注解从写代码一直到运行还在，永远存活！！</span></span><br><span class="line"><span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>注解解析相关的接口：</p><ul><li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li><li>AnnotatedElement：该接口定义了与注解解析相关的方法</li><li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li></ul><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定位Class类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// 2.判断这个类上是否使用了某个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="comment">// 3.获取这个注解对象</span></span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)c.getDeclarAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.authors()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(run.isAnnotationPresent(Book.class))&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> (Book)run.getDeclaredAnnotation(Book.class);</span><br><span class="line">           sout(上面的三个);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;张三&quot;,&quot;李四&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line">    <span class="meta">@Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;王五&quot;,&quot;小六&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">// 类和成员方法上使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解永久存活</span></span><br><span class="line"><span class="meta">@interface</span> Book&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] authors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Seazean/JavaNote.git">在此感谢github大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识jvm内存模型</title>
      <link href="/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/04/jvm/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h1><p><img src="/../../images/jvm/jvm-memory/jvm_classloader.png" alt="jvm_classloader"></p><p>​    区别于Java内存模型，<strong>JVM内存模型是指JVM虚拟机在运行Java程序时，所使用的内存结构和管理方式。</strong>JVM内存模型包括以下几个部分：</p><ol><li><p>程序计数器(Program Counter Register)</p><p>​    Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>总的来说：<font color="red">每个线程都有一个程序计数器，用于记录当前执行的指令地址。</font></p></li><li><p>虚拟机栈(Java Virtual Machine Stacks)<br>每个线程都有一个虚拟机栈，用于存储<font color="red">局部变量、方法参数、方法返回值以及操作数栈。</font>每个方法在执行时都会创建一个栈帧，用于存储该方法的局部变量、操作数栈等信息。当该方法运行完后便出栈。当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError,如果虚拟机栈可以动态扩展，若无法申请到足够的内存，抛出OutOfMemoryError异常。<br><img src="/../../images/jvm/jvm-memory/2022-12-03-11-13-42.png" alt="2022-12-03-11-13-42"></p></li><li><p>本地方法栈(Native Method Stack)<br> JVM 为 Native 方法执行而开辟的一块栈空间，<font color="red">用于存储本地方法的参数和局部变量等信息。</font>本地方法栈与虚拟机栈类似，都是栈结构，但两者是不同的概念和实现方式。（本地方法栈不受 JVM 内存管理机制的控制）</p></li><li><p>堆(Heap)<br>又称为GC堆，垃圾收集器管理的主要区域，是所有线程共享的内存区域，<font color="red">用于存储Java对象实例和数组。</font>现在的收集器基本都采用分代收集算法，即java堆又可以细分为：新生代和老年代。其中新生代又分为 Eden 区、Survivor 区 1 和 Survivor 区 2。堆内存的大小可以通过JVM启动参数进行调整。JVM 会通过垃圾回收机制来自动管理堆内存，包括垃圾收集和内存分配等操作。 </p></li><li><p>方法区(Method Area)<br>方法区也是所有线程共享的内存区域，<font color="red">用于存储类信息、常量池、静态变量、即时编译器编译后的代码等。</font>该区 是 JVM 内存模型中唯一没有规定垃圾回收方式的区域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm内存布局/内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载</title>
      <link href="/2023/03/03/jvm/jvm-classloader/"/>
      <url>/2023/03/03/jvm/jvm-classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="JVM的内存布局-x2F-内存模型"><a href="#JVM的内存布局-x2F-内存模型" class="headerlink" title="JVM的内存布局&#x2F;内存模型"></a>JVM的内存布局&#x2F;内存模型</h2><p><img src="/../../images/jvm/jvm-classloader/jvm_classloader.png" alt="01_2"></p><p>完整：</p><p><img src="/../../images/jvm/jvm-classloader/1677831036747.png" alt="1677831036747"></p><h2 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h2><p><img src="/../../images/jvm/jvm-classloader/1677831559346.png" alt="1677831519784"></p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>​    Java类加载是指将类的字节码文件加载到 JVM 中，使得这些类在程序运行时可以被使用。Java类加载的过程主要包括三个阶段：加载、链接（连接）和初始化。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><strong>加载阶段</strong></h4><p>​    在加载阶段，JVM会查找并加载类的字节码文件。首先，JVM会通过类的全限定名查找类文件，如果找不到，则会抛出ClassNotFoundException异常；如果找到了，就会将字节码文件加载到内存中，并在方法区中生成一个代表这个类的Class对象，这个过程也被称为类的装载,如 <a href="#classloader">类加载器ClassLoader</a> 的第一个图片。</p><p>​    Java类的加载是通过类加载器（ClassLoader）来完成的。类加载器负责查找和加载类的字节码文件，并生成表示这个类的Class对象。在加载阶段，JVM需要完成以下工作：</p><ul><li>通过类的全限定名查找字节码文件，并将其读入内存。</li><li>解析字节码文件，并生成表示这个类的Class对象。</li><li>在方法区中为这个类分配内存，并存储类的相关信息。<br>这工作在《深入理解Java虚拟机》第三版中的解释为：</li><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据<br>的访问入口。</li></ul><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><strong>链接阶段</strong></h4><p>​    在链接阶段，JVM会对类进行<strong>验证</strong>、<strong>准备</strong>和<strong>解析</strong>三个步骤：</p><p><font color="red">验证</font>：验证字节码文件是否符合Java语言规范以及JVM规范，包括语法检查、语义检查、字节码验证、符号引用验证等。如果验证不通过，则会抛出VerifyError异常。</p><p><font color="red">准备</font>：为类的静态变量分配内存，并设置初始值。这些变量在类加载时会被设置为默认值（0或null）。<strong>变量所使用的内存在方法区</strong></p><p><font color="red">解析</font>：将类中的符号引用（如类、方法、字段等）转换为直接引用。符号引用是一种符号形式的引用，需要通过解析才能转换为直接引用，以便JVM能够定位到对应的类、方法或字段。注意，该阶段可以在初始化后进行，如运行时需要动态绑定，则该阶段在初始完成后再进行。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h4><p>​    在初始化阶段，JVM会对类进行初始化，主要是执行类构造器方法（<clinit>()），静态变量的赋值和静态代码块的执行等。该构造器方法区别于类的构造函数或者说实例构造器（<init>()）方法，类构造器方法是类中的一个静态块，用于初始化静态变量或执行其他的类初始化操作。如果类没有静态变量或静态代码块，则初始化阶段会被跳过。</init></clinit></p><p>​    需要注意的是，类加载过程是按需加载的，即只有在需要使用类时才会进行加载。此外，JVM还提供了双亲委派机制，即先让父类加载器尝试加载类，如果父类加载器无法加载，则由当前类加载器进行加载。这种机制可以保证类的唯一性和安全性，避免重复加载和不同类加载器之间的类名冲突。</p><h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title=" 类加载器ClassLoader"></a><div id="classloader"> 类加载器ClassLoader</div></h2><p>​    <strong>.java</strong>文件通过编译后形成**.class**文件，在程序运行时使用该class文件，需要通过类加载器从内存加载进来处理。</p><p><img src="/../../images/jvm/jvm-classloader/1677832219825.png" alt="1677832219825"></p><p>​    在 JVM 中，类加载器用于查找、加载和链接Java类。Java虚拟机支持三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和系统类加载器（System Class Loader）。 </p><h3 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h3><p>​    启动类加载器是Java虚拟机内置的类加载器，负责加载Java核心类库，如java.lang和java.util等。启动类加载器是Java虚拟机内部实现的，不是Java类，因此无法用Java代码来实现和引用启动类加载器。该类加载器是用 C++ 实现，其他都是Java实现。</p><h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><p>​    扩展类加载器是Java虚拟机的内置类加载器之一，负责加载Java扩展库。Java扩展库包括Java虚拟机扩展机制所需的所有类，例如JNDI、JDBC和JavaMail等。扩展类加载器的父类加载器是启动类加载器。</p><h3 id="系统-x2F-应用程序类加载器（System-Class-Loader）"><a href="#系统-x2F-应用程序类加载器（System-Class-Loader）" class="headerlink" title="系统&#x2F;应用程序类加载器（System Class Loader）"></a>系统&#x2F;应用程序类加载器（System Class Loader）</h3><p>​    系统类加载器也称为应用类加载器，是Java虚拟机默认的类加载器，负责加载应用程序的类。系统类加载器通常从环境变量classpath或者Java命令的-cp选项指定的路径中查找类，它的父类加载器是扩展类加载器。</p><p>​    除了这三种内置类加载器之外，Java虚拟机还支持自定义类加载器。自定义类加载器可以实现特定的加载策略，例如从网络中动态加载类、从数据库中加载类或者从加密文件中加载类等。自定义类加载器必须继承 ClassLoader类，并重写findClass()方法，实现自己的类查找和加载策略。</p><p>​    <strong>需要注意的是，Java虚拟机中每个类加载器都有一个特定的命名空间，它只能加载它自己命名空间中的类。如果同一个类被不同的类加载器加载，那么它们在Java虚拟机中是不同的类，即使它们的字节码文件内容是相同的。这种机制可以保证类的唯一性和安全性，避免不同类加载器之间的类名冲突和安全隐患。</strong></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>​    由于类加载器存在层级关系，这种关系称为双亲委派模型。</p><p><img src="/../../images/jvm/jvm-classloader/1677850958450.png" alt="1677850958450"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>​    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器（Bootstrap ClassLoader）中，只有当父加载器反馈 自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 </p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>​    双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在某些特定情况下，可能需要打破双亲委派模型。具体方法如下：</p><ol><li>自定义类加载器</li></ol><p>​    自定义类加载器可以通过继承ClassLoader类并实现findClass()方法来打破双亲委派模型。如果一个类加载器自己能够完成类的加载任务，就不必委派给父类加载器，这种情况下可以打破双亲委派模型。</p><ol start="2"><li>线程上下文类加载器</li></ol><p>​    线程上下文类加载器可以通过Thread类的setContextClassLoader()方法来设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。在某些复杂的场景中，可能需要在不同的线程中使用不同的类加载器来加载类，这种情况下就需要使用线程上下文类加载器来打破双亲委派模型。</p><ol start="3"><li>OSGi和J2EE容器</li></ol><p>​    OSGi和J2EE容器等平台提供了自己的类加载器实现，可以在不同的模块中加载不同的类。这种情况下，打破双亲委派模型是必要的，否则会出现类加载失败或者类冲突等问题。</p><p><strong>需要注意的是，打破双亲委派模型可能会导致类的重复加载或者不同类加载器之间的类名冲突，从而导致程序运行出现问题。因此，在打破双亲委派模型时，需要谨慎考虑，确保程序的安全性和稳定性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初识类加载过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jwt</title>
      <link href="/2023/01/16/jwt/jwt/"/>
      <url>/2023/01/16/jwt/jwt/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h1><p><a href="https://jwt.io/introduction">官网jwt介绍</a></p><p>​JSON Web Token (JWT) is an open standard (<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the <strong>HMAC</strong> algorithm) or a public&#x2F;private key pair using <strong>RSA</strong> or <strong>ECDSA</strong>. </p><p>​翻译：JSON Web Token (JWT)是一个开放标准(rfc7519),它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥／私钥对进行签名 。</p><p>​通俗来说，JWT简称JSON Web Token，也就是通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p><h1 id="JWT能做什么"><a href="#JWT能做什么" class="headerlink" title="JWT能做什么"></a>JWT能做什么</h1><ol><li><p>授权</p><p>​这是使用JWT的最常见方案，一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。</p></li><li><p>信息交换</p><p>​JSON Web Token是在各方之间安全地<strong>传输信息</strong>的好方法。因为可以对JWT进行签名（例如，使用公钥／私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以<strong>验证内容是否遭到篡改</strong>。</p></li></ol><h1 id="为什么是JWT"><a href="#为什么是JWT" class="headerlink" title="为什么是JWT"></a>为什么是JWT</h1><h2 id="基于传统的Session认证"><a href="#基于传统的Session认证" class="headerlink" title="基于传统的Session认证"></a>基于传统的Session认证</h2><ol><li><p>认证方式<br>我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。 </p></li><li><p>认证流程<br><img src="/../images/jwt/1673842472937.png" alt="1673842472937"></p></li><li><p>暴露问题</p><ol><li><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p></li><li><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li><li><p>在前后端分离系统中就更加痛苦：如下图所示<br><img src="/../images/jwt/1673843150954.png" alt="1673843150954"></p><p>​也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是</p><p>sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</p></li></ol></li></ol><h2 id="基于JWT认证"><a href="#基于JWT认证" class="headerlink" title="基于JWT认证"></a>基于JWT认证</h2><p><img src="/../images/jwt/1673843325267.png" alt="1673843325267"></p><ol><li><p>认证流程</p><p>​首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p><p>​后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同111．zzz．xxx的字符串。</p><p>​后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</p><p>​前端在每次请求时将JWT放入HTTP Header中的Authorization位。（解决XSS和XSRF问题??????）</p><p>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p><p>​验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p></li><li><p>jwt优势</p><ul><li><p>简洁（Compact）：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p></li><li><p>自包含（Self—contained）：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li><li><p>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p></li><li><p>不需要在服务端保存会话信息，特别适用于分布式微服务。</p></li></ul></li></ol><h1 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h1><p>JWT通常为：xxxx.yyyyy.zzzzzHeader.Payload.Signature</p><ol><li>令牌组成<ol><li>标头(Header)<ul><li>标头通常由两部分组成：令牌的类型(即JWT)和所使用的签名算法，例如HMAC SHA256或RSA。它会使用Base64编码组成JWT结构的第一部分。<br>注意：<strong>Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span></span><br><span class="line"> <span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>有效载荷(Payload)<ul><li>令牌的第二部分是有效负载，其中包含声明。声明式有关实体(通常是用户)和其他数据的声明。同样的，它会使用Base64编码组成JWT结构的第二部分。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span></span><br><span class="line">  <span class="string">&quot;admin&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意：<strong>有效负载中不放用户敏感信息，如用户密码等</strong></li></ul></li><li>签名(Signature)<br>   前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过。（HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload) , secret)）<br>   签名的目的：最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</li></ol></li></ol><h1 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h1><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置90秒的对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.SECOND,<span class="number">90</span>);</span><br><span class="line"><span class="comment">//生成令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">    .withClaim(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;张三&quot;</span>)<span class="comment">//设置自定义用户名</span></span><br><span class="line">    .withExpiresAt(instance.getTime())<span class="comment">//设置过期时间</span></span><br><span class="line">    .sign(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>))；<span class="comment">//设置签名  保密  复杂</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出令牌</span></span><br><span class="line">System.out.println(token);</span><br></pre></td></tr></table></figure></li><li><p>根据令牌和签名解析数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(<span class="string">&quot;token!ahlgj&quot;</span>)).build;</span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">System.out.println(<span class="string">&quot;用户名&quot;</span>+decodedJWT.getClaim(<span class="string">&quot;username&quot;</span>).asString());</span><br><span class="line">System.out.println(<span class="string">&quot;过期时间：&quot;</span>+decodedJWT.getExpiresAt());</span><br></pre></td></tr></table></figure></li><li><p>常见异常信息</p></li></ol><ul><li>SignatureVerificationException: 签名不一致异常</li><li>TokenExpiredException： 令牌过期异常</li><li>AlgorithmMismatchException:  算法不匹配异常</li><li>InvalidClaimException:  失效的payload异常</li></ul><ol start="5"><li><p>封装工具类<br>方式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtils</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SING</span> <span class="operator">=</span> <span class="string">&quot;hnalhjg&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    生成token   header.payload.sing</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getToken</span><span class="params">(Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.add(Calendar.DATE,<span class="number">7</span>);<span class="comment">//默认7天过期</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建jwt builder</span></span><br><span class="line">        JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            builder.withClaim(k,v);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> builder.withExpiresAt(instance.getTime()) <span class="comment">//指定令牌过期时间</span></span><br><span class="line">            .sign(Algorithm.HMAC256(SING));<span class="comment">//sign</span></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    验证token 合法性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SING)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expire;</span><br><span class="line">    <span class="keyword">private</span> String header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(date)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime() + <span class="number">1000</span> * expire))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, key)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">parserToken</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                    .setSigningKey(key)</span><br><span class="line">                    .parseClaimsJws(jwt)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//token是否过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpire</span><span class="params">(Claims claims)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt的基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx基础入门</title>
      <link href="/2023/01/07/nginx/nginx/"/>
      <url>/2023/01/07/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx简介"><a href="#nginx简介" class="headerlink" title="nginx简介"></a>nginx简介</h1><p>说明：<a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=1&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址来源</a> </p><p>​Nginx（＂engine x＂）是一个高性能的HTTP和反向代理服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好</p><p>​Nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50，000个并发连接数。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><div id="res">反向代理</div></h2><p>​反向代理：其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择(转发)目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。  </p><p><img src="/../images/nginx/1672465996506.png" alt="1672465996506"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​正向代理：如果把局域网外的Intemet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。  在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问。</p><p><img src="/../images/nginx/1672465637077.png" alt="1672465637077"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>​客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p><p>​这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？</p><p>​* **单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡  ***</p><p><img src="/../images/nginx/1672466554613.png" alt="1672466554613"></p><h2 id="动态分离"><a href="#动态分离" class="headerlink" title="动态分离"></a>动态分离</h2><p>​为了加快网站的解析速度，可以把动态页面和静态页面有不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><img src="/../images/nginx/1672466852524.png" alt="1672466852524"></p><h1 id="nginx的安装与启动"><a href="#nginx的安装与启动" class="headerlink" title="nginx的安装与启动"></a>nginx的安装与启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p><a href="http://nginx.org/en/download.html">官网下载</a> nginx压缩包，本次为Linux下安装，选择如下：<br><img src="/../images/nginx/1672583906360.png" alt="1672583906360"></p></li><li><p>登录linux，并上传该文件到Linux下，用Winscp上传文件</p><p><img src="/../images/nginx/1672584047837.png" alt="1672584047837"></p><p>附：可用sftp命令上传。。。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接linux</span></span><br><span class="line">sftp [root@192.168...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录成功后，所有的l开头都是代表操作本机，不带l的是操作linux</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在确定好要将本机的文件上传到linux的位置后</span></span><br><span class="line">put 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用命令</span></span><br><span class="line">help  # 看支持哪些命令</span><br><span class="line">pwd &amp; lpwd  # linux当前目录与本机当前工作目录</span><br><span class="line">ls &amp; lls # linux当前目录下的文件，本机当前目录的文件</span><br><span class="line">put a.txt # 将本机a.txt文件上传到linux</span><br><span class="line">get b.txt # 从linux中下载文件到本机</span><br><span class="line">exit &amp; quit # 退出</span><br></pre></td></tr></table></figure></li><li><p>一键安装nginx相关依赖库</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc openssl openssl-devel pcre pcre-devel zlib zlib-devel -y</span><br></pre></td></tr></table></figure><p>   说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- gcc : 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境 </span><br><span class="line">- pcre pcre-devel : pcre(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库,nginx也需要此库。</span><br><span class="line">- zlib : zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</span><br><span class="line">- openssl openssl-devel : OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 </span><br></pre></td></tr></table></figure><ol><li><p>开始安装nginx</p></li><li><p>创建一个nginx文件夹,并进行nginx压缩包的解压</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件夹</span></span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将压缩包解压到当前文件夹中</span></span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz -C /usr/local/nginx# tar -zxvf 压缩包名 -C 指定目录</span><br></pre></td></tr></table></figure></li><li><p>编译并安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx目录</span></span><br><span class="line">cd /usr/local/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd nginx-1.18.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make命令进行编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行make install命令进行安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>安装完后会有conf文件夹，进入nginx.conf文件中配置端口号与ip(与虚拟机ip一致)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开nginx.conf配置文件</span></span><br><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改端口号与ip</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586130429.png" alt="1672586130429"></p></li></ol><h2 id="测试、启动与关闭"><a href="#测试、启动与关闭" class="headerlink" title="测试、启动与关闭"></a>测试、启动与关闭</h2><ol><li><p>查看版本号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -v</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -v</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure></li><li><p>查看是否启动成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginxz</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672586390937.png" alt="1672586390937"></p></li><li><p>配置过nginx.conf文件，进行刷新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s reload</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入nginx安装路径下sbin文件夹中执行./nginx -s stop</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开放的端口号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式：firewall-cmd --add-service=http --permanent</span></span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>本机浏览器输入虚拟机ip</p><p><img src="/../images/nginx/1672586743935.png" alt="1672586743935"></p><h1 id="nginx配置文件说明"><a href="#nginx配置文件说明" class="headerlink" title="nginx配置文件说明"></a>nginx配置文件说明</h1><p>配置文件位置：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p><p>nginx配置文件由三大部分组成，分为全局块、events块、http块</p><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>​从配置文件开始到 events块之间的内容，主要会设置一些影响 <strong>nginx服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的worker process 数，进程 PID存放路径、日志存放路径和类型以及配置文件的引入等</strong>。 如：</p><p><img src="/../images/nginx/1672627362232.png" alt="1672627362232"></p><p>​这是Nginx 服务器并发处理服务的关键配置，worker＿processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约</p><h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><p>​events 块涉及的指令主要影响 <strong>Nginx 服务器与用户的网络连接</strong>，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。</p><p><img src="/../images/nginx/1672627668523.png" alt="1672627668523"></p><p>​上述例子就表示每个 work process 支持的最大连接数为1024．</p><p>​这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。</p><h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>http块也包括http全局块(http的全局配置)以及server块。</p><ol><li><p>http全局块<br>http 全局块配置的指令包括文件引入、MIME—TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>  <img src="/../images/nginx/1672627926561.png" alt="1672627926561"></p></li><li><p>http块<br>整个大的http包裹的就是http块，可以嵌套多个server</p></li><li><p>server块</p><p>​这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p><p>​每个 http块可以包括多个 server块，而每个server块就相当于一个虚拟主机。而每个 server块也分为全局server块，以及可以同时包含多个locaton块。</p><ol><li><p>全局server块<br>最常见的本虚拟机主机的监听配置和本虚拟机的名称或ip配置</p></li><li><p>location块</p><p>​一个server块可以配置多个location块。</p><p>​这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server-name&#x2F;uri-string），对虚以主机名称（也可以是IP别名）之外的字符串（例如前面的&#x2F;uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。即：<strong>配置请求的路由，以及各种页面 的处理情况</strong>。</p></li></ol></li></ol><h1 id="nginx配置实例-反向代理1"><a href="#nginx配置实例-反向代理1" class="headerlink" title="nginx配置实例-反向代理1"></a>nginx配置实例-反向代理1</h1><p>反向代理原理请参考<a href="#res">1.1反向代理</a></p><p>要实现的效果：</p><p>​打开浏览器，输入网址，跳转到linux系统的tomcat主页</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在linux系统下安装tomcat，使用默认端口8080,并在本地测试是否成功。</p><ol><li><p><a href="https://tomcat.apache.org/download-90.cgi">官网下载 </a> tomcat压缩包<br><img src="/../images/nginx/1672632380038.png" alt="1672632380038"></p></li><li><p>将压缩包上传到linux系统中</p></li><li><p>解压到&#x2F;usr&#x2F;src下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>centos默认安装了jdk，直接进入bin目录启动tomcat|</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/apache-tomcat-9.0.70/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动tomcat</span></span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙或开放8080端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放8080端口</span></span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口号</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问linux<br><img src="/../images/nginx/1672632912754.png" alt="1672632912754"></p></li></ol></li></ol><h2 id="访问过程分析"><a href="#访问过程分析" class="headerlink" title="访问过程分析"></a>访问过程分析</h2><p><img src="/../images/nginx/1672633212388.png" alt="1672633212388"></p><h2 id="配置本地host文件"><a href="#配置本地host文件" class="headerlink" title="配置本地host文件"></a>配置本地host文件</h2><ol><li>在C:\Windows\System32\drivers\etc下，修改hosts文件。添加一个本机域名地址：</li></ol><p><img src="/../images/nginx/1672646981434.png" alt="1672646981434"></p><ol><li>在启动了tomcat的情况下，输入地址<a href="http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。">http://www.123.com:8080可以访问到tomcat。此时相当于直接访问tomcat。</a><br><img src="/../images/nginx/1672647258790.png" alt="1672647258790"></li><li>配置nginx的配置文件，并启动nginx<br><img src="/../images/nginx/1672647451217.png" alt="1672647451217"></li><li>测试<br>浏览器输入<a href="http://www.123.com,通过nginx的配置,将该请求转发到http//127.0.0.1:8080%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84127.0.0.1%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%AC%E6%9C%BAip%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">www.123.com，通过nginx的配置，将该请求转发到http://127.0.0.1:8080，此时的127.0.0.1代表的是虚拟机本机ip，结果如下：</a><br><img src="/../images/nginx/1672647631481.png" alt="1672647631481"></li></ol><h1 id="nginx配置实例-反向代理2"><a href="#nginx配置实例-反向代理2" class="headerlink" title="nginx配置实例-反向代理2"></a>nginx配置实例-反向代理2</h1><p>想要实现的效果：</p><p>​使用nginx反向代理，根据访问的路径跳转到不同端口的服务中，nginx监听的端口为9001。如：</p><ol><li>访问<a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> ,直接跳转到127.0.0.1:8081</li><li>访问<a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> ,直接跳转到127.0.0.1:8082</li></ol><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>准备两个tomcat服务器，一个8080端口，一个8081端口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/usr/src下创建2个文件夹</span></span><br><span class="line">cd /usr/src</span><br><span class="line">mkdir tomcat8080</span><br><span class="line">mkdir tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/usr/src下的tomcat压缩包分别拷贝到这2个文件夹中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式：<span class="built_in">cp</span> 要拷贝的文件名 指定拷贝到的目录</span></span><br><span class="line">cd /usr/src</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8080</span><br><span class="line">cp apache-tomcat-9.0.70.tar.gz tomcat8081</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别解压这两个压缩包</span></span><br><span class="line">cd tomcat8080</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line">cd tomcat8081</span><br><span class="line">tar -zxvf apache-tomcat-9.0.70.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改tomcat8081文件夹下的tomcat端口，改为8081</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/conf</span><br><span class="line">vi server.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672657513308.png" alt="1672657513308"></p><p><img src="/../images/nginx/1672657571433.png" alt="1672657571433"></p></li></ol><p><img src="/../images/nginx/1672657600381.png" alt="1672657600381"></p><ol><li><p>分别启动这两个tomcat</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8080端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动8081端口的tomcat</span></span><br><span class="line">cd /usr/src/tomcat8081/apache-tomcat-9.0.70/bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li><li><p>创建一些访问的页面(windows上传过来a.html也行)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/tomcat8080/apache-tomcat-9.0.70/webapps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个文件</span></span><br><span class="line">mkdir edu/a.html</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658101588.png" alt="1672658101588"></p><p>同样方法创建一个vod&#x2F;a.html在端口为8081的tomcat中。</p></li></ol><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>配置nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在http块中添加如下内容</span></span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658389765.png" alt="1672658389765"></p></li><li><p>开放8080、8081、9001端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8081/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=9001/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放的端口</span></span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1672658662276.png" alt="1672658662276"></p></li><li><p>测试<br>通过访问不同的文件，nginx转发到不同的端口</p><p>访问<a href="http://192.168.52.128:9001/edu/a.html">192.168.52.128:9001&#x2F;edu&#x2F;a.html</a>  ：</p><p><img src="/../images/nginx/1672658799404.png" alt="1672658799404"></p><p>访问<a href="http://192.168.52.128:9001/vod/a.html">192.168.52.128:9001&#x2F;vod&#x2F;a.html</a> ：</p><p><img src="/../images/nginx/1672658827810.png" alt="1672658827810"></p></li></ol><p>但是现在依然能够不通过nginx，直接进行tomcat的访问，如直接访问8081：</p><p><img src="/../images/nginx/1672658906294.png" alt="1672658906294"></p><p>可以把8080端口与8081端口关闭，达到只能通过9001端口进行访问8080端口的tomcat资源或8081端口的tomcat资源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭8080端口</span></span><br><span class="line">firewall-cmd --remove-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="关于nginx配置文件的location的配置说明"><a href="#关于nginx配置文件的location的配置说明" class="headerlink" title="关于nginx配置文件的location的配置说明"></a>关于nginx配置文件的location的配置说明</h3><p>该指令用于匹配URL。语法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~] uri &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>&#x3D; : 用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</li><li>~ ： 用于表示uri包含正则表达式，并且区分大小写。</li><li>~* ：用于表示uri包含正则表达式，并且不区别大小写。</li><li>^~ : 用于不含正在表达式的uri前，要求nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。<br><em><em>注意：如果uri包含正则表达式，则必须要有 ~ 或者 ~</em> 标识</em>*</li></ol><h1 id="nginx配置实例-负载均衡"><a href="#nginx配置实例-负载均衡" class="headerlink" title="nginx配置实例-负载均衡"></a>nginx配置实例-负载均衡</h1><p>想要实现的效果：</p><ol><li>浏览器地址栏输入地址 <a href="http://192.168.52.128/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%B9%B3%E5%9D%87%E8%BD%AC%E5%8F%91%E7%BB%998080%E5%92%8C8081%E7%AB%AF%E5%8F%A3%E3%80%82">http://192.168.52.128/edu/a.html，负载均衡效果：请求平均转发给8080和8081端口。</a></li></ol><h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备两台tomcat服务器，一台8080端口，一台8081<br>根据前面的配置的方向代理实例已经配置好了两台tomcat服务器。</li><li>在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建页面a.html，用于测试|<br><img src="/../images/nginx/1673003516724.png" alt="1673003516724"></li></ol><h2 id="在nginx的配置文件中进行负载均衡的配置"><a href="#在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="在nginx的配置文件中进行负载均衡的配置"></a>在nginx的配置文件中进行负载均衡的配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>   <img src="/../images/nginx/1673003654331.png" alt="1673003654331"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>​在浏览器中输入 <a href="http://192.168.52.128/edu/a.html">http://192.168.52.128/edu/a.html</a> 进行测试，访问一次便刷新一次，效果就是不断依次访问到两个服务器的资源。</p><h2 id="关于nginx分配服务器（负载均衡）的几种策略"><a href="#关于nginx分配服务器（负载均衡）的几种策略" class="headerlink" title="关于nginx分配服务器（负载均衡）的几种策略"></a>关于nginx分配服务器（负载均衡）的几种策略</h2><ol><li><font color="red">轮询(默认)</font><br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉（宕机），能自动剔除。</li><li>weight<br>weight代表权重，默认为1，权重越高被分配的客户端越多。<br><img src="/../images/nginx/1673004386609.png" alt="1673004386609"></li><li>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器，可以解决session的问题。<br><img src="/../images/nginx/1673004591334.png" alt="1673004591334"></li><li>fair(第三方，此配置需要装插件)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><img src="/../images/nginx/1673004829929.png" alt="1673004829929"></li></ol><h1 id="nginx配置实例-动静分离"><a href="#nginx配置实例-动静分离" class="headerlink" title="nginx配置实例-动静分离"></a>nginx配置实例-动静分离</h1><p>​Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过nginx 来分开。</p><p>​通过location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p><p>​具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires 来缓存），我这里设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><img src="/../images/nginx/1673056715488.png" alt="1673056715488"></p><h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>​在linux系统中准备静态资源，用于进行访问。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir data</span><br><span class="line">cd data</span><br><span class="line">mkdir www</span><br><span class="line">mkdir image</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673058624024.png" alt="1673058624024"></p><p>​在image中添加静态资源a.png,在www下添加a.html</p><p><img src="/../images/nginx/1673058664898.png" alt="1673058664898"></p><p><img src="/../images/nginx/1673058781285.png" alt="1673058781285"></p><h2 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h2><ol><li><p>在nginx的配置文件中进行配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/../images/nginx/1673059330164.png" alt="1673059330164"></p></li><li><p>启动nginx后进行测试</p><p>访问静态资源：</p><p><img src="/../images/nginx/1673059651262.png" alt="1673059651262"><br>配置了autoindex on;  ：表示是否将所有资源以列表的形式列举出来。</p><p><img src="/../images/nginx/1673060605982.png" alt="1673060605982"></p></li></ol><h1 id="nginx配置实例-高可用"><a href="#nginx配置实例-高可用" class="headerlink" title="nginx配置实例-高可用"></a>nginx配置实例-高可用</h1><p><img src="/../images/nginx/1673061314633.png" alt="1673061314633"></p><p>nginx宕机则会出现无法访问到tomcat，使用高可用解决该问题，如下图：</p><p><img src="/../images/nginx/1673061394135.png" alt="1673061394135"></p><p>如果nginx主服务器宕机，则通过nginx的备用服务器访问tomcat。</p><p><a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=14&vd_source=3b8b9bda5c06f05c6d39829ba8e4f3fe">视频地址：14-nginx配置实例（高可用准备工作）_哔哩哔哩_bilibili</a> </p><p><a href="https://www.cnblogs.com/SimpleWu/p/11004902.html">参考：生产环境之Nginx高可用方案 - 日落西风又在吹 - 博客园 </a> </p><p><a href="https://besterwin.gitee.io/blogs/knowledge/middle/Nginx.html">脑图参考：Nginx.mmap (gitee.io)</a> </p><h1 id="nginx的原理解析"><a href="#nginx的原理解析" class="headerlink" title="nginx的原理解析"></a>nginx的原理解析</h1><p>进程模型：</p><p><img src="/../images/nginx/nginx.webp" alt="img"> </p><ol><li>在nginx启动后，会有一个master进程和多个worker进程，master进程主要用来管理worker进程，包括：接受信号，将信号分发给worker进程，监听worker进程工作状态，当worker进程退出时(非正常)，启动新的worker进程。基本的网络事件会交给worker进程处理。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 。</li><li>当master接收到重新加载的信号会怎么处理(.&#x2F;nginx -s reload)?，master会重新加载配置文件，然后启动新的进程，使用的新的worker进程来接受请求，并告诉老的worker进程他们可以退休了，老的worker进程将不会接受新的，老的worker进程处理完手中正在处理的请求就会退出。</li><li>worker进程是如何处理用户的请求呢？首先master会根据配置文件生成一个监听相应端口的socket，然后再faster出多个worker进程，这样每个worker就可以接受从socket过来的消息（其实这个时候应该是每一个worker都有一个socket，只是这些socket监听的地址是一样的）。当一个连接过来的时候，每一个worker都能接收到通知，但是只有一个worker能和这个连接建立关系，其他的worker都会连接失败，这就是所谓的惊群现在，为了解决这个问题，nginx提供一个共享锁accept_mutex，有了这个共享锁后，就会只有一个worker去接收这个连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。</li></ol><p><a href="https://blog.csdn.net/wangbiao007/article/details/82910709">nginx原理参考</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础常见问题</title>
      <link href="/2022/12/20/Java/JavaSE/"/>
      <url>/2022/12/20/Java/JavaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h1><h2 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1. JDK和JRE有什么区别？"></a>1. JDK和JRE有什么区别？</h2><p>JDK：Java Development Kit的简称，java开发工具包，提供了java的开发环境和运行环境。<br>JRE: Java Runtime Environment的简称，java运行环境，为java的运行提供了所需环境。<br>具体来说JDK其实包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具。简单来说：如果你需要运行java程序，只需要安装JRE就可以了，如果你需要编写java程序，需要安装JDK。</p><h2 id="2-x3D-x3D-和-equals的区别是什么？"><a href="#2-x3D-x3D-和-equals的区别是什么？" class="headerlink" title="2. &#x3D;&#x3D; 和 equals的区别是什么？"></a>2. &#x3D;&#x3D; 和 equals的区别是什么？</h2><ol><li>却别： equals是方法，而 &#x3D;&#x3D; 是操作符；</li><li>对于基本数据类型（short、int、long、float、double）来说，只能使用 &#x3D;&#x3D; 比较值</li><li>对于引用数据类型来说，需要分情况<ul><li>没有重写Object类的equals方法，则用 &#x3D;&#x3D; 比较的是存放的地址。</li><li>重写了Object类的equals方法，如String类，看源码是用 &#x3D;&#x3D; 先进行引用(存放地址)的比较，如果不等，再进行值的比较</li></ul></li></ol><p>总结：<br><font color="red">&#x3D;&#x3D;对于基本数据类型来说是值比较；对于引用数据类型来说，比较的是引用；而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String（先比较引用，再比较值）、Integer（值比较）等把它变成了值比较，所以一般情况下equals比较的是值是否相等</font></p><h2 id="3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？"><a href="#3-两个对象的hashCode-值相同，则equals-也一定为true，对吗？" class="headerlink" title="3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？"></a>3. 两个对象的hashCode()值相同，则equals()也一定为true，对吗？</h2><p><font color="red">不对，两个对象的hashCode()相同，equals()不一定为true。</font></p><p>如字符串“通话”、“重地”,这两个字符串的hash相同（用固定公式计算hash），但a.equals(b)是不一样的。</p><h2 id="4-final在java中有什么作用？"><a href="#4-final在java中有什么作用？" class="headerlink" title="4. final在java中有什么作用？"></a>4. final在java中有什么作用？</h2><ul><li>final修饰的类叫最终类，该类不能被继承。</li><li>final修饰的方法不能被重写。</li><li>final修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="5-java中的Math-round-1-5-等于多少？"><a href="#5-java中的Math-round-1-5-等于多少？" class="headerlink" title="5. java中的Math.round(-1.5)等于多少？"></a>5. java中的Math.round(-1.5)等于多少？</h2><p>等于-1，因为在数轴上取值是，中间值(0.5)向右取整，所以整0.5是往上取整，负0.5是直接舍弃。</p><h2 id="6-String属于基础的数据类型吗？"><a href="#6-String属于基础的数据类型吗？" class="headerlink" title="6. String属于基础的数据类型吗？"></a>6. String属于基础的数据类型吗？</h2><p>String不属于基础类型，基础类型有8中，byte(1)、boolean、char(2)、short(2)、int(4)、float(4)、long(8)、double(8)，而String属于对象（引用数据类型）</p><h2 id="7-java中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java中操作字符串都有哪些类？它们之间有什么区别？"></a>7. java中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会⽣成新的String 对象，然后将指针指向新的 String 对象；⽽ StringBuffer、StringBuilder 可以在原有对象的基础上进⾏操作，所以在经常改变字符串内容的情况下最好不要使⽤ String。</p><p>StringBuffer 和 StringBuilder 最⼤的区别在于，StringBuffer 是线程安全的，⽽ StringBuilder 是⾮线程安全的，但 StringBuilder 的性能却⾼于StringBuffer，所以在单线程环境下推荐使⽤ StringBuilder，多线程环境下推荐使⽤ StringBuffer。</p><h2 id="8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？"><a href="#8-String-str-x3D-”i”与String-str-x3D-new-String（”i”）一样吗？" class="headerlink" title="8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？"></a>8. String str&#x3D;”i”与String str &#x3D; new String（”i”）一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str &#x3D; “i”的方式，java虚拟机会将其分配到常量池中；而String str &#x3D; new String（”i”）则会被分到堆内存中。</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><p>使用StringBuilder或者StringBuffer的reverse()方法。</p><h2 id="10-String类的常用方法都有哪些？"><a href="#10-String类的常用方法都有哪些？" class="headerlink" title="10. String类的常用方法都有哪些？"></a>10. String类的常用方法都有哪些？</h2><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白（空格）</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的byte类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字母。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li><li>compareTo()：按字典顺序比较大小。</li></ul><h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。（有抽象方法的类必定是抽象类）</p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h2 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13. 抽象类能使用final修饰吗？"></a>13. 抽象类能使用final修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以使任意访问修饰符。</li></ul><h2 id="15-java中IO流分为几种？"><a href="#15-java中IO流分为几种？" class="headerlink" title="15. java中IO流分为几种？"></a>15. java中IO流分为几种？</h2><ol><li>按功能分<ul><li>输入流（input）</li><li>输出流（output）</li></ul></li><li>按类型分<ul><li>字节流</li><li>字符流<br>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字节流按16位传输以字符为单位输入输出数据。</li></ul></li></ol><h2 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16. BIO、NIO、AIO有什么区别？"></a>16. BIO、NIO、AIO有什么区别？</h2><ul><li>BIO：Block IO同步阻塞IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO (或Non Blocking IO) 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel(通道)通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制。</li></ul><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h2><ul><li>Files.exists()：检测⽂件路径是否存在。</li><li>Files.createFile()：创建⽂件。</li><li>Files.createDirectory()：创建⽂件夹。</li><li>Files.delete()：删除⼀个⽂件或⽬录。</li><li>Files.copy()：复制⽂件。</li><li>Files.move()：移动⽂件。</li><li>Files.size()：查看⽂件个数。</li><li>Files.read()：读取⽂件。</li><li>Files.write()：写⼊⽂件。</li></ul><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示："><a href="#1-java-容器分为-Collection-和-Map-两⼤类，其下⼜有很多⼦类，如下所示：" class="headerlink" title="1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示："></a>1. java 容器分为 Collection 和 Map 两⼤类，其下⼜有很多⼦类，如下所示：</h2><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector<ul><li>Stack</li></ul></li></ul></li><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeSet</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol><li>Collection 是⼀个集合接⼝，它提供了对集合对象进⾏基本操作的通⽤接⼝⽅法，所有集合都是它的⼦类，比如 List、Set 等。</li><li>Collections 是⼀个包装类，包含了很多静态⽅法，不能被实例化，就像⼀个⼯具类，⽐如提供的排序⽅法： Collections.sort(list)。</li></ol><h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个⽅⾯：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br><img src="/../images/JavaSE/2022-12-02-13-46-08.png"></p><h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：HashMap 允许 key 和 value 为 null，⽽ Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，⽽ HashMap 是⾮线程安全的。</li><li>推荐使⽤：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使⽤，推荐在单线程环境下使⽤ HashMap 替代，如果需要多线程使⽤则⽤ ConcurrentHashMap 替代。</li></ul><h2 id="5-如何决定使⽤-HashMap-还是-TreeMap？"><a href="#5-如何决定使⽤-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使⽤ HashMap 还是 TreeMap？"></a>5. 如何决定使⽤ HashMap 还是 TreeMap？</h2><p>   对于在 Map 中插⼊、删除、定位⼀个元素这类操作，HashMap 是最好的选择，因为相对⽽⾔ HashMap的插⼊会更快，但如果你要对⼀个 key 集合进⾏有序的遍历，那 TreeMap 是更好的选择。</p><h2 id="6-说⼀下-HashMap-的实现原理？"><a href="#6-说⼀下-HashMap-的实现原理？" class="headerlink" title="6. 说⼀下 HashMap 的实现原理？"></a>6. 说⼀下 HashMap 的实现原理？</h2><p>   HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传⼊ key 时，HashMap 会根据 key.hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket ⾥。当计算出的hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是⽤链表和红⿊树存储相同 hash 值的 value。<br>当 hash 冲突的个数⽐较少时，使⽤链表否则使⽤红⿊树。</p><h2 id="7-说⼀下-HashSet-的实现原理？"><a href="#7-说⼀下-HashSet-的实现原理？" class="headerlink" title="7. 说⼀下 HashSet 的实现原理？"></a>7. 说⼀下 HashSet 的实现原理？</h2><p>   HashSet 是基于 HashMap 实现的，HashSet 底层使⽤ HashMap 来保存所有元素，因此 HashSet 的实现⽐较简单，相关 HashSet 的操作，基本上都是直接调⽤底层 HashMap 的相关⽅法来完成，HashSet 不允许重复的值。</p><h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，⽽ LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList ⽐ LinkedList 在随机访问的时候效率要⾼，因为 LinkedList 是线性的数据存储⽅式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在⾮⾸尾的增加和删除操作，LinkedList 要⽐ ArrayList 效率要⾼，因为 ArrayList增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使⽤ ArrayList，⽽在插⼊和删除操作较多时，更推荐<br>使⽤ LinkedList。</p><h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使⽤ Arrays.asList(array) 进⾏转换。</li><li>List 转数组：使⽤ List ⾃带的 toArray() ⽅法。</li></ul><h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul><li>线程安全：Vector 使⽤了 Synchronized 来实现线程同步，是线程安全的，⽽ ArrayList 是⾮线程安全的。</li><li>性能：ArrayList 在性能⽅⾯要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1倍，⽽ ArrayList 只会增加 50%。</li></ul><h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定⼤⼩的，⽽ ArrayList ⼤⼩是⾃动扩展的。</li><li>Array 内置⽅法没有 ArrayList 多，⽐如 addAll、removeAll、iteration 等⽅法只有 ArrayList 有。</li></ul><h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul><li>相同点：都是返回第⼀个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，⽽ remove()会直接抛出 NoSuchElementException 异常。</li></ul><h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，⽽像 HashMap 则是⾮线程安全的，不过在 jdk 1.5 之后随着java.util.concurrent 并发包的出现，它们也有了⾃⼰对应的线程安全类，⽐如 HashMap 对应的线程安全类就是ConcurrentHashMap。</p><h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><p>Iterator 接⼝提供遍历任何 Collection 的接⼝。我们可以从⼀个 Collection 中使⽤迭代器⽅法来获取迭代器实例。迭代器取代了 java 集合框架中的Enumeration，迭代器允许调⽤者在迭代过程中移除元素。</p><h2 id="15-Iterator-怎么使⽤？有什么特点？"><a href="#15-Iterator-怎么使⽤？有什么特点？" class="headerlink" title="15. Iterator 怎么使⽤？有什么特点？"></a>15. Iterator 怎么使⽤？有什么特点？</h2><p>使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p><h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator 可以遍历 Set 和 List 集合，⽽ ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，⽽ ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接⼝继承，然后添加了⼀些额外的功能，⽐如添加⼀个元素、替换⼀个元素、获取前⾯或后⾯元素的索引位置。</li></ul><h2 id="17-怎么确保⼀个集合不能被修改？"><a href="#17-怎么确保⼀个集合不能被修改？" class="headerlink" title="17. 怎么确保⼀个集合不能被修改？"></a>17. 怎么确保⼀个集合不能被修改？</h2><p>可以使⽤ Collections.unmodifiableCollection(Collection c) ⽅法来创建⼀个只读集合，这样改变集合的任何操作都会抛出 java.lang.UnsupportedOperationException 异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运⾏时此⾏报错</span></span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
